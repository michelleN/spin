// Generated by `wit-bindgen` 0.12.0. DO NOT EDIT!
pub mod fermyon {
  pub mod spin {
    
    #[allow(clippy::all)]
    pub mod http_types {
      #[used]
      #[doc(hidden)]
      #[cfg(target_arch = "wasm32")]
      static __FORCE_SECTION_REF: fn() = super::super::super::__link_section;
      pub type HttpStatus = u16;
      pub type Body = wit_bindgen::rt::vec::Vec::<u8>;
      pub type Headers = wit_bindgen::rt::vec::Vec::<(wit_bindgen::rt::string::String,wit_bindgen::rt::string::String,)>;
      pub type Params = wit_bindgen::rt::vec::Vec::<(wit_bindgen::rt::string::String,wit_bindgen::rt::string::String,)>;
      pub type Uri = wit_bindgen::rt::string::String;
      #[repr(u8)]
      #[derive(Clone, Copy, Eq, PartialEq)]
      pub enum Method {
        Get,
        Post,
        Put,
        Delete,
        Patch,
        Head,
        Options,
      }
      impl ::core::fmt::Debug for Method {
        fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
          match self {
            Method::Get => {
              f.debug_tuple("Method::Get").finish()
            }
            Method::Post => {
              f.debug_tuple("Method::Post").finish()
            }
            Method::Put => {
              f.debug_tuple("Method::Put").finish()
            }
            Method::Delete => {
              f.debug_tuple("Method::Delete").finish()
            }
            Method::Patch => {
              f.debug_tuple("Method::Patch").finish()
            }
            Method::Head => {
              f.debug_tuple("Method::Head").finish()
            }
            Method::Options => {
              f.debug_tuple("Method::Options").finish()
            }
          }
        }
      }
      
      impl Method{
        pub(crate) unsafe fn _lift(val: u8) -> Method{
          if !cfg!(debug_assertions) {
            return ::core::mem::transmute(val);
          }
          
          match val {
            0 => Method::Get,
            1 => Method::Post,
            2 => Method::Put,
            3 => Method::Delete,
            4 => Method::Patch,
            5 => Method::Head,
            6 => Method::Options,
            
            _ => panic!("invalid enum discriminant"),
          }
        }
      }
      
      #[derive(Clone)]
      pub struct Request {
        pub method: Method,
        pub uri: Uri,
        pub headers: Headers,
        pub params: Params,
        pub body: Option<Body>,
      }
      impl ::core::fmt::Debug for Request {
        fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
          f.debug_struct("Request").field("method", &self.method).field("uri", &self.uri).field("headers", &self.headers).field("params", &self.params).field("body", &self.body).finish()
        }
      }
      #[derive(Clone)]
      pub struct Response {
        pub status: HttpStatus,
        pub headers: Option<Headers>,
        pub body: Option<Body>,
      }
      impl ::core::fmt::Debug for Response {
        fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
          f.debug_struct("Response").field("status", &self.status).field("headers", &self.headers).field("body", &self.body).finish()
        }
      }
      #[repr(u8)]
      #[derive(Clone, Copy, Eq, PartialEq)]
      pub enum HttpError {
        Success,
        DestinationNotAllowed,
        InvalidUrl,
        RequestError,
        RuntimeError,
        TooManyRequests,
      }
      impl HttpError{
        pub fn name(&self) -> &'static str {
          match self {
            HttpError::Success => "success",
            HttpError::DestinationNotAllowed => "destination-not-allowed",
            HttpError::InvalidUrl => "invalid-url",
            HttpError::RequestError => "request-error",
            HttpError::RuntimeError => "runtime-error",
            HttpError::TooManyRequests => "too-many-requests",
          }
        }
        pub fn message(&self) -> &'static str {
          match self {
            HttpError::Success => "",
            HttpError::DestinationNotAllowed => "",
            HttpError::InvalidUrl => "",
            HttpError::RequestError => "",
            HttpError::RuntimeError => "",
            HttpError::TooManyRequests => "",
          }
        }
      }
      impl ::core::fmt::Debug for HttpError{
        fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
          f.debug_struct("HttpError")
          .field("code", &(*self as i32))
          .field("name", &self.name())
          .field("message", &self.message())
          .finish()
        }
      }
      impl ::core::fmt::Display for HttpError{
        fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
          write!(f, "{} (error {})", self.name(), *self as i32)
        }
      }
      
      impl std::error::Error for HttpError{}
      
      impl HttpError{
        pub(crate) unsafe fn _lift(val: u8) -> HttpError{
          if !cfg!(debug_assertions) {
            return ::core::mem::transmute(val);
          }
          
          match val {
            0 => HttpError::Success,
            1 => HttpError::DestinationNotAllowed,
            2 => HttpError::InvalidUrl,
            3 => HttpError::RequestError,
            4 => HttpError::RuntimeError,
            5 => HttpError::TooManyRequests,
            
            _ => panic!("invalid enum discriminant"),
          }
        }
      }
      
      
    }
    
    
    #[allow(clippy::all)]
    pub mod config {
      #[used]
      #[doc(hidden)]
      #[cfg(target_arch = "wasm32")]
      static __FORCE_SECTION_REF: fn() = super::super::super::__link_section;
      #[derive(Clone)]
      pub enum Error{
        Provider(wit_bindgen::rt::string::String),
        InvalidKey(wit_bindgen::rt::string::String),
        InvalidSchema(wit_bindgen::rt::string::String),
        Other(wit_bindgen::rt::string::String),
      }
      impl ::core::fmt::Debug for Error {
        fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
          match self {
            Error::Provider(e) => {
              f.debug_tuple("Error::Provider").field(e).finish()
            }
            Error::InvalidKey(e) => {
              f.debug_tuple("Error::InvalidKey").field(e).finish()
            }
            Error::InvalidSchema(e) => {
              f.debug_tuple("Error::InvalidSchema").field(e).finish()
            }
            Error::Other(e) => {
              f.debug_tuple("Error::Other").field(e).finish()
            }
          }
        }
      }
      impl ::core::fmt::Display for Error {
        fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
          write!(f, "{:?}", self)
        }
      }
      
      impl std::error::Error for Error {}
      #[allow(clippy::all)]
      pub fn get_config(key: &str,) -> Result<wit_bindgen::rt::string::String,Error>{
        
        #[allow(unused_imports)]
        use wit_bindgen::rt::{alloc, vec::Vec, string::String};
        unsafe {
          
          #[repr(align(4))]
          struct RetArea([u8; 16]);
          let mut ret_area = ::core::mem::MaybeUninit::<RetArea>::uninit();
          let vec0 = key;
          let ptr0 = vec0.as_ptr() as i32;
          let len0 = vec0.len() as i32;
          let ptr1 = ret_area.as_mut_ptr() as i32;
          #[cfg(target_arch = "wasm32")]
          #[link(wasm_import_module = "fermyon:spin/config")]
          extern "C" {
            #[link_name = "get-config"]
            fn wit_import(_: i32, _: i32, _: i32, );
          }
          
          #[cfg(not(target_arch = "wasm32"))]
          fn wit_import(_: i32, _: i32, _: i32, ){ unreachable!() }
          wit_import(ptr0, len0, ptr1);
          let l2 = i32::from(*((ptr1 + 0) as *const u8));
          match l2 {
            0 => {
              let e = {
                let l3 = *((ptr1 + 4) as *const i32);
                let l4 = *((ptr1 + 8) as *const i32);
                let len5 = l4 as usize;
                let bytes5 = Vec::from_raw_parts(l3 as *mut _, len5, len5);
                
                wit_bindgen::rt::string_lift(bytes5)
              };
              Ok(e)
            }
            1 => {
              let e = {
                let l6 = i32::from(*((ptr1 + 4) as *const u8));
                let v19 = match l6 {
                  0 => {
                    let e19 = {
                      let l7 = *((ptr1 + 8) as *const i32);
                      let l8 = *((ptr1 + 12) as *const i32);
                      let len9 = l8 as usize;
                      let bytes9 = Vec::from_raw_parts(l7 as *mut _, len9, len9);
                      
                      wit_bindgen::rt::string_lift(bytes9)
                    };
                    Error::Provider(e19)
                  }
                  1 => {
                    let e19 = {
                      let l10 = *((ptr1 + 8) as *const i32);
                      let l11 = *((ptr1 + 12) as *const i32);
                      let len12 = l11 as usize;
                      let bytes12 = Vec::from_raw_parts(l10 as *mut _, len12, len12);
                      
                      wit_bindgen::rt::string_lift(bytes12)
                    };
                    Error::InvalidKey(e19)
                  }
                  2 => {
                    let e19 = {
                      let l13 = *((ptr1 + 8) as *const i32);
                      let l14 = *((ptr1 + 12) as *const i32);
                      let len15 = l14 as usize;
                      let bytes15 = Vec::from_raw_parts(l13 as *mut _, len15, len15);
                      
                      wit_bindgen::rt::string_lift(bytes15)
                    };
                    Error::InvalidSchema(e19)
                  }
                  n => {
                    debug_assert_eq!(n, 3, "invalid enum discriminant");
                    let e19 = {
                      let l16 = *((ptr1 + 8) as *const i32);
                      let l17 = *((ptr1 + 12) as *const i32);
                      let len18 = l17 as usize;
                      let bytes18 = Vec::from_raw_parts(l16 as *mut _, len18, len18);
                      
                      wit_bindgen::rt::string_lift(bytes18)
                    };
                    Error::Other(e19)
                  }
                };
                
                v19
              };
              Err(e)
            }
            _ => wit_bindgen::rt::invalid_enum_discriminant(),
          }
        }
      }
      
    }
    
    
    #[allow(clippy::all)]
    pub mod http {
      #[used]
      #[doc(hidden)]
      #[cfg(target_arch = "wasm32")]
      static __FORCE_SECTION_REF: fn() = super::super::super::__link_section;
      pub type Request = super::super::super::fermyon::spin::http_types::Request;
      pub type Response = super::super::super::fermyon::spin::http_types::Response;
      pub type HttpError = super::super::super::fermyon::spin::http_types::HttpError;
      #[allow(clippy::all)]
      pub fn send_request(req: &Request,) -> Result<Response,HttpError>{
        
        #[allow(unused_imports)]
        use wit_bindgen::rt::{alloc, vec::Vec, string::String};
        unsafe {
          
          #[repr(align(4))]
          struct RetArea([u8; 32]);
          let mut ret_area = ::core::mem::MaybeUninit::<RetArea>::uninit();
          let super::super::super::fermyon::spin::http_types::Request{ method:method0, uri:uri0, headers:headers0, params:params0, body:body0, } = req;
          let vec1 = uri0;
          let ptr1 = vec1.as_ptr() as i32;
          let len1 = vec1.len() as i32;
          let vec5 = headers0;
          let len5 = vec5.len() as i32;
          let layout5 = alloc::Layout::from_size_align_unchecked(vec5.len() * 16, 4);
          let result5 = if layout5.size() != 0
          {
            let ptr = alloc::alloc(layout5);
            if ptr.is_null()
            {
              alloc::handle_alloc_error(layout5);
            }
            ptr
          }else {{
            ::core::ptr::null_mut()
          }};
          for (i, e) in vec5.into_iter().enumerate() {
            let base = result5 as i32 + (i as i32) * 16;
            {
              let (t2_0, t2_1, ) = e;
              let vec3 = t2_0;
              let ptr3 = vec3.as_ptr() as i32;
              let len3 = vec3.len() as i32;
              *((base + 4) as *mut i32) = len3;
              *((base + 0) as *mut i32) = ptr3;
              let vec4 = t2_1;
              let ptr4 = vec4.as_ptr() as i32;
              let len4 = vec4.len() as i32;
              *((base + 12) as *mut i32) = len4;
              *((base + 8) as *mut i32) = ptr4;
            }
          }
          let vec9 = params0;
          let len9 = vec9.len() as i32;
          let layout9 = alloc::Layout::from_size_align_unchecked(vec9.len() * 16, 4);
          let result9 = if layout9.size() != 0
          {
            let ptr = alloc::alloc(layout9);
            if ptr.is_null()
            {
              alloc::handle_alloc_error(layout9);
            }
            ptr
          }else {{
            ::core::ptr::null_mut()
          }};
          for (i, e) in vec9.into_iter().enumerate() {
            let base = result9 as i32 + (i as i32) * 16;
            {
              let (t6_0, t6_1, ) = e;
              let vec7 = t6_0;
              let ptr7 = vec7.as_ptr() as i32;
              let len7 = vec7.len() as i32;
              *((base + 4) as *mut i32) = len7;
              *((base + 0) as *mut i32) = ptr7;
              let vec8 = t6_1;
              let ptr8 = vec8.as_ptr() as i32;
              let len8 = vec8.len() as i32;
              *((base + 12) as *mut i32) = len8;
              *((base + 8) as *mut i32) = ptr8;
            }
          }
          let (result11_0,result11_1,result11_2,) = match body0 {
            Some(e) => {
              let vec10 = e;
              let ptr10 = vec10.as_ptr() as i32;
              let len10 = vec10.len() as i32;
              
              (1i32, ptr10, len10)
            },
            None => {
              (0i32, 0i32, 0i32)
            },
          };let ptr12 = ret_area.as_mut_ptr() as i32;
          #[cfg(target_arch = "wasm32")]
          #[link(wasm_import_module = "fermyon:spin/http")]
          extern "C" {
            #[link_name = "send-request"]
            fn wit_import(_: i32, _: i32, _: i32, _: i32, _: i32, _: i32, _: i32, _: i32, _: i32, _: i32, _: i32, );
          }
          
          #[cfg(not(target_arch = "wasm32"))]
          fn wit_import(_: i32, _: i32, _: i32, _: i32, _: i32, _: i32, _: i32, _: i32, _: i32, _: i32, _: i32, ){ unreachable!() }
          wit_import(method0.clone() as i32, ptr1, len1, result5 as i32, len5, result9 as i32, len9, result11_0, result11_1, result11_2, ptr12);
          let l13 = i32::from(*((ptr12 + 0) as *const u8));
          if layout5.size() != 0 {
            alloc::dealloc(result5, layout5);
          }
          if layout9.size() != 0 {
            alloc::dealloc(result9, layout9);
          }
          match l13 {
            0 => {
              let e = {
                let l14 = i32::from(*((ptr12 + 4) as *const u16));
                let l15 = i32::from(*((ptr12 + 8) as *const u8));
                let l25 = i32::from(*((ptr12 + 20) as *const u8));
                
                super::super::super::fermyon::spin::http_types::Response{
                  status: l14 as u16,
                  headers: match l15 {
                    0 => None,
                    1 => {
                      let e = {
                        let l16 = *((ptr12 + 12) as *const i32);
                        let l17 = *((ptr12 + 16) as *const i32);
                        let base24 = l16;
                        let len24 = l17;
                        let mut result24 = Vec::with_capacity(len24 as usize);
                        for i in 0..len24 {
                          let base = base24 + i * 16;
                          let e24 = {
                            let l18 = *((base + 0) as *const i32);
                            let l19 = *((base + 4) as *const i32);
                            let len20 = l19 as usize;
                            let bytes20 = Vec::from_raw_parts(l18 as *mut _, len20, len20);
                            let l21 = *((base + 8) as *const i32);
                            let l22 = *((base + 12) as *const i32);
                            let len23 = l22 as usize;
                            let bytes23 = Vec::from_raw_parts(l21 as *mut _, len23, len23);
                            
                            (wit_bindgen::rt::string_lift(bytes20), wit_bindgen::rt::string_lift(bytes23))
                          };
                          result24.push(e24);
                        }
                        wit_bindgen::rt::dealloc(base24, (len24 as usize) * 16, 4);
                        
                        result24
                      };
                      Some(e)
                    }
                    _ => wit_bindgen::rt::invalid_enum_discriminant(),
                  },
                  body: match l25 {
                    0 => None,
                    1 => {
                      let e = {
                        let l26 = *((ptr12 + 24) as *const i32);
                        let l27 = *((ptr12 + 28) as *const i32);
                        let len28 = l27 as usize;
                        
                        Vec::from_raw_parts(l26 as *mut _, len28, len28)
                      };
                      Some(e)
                    }
                    _ => wit_bindgen::rt::invalid_enum_discriminant(),
                  },
                }
              };
              Ok(e)
            }
            1 => {
              let e = {
                let l29 = i32::from(*((ptr12 + 4) as *const u8));
                
                super::super::super::fermyon::spin::http_types::HttpError::_lift(l29 as u8)
              };
              Err(e)
            }
            _ => wit_bindgen::rt::invalid_enum_discriminant(),
          }
        }
      }
      
    }
    
    
    #[allow(clippy::all)]
    pub mod rdbms_types {
      #[used]
      #[doc(hidden)]
      #[cfg(target_arch = "wasm32")]
      static __FORCE_SECTION_REF: fn() = super::super::super::__link_section;
      #[repr(u8)]
      #[derive(Clone, Copy, Eq, PartialEq)]
      pub enum DbDataType {
        Boolean,
        Int8,
        Int16,
        Int32,
        Int64,
        Uint8,
        Uint16,
        Uint32,
        Uint64,
        Floating32,
        Floating64,
        Str,
        Binary,
        Other,
      }
      impl ::core::fmt::Debug for DbDataType {
        fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
          match self {
            DbDataType::Boolean => {
              f.debug_tuple("DbDataType::Boolean").finish()
            }
            DbDataType::Int8 => {
              f.debug_tuple("DbDataType::Int8").finish()
            }
            DbDataType::Int16 => {
              f.debug_tuple("DbDataType::Int16").finish()
            }
            DbDataType::Int32 => {
              f.debug_tuple("DbDataType::Int32").finish()
            }
            DbDataType::Int64 => {
              f.debug_tuple("DbDataType::Int64").finish()
            }
            DbDataType::Uint8 => {
              f.debug_tuple("DbDataType::Uint8").finish()
            }
            DbDataType::Uint16 => {
              f.debug_tuple("DbDataType::Uint16").finish()
            }
            DbDataType::Uint32 => {
              f.debug_tuple("DbDataType::Uint32").finish()
            }
            DbDataType::Uint64 => {
              f.debug_tuple("DbDataType::Uint64").finish()
            }
            DbDataType::Floating32 => {
              f.debug_tuple("DbDataType::Floating32").finish()
            }
            DbDataType::Floating64 => {
              f.debug_tuple("DbDataType::Floating64").finish()
            }
            DbDataType::Str => {
              f.debug_tuple("DbDataType::Str").finish()
            }
            DbDataType::Binary => {
              f.debug_tuple("DbDataType::Binary").finish()
            }
            DbDataType::Other => {
              f.debug_tuple("DbDataType::Other").finish()
            }
          }
        }
      }
      
      impl DbDataType{
        pub(crate) unsafe fn _lift(val: u8) -> DbDataType{
          if !cfg!(debug_assertions) {
            return ::core::mem::transmute(val);
          }
          
          match val {
            0 => DbDataType::Boolean,
            1 => DbDataType::Int8,
            2 => DbDataType::Int16,
            3 => DbDataType::Int32,
            4 => DbDataType::Int64,
            5 => DbDataType::Uint8,
            6 => DbDataType::Uint16,
            7 => DbDataType::Uint32,
            8 => DbDataType::Uint64,
            9 => DbDataType::Floating32,
            10 => DbDataType::Floating64,
            11 => DbDataType::Str,
            12 => DbDataType::Binary,
            13 => DbDataType::Other,
            
            _ => panic!("invalid enum discriminant"),
          }
        }
      }
      
      #[derive(Clone)]
      pub enum DbValue{
        Boolean(bool),
        Int8(i8),
        Int16(i16),
        Int32(i32),
        Int64(i64),
        Uint8(u8),
        Uint16(u16),
        Uint32(u32),
        Uint64(u64),
        Floating32(f32),
        Floating64(f64),
        Str(wit_bindgen::rt::string::String),
        Binary(wit_bindgen::rt::vec::Vec::<u8>),
        DbNull,
        Unsupported,
      }
      impl ::core::fmt::Debug for DbValue {
        fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
          match self {
            DbValue::Boolean(e) => {
              f.debug_tuple("DbValue::Boolean").field(e).finish()
            }
            DbValue::Int8(e) => {
              f.debug_tuple("DbValue::Int8").field(e).finish()
            }
            DbValue::Int16(e) => {
              f.debug_tuple("DbValue::Int16").field(e).finish()
            }
            DbValue::Int32(e) => {
              f.debug_tuple("DbValue::Int32").field(e).finish()
            }
            DbValue::Int64(e) => {
              f.debug_tuple("DbValue::Int64").field(e).finish()
            }
            DbValue::Uint8(e) => {
              f.debug_tuple("DbValue::Uint8").field(e).finish()
            }
            DbValue::Uint16(e) => {
              f.debug_tuple("DbValue::Uint16").field(e).finish()
            }
            DbValue::Uint32(e) => {
              f.debug_tuple("DbValue::Uint32").field(e).finish()
            }
            DbValue::Uint64(e) => {
              f.debug_tuple("DbValue::Uint64").field(e).finish()
            }
            DbValue::Floating32(e) => {
              f.debug_tuple("DbValue::Floating32").field(e).finish()
            }
            DbValue::Floating64(e) => {
              f.debug_tuple("DbValue::Floating64").field(e).finish()
            }
            DbValue::Str(e) => {
              f.debug_tuple("DbValue::Str").field(e).finish()
            }
            DbValue::Binary(e) => {
              f.debug_tuple("DbValue::Binary").field(e).finish()
            }
            DbValue::DbNull => {
              f.debug_tuple("DbValue::DbNull").finish()
            }
            DbValue::Unsupported => {
              f.debug_tuple("DbValue::Unsupported").finish()
            }
          }
        }
      }
      #[derive(Clone)]
      pub enum ParameterValue{
        Boolean(bool),
        Int8(i8),
        Int16(i16),
        Int32(i32),
        Int64(i64),
        Uint8(u8),
        Uint16(u16),
        Uint32(u32),
        Uint64(u64),
        Floating32(f32),
        Floating64(f64),
        Str(wit_bindgen::rt::string::String),
        Binary(wit_bindgen::rt::vec::Vec::<u8>),
        DbNull,
      }
      impl ::core::fmt::Debug for ParameterValue {
        fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
          match self {
            ParameterValue::Boolean(e) => {
              f.debug_tuple("ParameterValue::Boolean").field(e).finish()
            }
            ParameterValue::Int8(e) => {
              f.debug_tuple("ParameterValue::Int8").field(e).finish()
            }
            ParameterValue::Int16(e) => {
              f.debug_tuple("ParameterValue::Int16").field(e).finish()
            }
            ParameterValue::Int32(e) => {
              f.debug_tuple("ParameterValue::Int32").field(e).finish()
            }
            ParameterValue::Int64(e) => {
              f.debug_tuple("ParameterValue::Int64").field(e).finish()
            }
            ParameterValue::Uint8(e) => {
              f.debug_tuple("ParameterValue::Uint8").field(e).finish()
            }
            ParameterValue::Uint16(e) => {
              f.debug_tuple("ParameterValue::Uint16").field(e).finish()
            }
            ParameterValue::Uint32(e) => {
              f.debug_tuple("ParameterValue::Uint32").field(e).finish()
            }
            ParameterValue::Uint64(e) => {
              f.debug_tuple("ParameterValue::Uint64").field(e).finish()
            }
            ParameterValue::Floating32(e) => {
              f.debug_tuple("ParameterValue::Floating32").field(e).finish()
            }
            ParameterValue::Floating64(e) => {
              f.debug_tuple("ParameterValue::Floating64").field(e).finish()
            }
            ParameterValue::Str(e) => {
              f.debug_tuple("ParameterValue::Str").field(e).finish()
            }
            ParameterValue::Binary(e) => {
              f.debug_tuple("ParameterValue::Binary").field(e).finish()
            }
            ParameterValue::DbNull => {
              f.debug_tuple("ParameterValue::DbNull").finish()
            }
          }
        }
      }
      #[derive(Clone)]
      pub struct Column {
        pub name: wit_bindgen::rt::string::String,
        pub data_type: DbDataType,
      }
      impl ::core::fmt::Debug for Column {
        fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
          f.debug_struct("Column").field("name", &self.name).field("data-type", &self.data_type).finish()
        }
      }
      pub type Row = wit_bindgen::rt::vec::Vec::<DbValue>;
      #[derive(Clone)]
      pub struct RowSet {
        pub columns: wit_bindgen::rt::vec::Vec::<Column>,
        pub rows: wit_bindgen::rt::vec::Vec::<Row>,
      }
      impl ::core::fmt::Debug for RowSet {
        fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
          f.debug_struct("RowSet").field("columns", &self.columns).field("rows", &self.rows).finish()
        }
      }
      
    }
    
    
    #[allow(clippy::all)]
    pub mod postgres {
      #[used]
      #[doc(hidden)]
      #[cfg(target_arch = "wasm32")]
      static __FORCE_SECTION_REF: fn() = super::super::super::__link_section;
      pub type ParameterValue = super::super::super::fermyon::spin::rdbms_types::ParameterValue;
      pub type RowSet = super::super::super::fermyon::spin::rdbms_types::RowSet;
      #[derive(Clone)]
      pub enum PgError{
        Success,
        ConnectionFailed(wit_bindgen::rt::string::String),
        BadParameter(wit_bindgen::rt::string::String),
        QueryFailed(wit_bindgen::rt::string::String),
        ValueConversionFailed(wit_bindgen::rt::string::String),
        OtherError(wit_bindgen::rt::string::String),
      }
      impl ::core::fmt::Debug for PgError {
        fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
          match self {
            PgError::Success => {
              f.debug_tuple("PgError::Success").finish()
            }
            PgError::ConnectionFailed(e) => {
              f.debug_tuple("PgError::ConnectionFailed").field(e).finish()
            }
            PgError::BadParameter(e) => {
              f.debug_tuple("PgError::BadParameter").field(e).finish()
            }
            PgError::QueryFailed(e) => {
              f.debug_tuple("PgError::QueryFailed").field(e).finish()
            }
            PgError::ValueConversionFailed(e) => {
              f.debug_tuple("PgError::ValueConversionFailed").field(e).finish()
            }
            PgError::OtherError(e) => {
              f.debug_tuple("PgError::OtherError").field(e).finish()
            }
          }
        }
      }
      impl ::core::fmt::Display for PgError {
        fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
          write!(f, "{:?}", self)
        }
      }
      
      impl std::error::Error for PgError {}
      #[allow(clippy::all)]
      pub fn query(address: &str,statement: &str,params: &[ParameterValue],) -> Result<RowSet,PgError>{
        
        #[allow(unused_imports)]
        use wit_bindgen::rt::{alloc, vec::Vec, string::String};
        unsafe {
          
          #[repr(align(4))]
          struct RetArea([u8; 20]);
          let mut ret_area = ::core::mem::MaybeUninit::<RetArea>::uninit();
          let vec0 = address;
          let ptr0 = vec0.as_ptr() as i32;
          let len0 = vec0.len() as i32;
          let vec1 = statement;
          let ptr1 = vec1.as_ptr() as i32;
          let len1 = vec1.len() as i32;
          let vec5 = params;
          let len5 = vec5.len() as i32;
          let layout5 = alloc::Layout::from_size_align_unchecked(vec5.len() * 16, 8);
          let result5 = if layout5.size() != 0
          {
            let ptr = alloc::alloc(layout5);
            if ptr.is_null()
            {
              alloc::handle_alloc_error(layout5);
            }
            ptr
          }else {{
            ::core::ptr::null_mut()
          }};
          for (i, e) in vec5.into_iter().enumerate() {
            let base = result5 as i32 + (i as i32) * 16;
            {
              use super::super::super::fermyon::spin::rdbms_types::ParameterValue as V4;
              match e {
                V4::Boolean(e) => {
                  *((base + 0) as *mut u8) = (0i32) as u8;
                  *((base + 8) as *mut u8) = (match e { true => 1, false => 0 }) as u8;
                },
                V4::Int8(e) => {
                  *((base + 0) as *mut u8) = (1i32) as u8;
                  *((base + 8) as *mut u8) = (wit_bindgen::rt::as_i32(e)) as u8;
                },
                V4::Int16(e) => {
                  *((base + 0) as *mut u8) = (2i32) as u8;
                  *((base + 8) as *mut u16) = (wit_bindgen::rt::as_i32(e)) as u16;
                },
                V4::Int32(e) => {
                  *((base + 0) as *mut u8) = (3i32) as u8;
                  *((base + 8) as *mut i32) = wit_bindgen::rt::as_i32(e);
                },
                V4::Int64(e) => {
                  *((base + 0) as *mut u8) = (4i32) as u8;
                  *((base + 8) as *mut i64) = wit_bindgen::rt::as_i64(e);
                },
                V4::Uint8(e) => {
                  *((base + 0) as *mut u8) = (5i32) as u8;
                  *((base + 8) as *mut u8) = (wit_bindgen::rt::as_i32(e)) as u8;
                },
                V4::Uint16(e) => {
                  *((base + 0) as *mut u8) = (6i32) as u8;
                  *((base + 8) as *mut u16) = (wit_bindgen::rt::as_i32(e)) as u16;
                },
                V4::Uint32(e) => {
                  *((base + 0) as *mut u8) = (7i32) as u8;
                  *((base + 8) as *mut i32) = wit_bindgen::rt::as_i32(e);
                },
                V4::Uint64(e) => {
                  *((base + 0) as *mut u8) = (8i32) as u8;
                  *((base + 8) as *mut i64) = wit_bindgen::rt::as_i64(e);
                },
                V4::Floating32(e) => {
                  *((base + 0) as *mut u8) = (9i32) as u8;
                  *((base + 8) as *mut f32) = wit_bindgen::rt::as_f32(e);
                },
                V4::Floating64(e) => {
                  *((base + 0) as *mut u8) = (10i32) as u8;
                  *((base + 8) as *mut f64) = wit_bindgen::rt::as_f64(e);
                },
                V4::Str(e) => {
                  *((base + 0) as *mut u8) = (11i32) as u8;
                  let vec2 = e;
                  let ptr2 = vec2.as_ptr() as i32;
                  let len2 = vec2.len() as i32;
                  *((base + 12) as *mut i32) = len2;
                  *((base + 8) as *mut i32) = ptr2;
                },
                V4::Binary(e) => {
                  *((base + 0) as *mut u8) = (12i32) as u8;
                  let vec3 = e;
                  let ptr3 = vec3.as_ptr() as i32;
                  let len3 = vec3.len() as i32;
                  *((base + 12) as *mut i32) = len3;
                  *((base + 8) as *mut i32) = ptr3;
                },
                V4::DbNull=> {
                  {
                    *((base + 0) as *mut u8) = (13i32) as u8;
                  }
                }
              }
            }
          }
          let ptr6 = ret_area.as_mut_ptr() as i32;
          #[cfg(target_arch = "wasm32")]
          #[link(wasm_import_module = "fermyon:spin/postgres")]
          extern "C" {
            #[link_name = "query"]
            fn wit_import(_: i32, _: i32, _: i32, _: i32, _: i32, _: i32, _: i32, );
          }
          
          #[cfg(not(target_arch = "wasm32"))]
          fn wit_import(_: i32, _: i32, _: i32, _: i32, _: i32, _: i32, _: i32, ){ unreachable!() }
          wit_import(ptr0, len0, ptr1, len1, result5 as i32, len5, ptr6);
          let l7 = i32::from(*((ptr6 + 0) as *const u8));
          if layout5.size() != 0 {
            alloc::dealloc(result5, layout5);
          }
          match l7 {
            0 => {
              let e = {
                let l8 = *((ptr6 + 4) as *const i32);
                let l9 = *((ptr6 + 8) as *const i32);
                let base14 = l8;
                let len14 = l9;
                let mut result14 = Vec::with_capacity(len14 as usize);
                for i in 0..len14 {
                  let base = base14 + i * 12;
                  let e14 = {
                    let l10 = *((base + 0) as *const i32);
                    let l11 = *((base + 4) as *const i32);
                    let len12 = l11 as usize;
                    let bytes12 = Vec::from_raw_parts(l10 as *mut _, len12, len12);
                    let l13 = i32::from(*((base + 8) as *const u8));
                    
                    super::super::super::fermyon::spin::rdbms_types::Column{
                      name: wit_bindgen::rt::string_lift(bytes12),
                      data_type: super::super::super::fermyon::spin::rdbms_types::DbDataType::_lift(l13 as u8),
                    }
                  };
                  result14.push(e14);
                }
                wit_bindgen::rt::dealloc(base14, (len14 as usize) * 12, 4);
                let l15 = *((ptr6 + 12) as *const i32);
                let l16 = *((ptr6 + 16) as *const i32);
                let base39 = l15;
                let len39 = l16;
                let mut result39 = Vec::with_capacity(len39 as usize);
                for i in 0..len39 {
                  let base = base39 + i * 8;
                  let e39 = {
                    let l17 = *((base + 0) as *const i32);
                    let l18 = *((base + 4) as *const i32);
                    let base38 = l17;
                    let len38 = l18;
                    let mut result38 = Vec::with_capacity(len38 as usize);
                    for i in 0..len38 {
                      let base = base38 + i * 16;
                      let e38 = {
                        let l19 = i32::from(*((base + 0) as *const u8));
                        use super::super::super::fermyon::spin::rdbms_types::DbValue as V37;
                        let v37 = match l19 {
                          0 => {
                            let e37 = {
                              let l20 = i32::from(*((base + 8) as *const u8));
                              
                              wit_bindgen::rt::bool_lift(l20 as u8)
                            };
                            V37::Boolean(e37)
                          }
                          1 => {
                            let e37 = {
                              let l21 = i32::from(*((base + 8) as *const i8));
                              
                              l21 as i8
                            };
                            V37::Int8(e37)
                          }
                          2 => {
                            let e37 = {
                              let l22 = i32::from(*((base + 8) as *const i16));
                              
                              l22 as i16
                            };
                            V37::Int16(e37)
                          }
                          3 => {
                            let e37 = {
                              let l23 = *((base + 8) as *const i32);
                              
                              l23
                            };
                            V37::Int32(e37)
                          }
                          4 => {
                            let e37 = {
                              let l24 = *((base + 8) as *const i64);
                              
                              l24
                            };
                            V37::Int64(e37)
                          }
                          5 => {
                            let e37 = {
                              let l25 = i32::from(*((base + 8) as *const u8));
                              
                              l25 as u8
                            };
                            V37::Uint8(e37)
                          }
                          6 => {
                            let e37 = {
                              let l26 = i32::from(*((base + 8) as *const u16));
                              
                              l26 as u16
                            };
                            V37::Uint16(e37)
                          }
                          7 => {
                            let e37 = {
                              let l27 = *((base + 8) as *const i32);
                              
                              l27 as u32
                            };
                            V37::Uint32(e37)
                          }
                          8 => {
                            let e37 = {
                              let l28 = *((base + 8) as *const i64);
                              
                              l28 as u64
                            };
                            V37::Uint64(e37)
                          }
                          9 => {
                            let e37 = {
                              let l29 = *((base + 8) as *const f32);
                              
                              l29
                            };
                            V37::Floating32(e37)
                          }
                          10 => {
                            let e37 = {
                              let l30 = *((base + 8) as *const f64);
                              
                              l30
                            };
                            V37::Floating64(e37)
                          }
                          11 => {
                            let e37 = {
                              let l31 = *((base + 8) as *const i32);
                              let l32 = *((base + 12) as *const i32);
                              let len33 = l32 as usize;
                              let bytes33 = Vec::from_raw_parts(l31 as *mut _, len33, len33);
                              
                              wit_bindgen::rt::string_lift(bytes33)
                            };
                            V37::Str(e37)
                          }
                          12 => {
                            let e37 = {
                              let l34 = *((base + 8) as *const i32);
                              let l35 = *((base + 12) as *const i32);
                              let len36 = l35 as usize;
                              
                              Vec::from_raw_parts(l34 as *mut _, len36, len36)
                            };
                            V37::Binary(e37)
                          }
                          13 => {
                            V37::DbNull
                          }
                          n => {
                            debug_assert_eq!(n, 14, "invalid enum discriminant");
                            V37::Unsupported
                          }
                        };
                        
                        v37
                      };
                      result38.push(e38);
                    }
                    wit_bindgen::rt::dealloc(base38, (len38 as usize) * 16, 8);
                    
                    result38
                  };
                  result39.push(e39);
                }
                wit_bindgen::rt::dealloc(base39, (len39 as usize) * 8, 4);
                
                super::super::super::fermyon::spin::rdbms_types::RowSet{
                  columns: result14,
                  rows: result39,
                }
              };
              Ok(e)
            }
            1 => {
              let e = {
                let l40 = i32::from(*((ptr6 + 4) as *const u8));
                let v56 = match l40 {
                  0 => {
                    PgError::Success
                  }
                  1 => {
                    let e56 = {
                      let l41 = *((ptr6 + 8) as *const i32);
                      let l42 = *((ptr6 + 12) as *const i32);
                      let len43 = l42 as usize;
                      let bytes43 = Vec::from_raw_parts(l41 as *mut _, len43, len43);
                      
                      wit_bindgen::rt::string_lift(bytes43)
                    };
                    PgError::ConnectionFailed(e56)
                  }
                  2 => {
                    let e56 = {
                      let l44 = *((ptr6 + 8) as *const i32);
                      let l45 = *((ptr6 + 12) as *const i32);
                      let len46 = l45 as usize;
                      let bytes46 = Vec::from_raw_parts(l44 as *mut _, len46, len46);
                      
                      wit_bindgen::rt::string_lift(bytes46)
                    };
                    PgError::BadParameter(e56)
                  }
                  3 => {
                    let e56 = {
                      let l47 = *((ptr6 + 8) as *const i32);
                      let l48 = *((ptr6 + 12) as *const i32);
                      let len49 = l48 as usize;
                      let bytes49 = Vec::from_raw_parts(l47 as *mut _, len49, len49);
                      
                      wit_bindgen::rt::string_lift(bytes49)
                    };
                    PgError::QueryFailed(e56)
                  }
                  4 => {
                    let e56 = {
                      let l50 = *((ptr6 + 8) as *const i32);
                      let l51 = *((ptr6 + 12) as *const i32);
                      let len52 = l51 as usize;
                      let bytes52 = Vec::from_raw_parts(l50 as *mut _, len52, len52);
                      
                      wit_bindgen::rt::string_lift(bytes52)
                    };
                    PgError::ValueConversionFailed(e56)
                  }
                  n => {
                    debug_assert_eq!(n, 5, "invalid enum discriminant");
                    let e56 = {
                      let l53 = *((ptr6 + 8) as *const i32);
                      let l54 = *((ptr6 + 12) as *const i32);
                      let len55 = l54 as usize;
                      let bytes55 = Vec::from_raw_parts(l53 as *mut _, len55, len55);
                      
                      wit_bindgen::rt::string_lift(bytes55)
                    };
                    PgError::OtherError(e56)
                  }
                };
                
                v56
              };
              Err(e)
            }
            _ => wit_bindgen::rt::invalid_enum_discriminant(),
          }
        }
      }
      #[allow(clippy::all)]
      pub fn execute(address: &str,statement: &str,params: &[ParameterValue],) -> Result<u64,PgError>{
        
        #[allow(unused_imports)]
        use wit_bindgen::rt::{alloc, vec::Vec, string::String};
        unsafe {
          
          #[repr(align(8))]
          struct RetArea([u8; 24]);
          let mut ret_area = ::core::mem::MaybeUninit::<RetArea>::uninit();
          let vec0 = address;
          let ptr0 = vec0.as_ptr() as i32;
          let len0 = vec0.len() as i32;
          let vec1 = statement;
          let ptr1 = vec1.as_ptr() as i32;
          let len1 = vec1.len() as i32;
          let vec5 = params;
          let len5 = vec5.len() as i32;
          let layout5 = alloc::Layout::from_size_align_unchecked(vec5.len() * 16, 8);
          let result5 = if layout5.size() != 0
          {
            let ptr = alloc::alloc(layout5);
            if ptr.is_null()
            {
              alloc::handle_alloc_error(layout5);
            }
            ptr
          }else {{
            ::core::ptr::null_mut()
          }};
          for (i, e) in vec5.into_iter().enumerate() {
            let base = result5 as i32 + (i as i32) * 16;
            {
              use super::super::super::fermyon::spin::rdbms_types::ParameterValue as V4;
              match e {
                V4::Boolean(e) => {
                  *((base + 0) as *mut u8) = (0i32) as u8;
                  *((base + 8) as *mut u8) = (match e { true => 1, false => 0 }) as u8;
                },
                V4::Int8(e) => {
                  *((base + 0) as *mut u8) = (1i32) as u8;
                  *((base + 8) as *mut u8) = (wit_bindgen::rt::as_i32(e)) as u8;
                },
                V4::Int16(e) => {
                  *((base + 0) as *mut u8) = (2i32) as u8;
                  *((base + 8) as *mut u16) = (wit_bindgen::rt::as_i32(e)) as u16;
                },
                V4::Int32(e) => {
                  *((base + 0) as *mut u8) = (3i32) as u8;
                  *((base + 8) as *mut i32) = wit_bindgen::rt::as_i32(e);
                },
                V4::Int64(e) => {
                  *((base + 0) as *mut u8) = (4i32) as u8;
                  *((base + 8) as *mut i64) = wit_bindgen::rt::as_i64(e);
                },
                V4::Uint8(e) => {
                  *((base + 0) as *mut u8) = (5i32) as u8;
                  *((base + 8) as *mut u8) = (wit_bindgen::rt::as_i32(e)) as u8;
                },
                V4::Uint16(e) => {
                  *((base + 0) as *mut u8) = (6i32) as u8;
                  *((base + 8) as *mut u16) = (wit_bindgen::rt::as_i32(e)) as u16;
                },
                V4::Uint32(e) => {
                  *((base + 0) as *mut u8) = (7i32) as u8;
                  *((base + 8) as *mut i32) = wit_bindgen::rt::as_i32(e);
                },
                V4::Uint64(e) => {
                  *((base + 0) as *mut u8) = (8i32) as u8;
                  *((base + 8) as *mut i64) = wit_bindgen::rt::as_i64(e);
                },
                V4::Floating32(e) => {
                  *((base + 0) as *mut u8) = (9i32) as u8;
                  *((base + 8) as *mut f32) = wit_bindgen::rt::as_f32(e);
                },
                V4::Floating64(e) => {
                  *((base + 0) as *mut u8) = (10i32) as u8;
                  *((base + 8) as *mut f64) = wit_bindgen::rt::as_f64(e);
                },
                V4::Str(e) => {
                  *((base + 0) as *mut u8) = (11i32) as u8;
                  let vec2 = e;
                  let ptr2 = vec2.as_ptr() as i32;
                  let len2 = vec2.len() as i32;
                  *((base + 12) as *mut i32) = len2;
                  *((base + 8) as *mut i32) = ptr2;
                },
                V4::Binary(e) => {
                  *((base + 0) as *mut u8) = (12i32) as u8;
                  let vec3 = e;
                  let ptr3 = vec3.as_ptr() as i32;
                  let len3 = vec3.len() as i32;
                  *((base + 12) as *mut i32) = len3;
                  *((base + 8) as *mut i32) = ptr3;
                },
                V4::DbNull=> {
                  {
                    *((base + 0) as *mut u8) = (13i32) as u8;
                  }
                }
              }
            }
          }
          let ptr6 = ret_area.as_mut_ptr() as i32;
          #[cfg(target_arch = "wasm32")]
          #[link(wasm_import_module = "fermyon:spin/postgres")]
          extern "C" {
            #[link_name = "execute"]
            fn wit_import(_: i32, _: i32, _: i32, _: i32, _: i32, _: i32, _: i32, );
          }
          
          #[cfg(not(target_arch = "wasm32"))]
          fn wit_import(_: i32, _: i32, _: i32, _: i32, _: i32, _: i32, _: i32, ){ unreachable!() }
          wit_import(ptr0, len0, ptr1, len1, result5 as i32, len5, ptr6);
          let l7 = i32::from(*((ptr6 + 0) as *const u8));
          if layout5.size() != 0 {
            alloc::dealloc(result5, layout5);
          }
          match l7 {
            0 => {
              let e = {
                let l8 = *((ptr6 + 8) as *const i64);
                
                l8 as u64
              };
              Ok(e)
            }
            1 => {
              let e = {
                let l9 = i32::from(*((ptr6 + 8) as *const u8));
                let v25 = match l9 {
                  0 => {
                    PgError::Success
                  }
                  1 => {
                    let e25 = {
                      let l10 = *((ptr6 + 12) as *const i32);
                      let l11 = *((ptr6 + 16) as *const i32);
                      let len12 = l11 as usize;
                      let bytes12 = Vec::from_raw_parts(l10 as *mut _, len12, len12);
                      
                      wit_bindgen::rt::string_lift(bytes12)
                    };
                    PgError::ConnectionFailed(e25)
                  }
                  2 => {
                    let e25 = {
                      let l13 = *((ptr6 + 12) as *const i32);
                      let l14 = *((ptr6 + 16) as *const i32);
                      let len15 = l14 as usize;
                      let bytes15 = Vec::from_raw_parts(l13 as *mut _, len15, len15);
                      
                      wit_bindgen::rt::string_lift(bytes15)
                    };
                    PgError::BadParameter(e25)
                  }
                  3 => {
                    let e25 = {
                      let l16 = *((ptr6 + 12) as *const i32);
                      let l17 = *((ptr6 + 16) as *const i32);
                      let len18 = l17 as usize;
                      let bytes18 = Vec::from_raw_parts(l16 as *mut _, len18, len18);
                      
                      wit_bindgen::rt::string_lift(bytes18)
                    };
                    PgError::QueryFailed(e25)
                  }
                  4 => {
                    let e25 = {
                      let l19 = *((ptr6 + 12) as *const i32);
                      let l20 = *((ptr6 + 16) as *const i32);
                      let len21 = l20 as usize;
                      let bytes21 = Vec::from_raw_parts(l19 as *mut _, len21, len21);
                      
                      wit_bindgen::rt::string_lift(bytes21)
                    };
                    PgError::ValueConversionFailed(e25)
                  }
                  n => {
                    debug_assert_eq!(n, 5, "invalid enum discriminant");
                    let e25 = {
                      let l22 = *((ptr6 + 12) as *const i32);
                      let l23 = *((ptr6 + 16) as *const i32);
                      let len24 = l23 as usize;
                      let bytes24 = Vec::from_raw_parts(l22 as *mut _, len24, len24);
                      
                      wit_bindgen::rt::string_lift(bytes24)
                    };
                    PgError::OtherError(e25)
                  }
                };
                
                v25
              };
              Err(e)
            }
            _ => wit_bindgen::rt::invalid_enum_discriminant(),
          }
        }
      }
      
    }
    
    
    #[allow(clippy::all)]
    pub mod mysql {
      #[used]
      #[doc(hidden)]
      #[cfg(target_arch = "wasm32")]
      static __FORCE_SECTION_REF: fn() = super::super::super::__link_section;
      pub type ParameterValue = super::super::super::fermyon::spin::rdbms_types::ParameterValue;
      pub type RowSet = super::super::super::fermyon::spin::rdbms_types::RowSet;
      #[derive(Clone)]
      pub enum MysqlError{
        Success,
        ConnectionFailed(wit_bindgen::rt::string::String),
        BadParameter(wit_bindgen::rt::string::String),
        QueryFailed(wit_bindgen::rt::string::String),
        ValueConversionFailed(wit_bindgen::rt::string::String),
        OtherError(wit_bindgen::rt::string::String),
      }
      impl ::core::fmt::Debug for MysqlError {
        fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
          match self {
            MysqlError::Success => {
              f.debug_tuple("MysqlError::Success").finish()
            }
            MysqlError::ConnectionFailed(e) => {
              f.debug_tuple("MysqlError::ConnectionFailed").field(e).finish()
            }
            MysqlError::BadParameter(e) => {
              f.debug_tuple("MysqlError::BadParameter").field(e).finish()
            }
            MysqlError::QueryFailed(e) => {
              f.debug_tuple("MysqlError::QueryFailed").field(e).finish()
            }
            MysqlError::ValueConversionFailed(e) => {
              f.debug_tuple("MysqlError::ValueConversionFailed").field(e).finish()
            }
            MysqlError::OtherError(e) => {
              f.debug_tuple("MysqlError::OtherError").field(e).finish()
            }
          }
        }
      }
      impl ::core::fmt::Display for MysqlError {
        fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
          write!(f, "{:?}", self)
        }
      }
      
      impl std::error::Error for MysqlError {}
      #[allow(clippy::all)]
      pub fn query(address: &str,statement: &str,params: &[ParameterValue],) -> Result<RowSet,MysqlError>{
        
        #[allow(unused_imports)]
        use wit_bindgen::rt::{alloc, vec::Vec, string::String};
        unsafe {
          
          #[repr(align(4))]
          struct RetArea([u8; 20]);
          let mut ret_area = ::core::mem::MaybeUninit::<RetArea>::uninit();
          let vec0 = address;
          let ptr0 = vec0.as_ptr() as i32;
          let len0 = vec0.len() as i32;
          let vec1 = statement;
          let ptr1 = vec1.as_ptr() as i32;
          let len1 = vec1.len() as i32;
          let vec5 = params;
          let len5 = vec5.len() as i32;
          let layout5 = alloc::Layout::from_size_align_unchecked(vec5.len() * 16, 8);
          let result5 = if layout5.size() != 0
          {
            let ptr = alloc::alloc(layout5);
            if ptr.is_null()
            {
              alloc::handle_alloc_error(layout5);
            }
            ptr
          }else {{
            ::core::ptr::null_mut()
          }};
          for (i, e) in vec5.into_iter().enumerate() {
            let base = result5 as i32 + (i as i32) * 16;
            {
              use super::super::super::fermyon::spin::rdbms_types::ParameterValue as V4;
              match e {
                V4::Boolean(e) => {
                  *((base + 0) as *mut u8) = (0i32) as u8;
                  *((base + 8) as *mut u8) = (match e { true => 1, false => 0 }) as u8;
                },
                V4::Int8(e) => {
                  *((base + 0) as *mut u8) = (1i32) as u8;
                  *((base + 8) as *mut u8) = (wit_bindgen::rt::as_i32(e)) as u8;
                },
                V4::Int16(e) => {
                  *((base + 0) as *mut u8) = (2i32) as u8;
                  *((base + 8) as *mut u16) = (wit_bindgen::rt::as_i32(e)) as u16;
                },
                V4::Int32(e) => {
                  *((base + 0) as *mut u8) = (3i32) as u8;
                  *((base + 8) as *mut i32) = wit_bindgen::rt::as_i32(e);
                },
                V4::Int64(e) => {
                  *((base + 0) as *mut u8) = (4i32) as u8;
                  *((base + 8) as *mut i64) = wit_bindgen::rt::as_i64(e);
                },
                V4::Uint8(e) => {
                  *((base + 0) as *mut u8) = (5i32) as u8;
                  *((base + 8) as *mut u8) = (wit_bindgen::rt::as_i32(e)) as u8;
                },
                V4::Uint16(e) => {
                  *((base + 0) as *mut u8) = (6i32) as u8;
                  *((base + 8) as *mut u16) = (wit_bindgen::rt::as_i32(e)) as u16;
                },
                V4::Uint32(e) => {
                  *((base + 0) as *mut u8) = (7i32) as u8;
                  *((base + 8) as *mut i32) = wit_bindgen::rt::as_i32(e);
                },
                V4::Uint64(e) => {
                  *((base + 0) as *mut u8) = (8i32) as u8;
                  *((base + 8) as *mut i64) = wit_bindgen::rt::as_i64(e);
                },
                V4::Floating32(e) => {
                  *((base + 0) as *mut u8) = (9i32) as u8;
                  *((base + 8) as *mut f32) = wit_bindgen::rt::as_f32(e);
                },
                V4::Floating64(e) => {
                  *((base + 0) as *mut u8) = (10i32) as u8;
                  *((base + 8) as *mut f64) = wit_bindgen::rt::as_f64(e);
                },
                V4::Str(e) => {
                  *((base + 0) as *mut u8) = (11i32) as u8;
                  let vec2 = e;
                  let ptr2 = vec2.as_ptr() as i32;
                  let len2 = vec2.len() as i32;
                  *((base + 12) as *mut i32) = len2;
                  *((base + 8) as *mut i32) = ptr2;
                },
                V4::Binary(e) => {
                  *((base + 0) as *mut u8) = (12i32) as u8;
                  let vec3 = e;
                  let ptr3 = vec3.as_ptr() as i32;
                  let len3 = vec3.len() as i32;
                  *((base + 12) as *mut i32) = len3;
                  *((base + 8) as *mut i32) = ptr3;
                },
                V4::DbNull=> {
                  {
                    *((base + 0) as *mut u8) = (13i32) as u8;
                  }
                }
              }
            }
          }
          let ptr6 = ret_area.as_mut_ptr() as i32;
          #[cfg(target_arch = "wasm32")]
          #[link(wasm_import_module = "fermyon:spin/mysql")]
          extern "C" {
            #[link_name = "query"]
            fn wit_import(_: i32, _: i32, _: i32, _: i32, _: i32, _: i32, _: i32, );
          }
          
          #[cfg(not(target_arch = "wasm32"))]
          fn wit_import(_: i32, _: i32, _: i32, _: i32, _: i32, _: i32, _: i32, ){ unreachable!() }
          wit_import(ptr0, len0, ptr1, len1, result5 as i32, len5, ptr6);
          let l7 = i32::from(*((ptr6 + 0) as *const u8));
          if layout5.size() != 0 {
            alloc::dealloc(result5, layout5);
          }
          match l7 {
            0 => {
              let e = {
                let l8 = *((ptr6 + 4) as *const i32);
                let l9 = *((ptr6 + 8) as *const i32);
                let base14 = l8;
                let len14 = l9;
                let mut result14 = Vec::with_capacity(len14 as usize);
                for i in 0..len14 {
                  let base = base14 + i * 12;
                  let e14 = {
                    let l10 = *((base + 0) as *const i32);
                    let l11 = *((base + 4) as *const i32);
                    let len12 = l11 as usize;
                    let bytes12 = Vec::from_raw_parts(l10 as *mut _, len12, len12);
                    let l13 = i32::from(*((base + 8) as *const u8));
                    
                    super::super::super::fermyon::spin::rdbms_types::Column{
                      name: wit_bindgen::rt::string_lift(bytes12),
                      data_type: super::super::super::fermyon::spin::rdbms_types::DbDataType::_lift(l13 as u8),
                    }
                  };
                  result14.push(e14);
                }
                wit_bindgen::rt::dealloc(base14, (len14 as usize) * 12, 4);
                let l15 = *((ptr6 + 12) as *const i32);
                let l16 = *((ptr6 + 16) as *const i32);
                let base39 = l15;
                let len39 = l16;
                let mut result39 = Vec::with_capacity(len39 as usize);
                for i in 0..len39 {
                  let base = base39 + i * 8;
                  let e39 = {
                    let l17 = *((base + 0) as *const i32);
                    let l18 = *((base + 4) as *const i32);
                    let base38 = l17;
                    let len38 = l18;
                    let mut result38 = Vec::with_capacity(len38 as usize);
                    for i in 0..len38 {
                      let base = base38 + i * 16;
                      let e38 = {
                        let l19 = i32::from(*((base + 0) as *const u8));
                        use super::super::super::fermyon::spin::rdbms_types::DbValue as V37;
                        let v37 = match l19 {
                          0 => {
                            let e37 = {
                              let l20 = i32::from(*((base + 8) as *const u8));
                              
                              wit_bindgen::rt::bool_lift(l20 as u8)
                            };
                            V37::Boolean(e37)
                          }
                          1 => {
                            let e37 = {
                              let l21 = i32::from(*((base + 8) as *const i8));
                              
                              l21 as i8
                            };
                            V37::Int8(e37)
                          }
                          2 => {
                            let e37 = {
                              let l22 = i32::from(*((base + 8) as *const i16));
                              
                              l22 as i16
                            };
                            V37::Int16(e37)
                          }
                          3 => {
                            let e37 = {
                              let l23 = *((base + 8) as *const i32);
                              
                              l23
                            };
                            V37::Int32(e37)
                          }
                          4 => {
                            let e37 = {
                              let l24 = *((base + 8) as *const i64);
                              
                              l24
                            };
                            V37::Int64(e37)
                          }
                          5 => {
                            let e37 = {
                              let l25 = i32::from(*((base + 8) as *const u8));
                              
                              l25 as u8
                            };
                            V37::Uint8(e37)
                          }
                          6 => {
                            let e37 = {
                              let l26 = i32::from(*((base + 8) as *const u16));
                              
                              l26 as u16
                            };
                            V37::Uint16(e37)
                          }
                          7 => {
                            let e37 = {
                              let l27 = *((base + 8) as *const i32);
                              
                              l27 as u32
                            };
                            V37::Uint32(e37)
                          }
                          8 => {
                            let e37 = {
                              let l28 = *((base + 8) as *const i64);
                              
                              l28 as u64
                            };
                            V37::Uint64(e37)
                          }
                          9 => {
                            let e37 = {
                              let l29 = *((base + 8) as *const f32);
                              
                              l29
                            };
                            V37::Floating32(e37)
                          }
                          10 => {
                            let e37 = {
                              let l30 = *((base + 8) as *const f64);
                              
                              l30
                            };
                            V37::Floating64(e37)
                          }
                          11 => {
                            let e37 = {
                              let l31 = *((base + 8) as *const i32);
                              let l32 = *((base + 12) as *const i32);
                              let len33 = l32 as usize;
                              let bytes33 = Vec::from_raw_parts(l31 as *mut _, len33, len33);
                              
                              wit_bindgen::rt::string_lift(bytes33)
                            };
                            V37::Str(e37)
                          }
                          12 => {
                            let e37 = {
                              let l34 = *((base + 8) as *const i32);
                              let l35 = *((base + 12) as *const i32);
                              let len36 = l35 as usize;
                              
                              Vec::from_raw_parts(l34 as *mut _, len36, len36)
                            };
                            V37::Binary(e37)
                          }
                          13 => {
                            V37::DbNull
                          }
                          n => {
                            debug_assert_eq!(n, 14, "invalid enum discriminant");
                            V37::Unsupported
                          }
                        };
                        
                        v37
                      };
                      result38.push(e38);
                    }
                    wit_bindgen::rt::dealloc(base38, (len38 as usize) * 16, 8);
                    
                    result38
                  };
                  result39.push(e39);
                }
                wit_bindgen::rt::dealloc(base39, (len39 as usize) * 8, 4);
                
                super::super::super::fermyon::spin::rdbms_types::RowSet{
                  columns: result14,
                  rows: result39,
                }
              };
              Ok(e)
            }
            1 => {
              let e = {
                let l40 = i32::from(*((ptr6 + 4) as *const u8));
                let v56 = match l40 {
                  0 => {
                    MysqlError::Success
                  }
                  1 => {
                    let e56 = {
                      let l41 = *((ptr6 + 8) as *const i32);
                      let l42 = *((ptr6 + 12) as *const i32);
                      let len43 = l42 as usize;
                      let bytes43 = Vec::from_raw_parts(l41 as *mut _, len43, len43);
                      
                      wit_bindgen::rt::string_lift(bytes43)
                    };
                    MysqlError::ConnectionFailed(e56)
                  }
                  2 => {
                    let e56 = {
                      let l44 = *((ptr6 + 8) as *const i32);
                      let l45 = *((ptr6 + 12) as *const i32);
                      let len46 = l45 as usize;
                      let bytes46 = Vec::from_raw_parts(l44 as *mut _, len46, len46);
                      
                      wit_bindgen::rt::string_lift(bytes46)
                    };
                    MysqlError::BadParameter(e56)
                  }
                  3 => {
                    let e56 = {
                      let l47 = *((ptr6 + 8) as *const i32);
                      let l48 = *((ptr6 + 12) as *const i32);
                      let len49 = l48 as usize;
                      let bytes49 = Vec::from_raw_parts(l47 as *mut _, len49, len49);
                      
                      wit_bindgen::rt::string_lift(bytes49)
                    };
                    MysqlError::QueryFailed(e56)
                  }
                  4 => {
                    let e56 = {
                      let l50 = *((ptr6 + 8) as *const i32);
                      let l51 = *((ptr6 + 12) as *const i32);
                      let len52 = l51 as usize;
                      let bytes52 = Vec::from_raw_parts(l50 as *mut _, len52, len52);
                      
                      wit_bindgen::rt::string_lift(bytes52)
                    };
                    MysqlError::ValueConversionFailed(e56)
                  }
                  n => {
                    debug_assert_eq!(n, 5, "invalid enum discriminant");
                    let e56 = {
                      let l53 = *((ptr6 + 8) as *const i32);
                      let l54 = *((ptr6 + 12) as *const i32);
                      let len55 = l54 as usize;
                      let bytes55 = Vec::from_raw_parts(l53 as *mut _, len55, len55);
                      
                      wit_bindgen::rt::string_lift(bytes55)
                    };
                    MysqlError::OtherError(e56)
                  }
                };
                
                v56
              };
              Err(e)
            }
            _ => wit_bindgen::rt::invalid_enum_discriminant(),
          }
        }
      }
      #[allow(clippy::all)]
      pub fn execute(address: &str,statement: &str,params: &[ParameterValue],) -> Result<(),MysqlError>{
        
        #[allow(unused_imports)]
        use wit_bindgen::rt::{alloc, vec::Vec, string::String};
        unsafe {
          
          #[repr(align(4))]
          struct RetArea([u8; 16]);
          let mut ret_area = ::core::mem::MaybeUninit::<RetArea>::uninit();
          let vec0 = address;
          let ptr0 = vec0.as_ptr() as i32;
          let len0 = vec0.len() as i32;
          let vec1 = statement;
          let ptr1 = vec1.as_ptr() as i32;
          let len1 = vec1.len() as i32;
          let vec5 = params;
          let len5 = vec5.len() as i32;
          let layout5 = alloc::Layout::from_size_align_unchecked(vec5.len() * 16, 8);
          let result5 = if layout5.size() != 0
          {
            let ptr = alloc::alloc(layout5);
            if ptr.is_null()
            {
              alloc::handle_alloc_error(layout5);
            }
            ptr
          }else {{
            ::core::ptr::null_mut()
          }};
          for (i, e) in vec5.into_iter().enumerate() {
            let base = result5 as i32 + (i as i32) * 16;
            {
              use super::super::super::fermyon::spin::rdbms_types::ParameterValue as V4;
              match e {
                V4::Boolean(e) => {
                  *((base + 0) as *mut u8) = (0i32) as u8;
                  *((base + 8) as *mut u8) = (match e { true => 1, false => 0 }) as u8;
                },
                V4::Int8(e) => {
                  *((base + 0) as *mut u8) = (1i32) as u8;
                  *((base + 8) as *mut u8) = (wit_bindgen::rt::as_i32(e)) as u8;
                },
                V4::Int16(e) => {
                  *((base + 0) as *mut u8) = (2i32) as u8;
                  *((base + 8) as *mut u16) = (wit_bindgen::rt::as_i32(e)) as u16;
                },
                V4::Int32(e) => {
                  *((base + 0) as *mut u8) = (3i32) as u8;
                  *((base + 8) as *mut i32) = wit_bindgen::rt::as_i32(e);
                },
                V4::Int64(e) => {
                  *((base + 0) as *mut u8) = (4i32) as u8;
                  *((base + 8) as *mut i64) = wit_bindgen::rt::as_i64(e);
                },
                V4::Uint8(e) => {
                  *((base + 0) as *mut u8) = (5i32) as u8;
                  *((base + 8) as *mut u8) = (wit_bindgen::rt::as_i32(e)) as u8;
                },
                V4::Uint16(e) => {
                  *((base + 0) as *mut u8) = (6i32) as u8;
                  *((base + 8) as *mut u16) = (wit_bindgen::rt::as_i32(e)) as u16;
                },
                V4::Uint32(e) => {
                  *((base + 0) as *mut u8) = (7i32) as u8;
                  *((base + 8) as *mut i32) = wit_bindgen::rt::as_i32(e);
                },
                V4::Uint64(e) => {
                  *((base + 0) as *mut u8) = (8i32) as u8;
                  *((base + 8) as *mut i64) = wit_bindgen::rt::as_i64(e);
                },
                V4::Floating32(e) => {
                  *((base + 0) as *mut u8) = (9i32) as u8;
                  *((base + 8) as *mut f32) = wit_bindgen::rt::as_f32(e);
                },
                V4::Floating64(e) => {
                  *((base + 0) as *mut u8) = (10i32) as u8;
                  *((base + 8) as *mut f64) = wit_bindgen::rt::as_f64(e);
                },
                V4::Str(e) => {
                  *((base + 0) as *mut u8) = (11i32) as u8;
                  let vec2 = e;
                  let ptr2 = vec2.as_ptr() as i32;
                  let len2 = vec2.len() as i32;
                  *((base + 12) as *mut i32) = len2;
                  *((base + 8) as *mut i32) = ptr2;
                },
                V4::Binary(e) => {
                  *((base + 0) as *mut u8) = (12i32) as u8;
                  let vec3 = e;
                  let ptr3 = vec3.as_ptr() as i32;
                  let len3 = vec3.len() as i32;
                  *((base + 12) as *mut i32) = len3;
                  *((base + 8) as *mut i32) = ptr3;
                },
                V4::DbNull=> {
                  {
                    *((base + 0) as *mut u8) = (13i32) as u8;
                  }
                }
              }
            }
          }
          let ptr6 = ret_area.as_mut_ptr() as i32;
          #[cfg(target_arch = "wasm32")]
          #[link(wasm_import_module = "fermyon:spin/mysql")]
          extern "C" {
            #[link_name = "execute"]
            fn wit_import(_: i32, _: i32, _: i32, _: i32, _: i32, _: i32, _: i32, );
          }
          
          #[cfg(not(target_arch = "wasm32"))]
          fn wit_import(_: i32, _: i32, _: i32, _: i32, _: i32, _: i32, _: i32, ){ unreachable!() }
          wit_import(ptr0, len0, ptr1, len1, result5 as i32, len5, ptr6);
          let l7 = i32::from(*((ptr6 + 0) as *const u8));
          if layout5.size() != 0 {
            alloc::dealloc(result5, layout5);
          }
          match l7 {
            0 => {
              let e = ();
              Ok(e)
            }
            1 => {
              let e = {
                let l8 = i32::from(*((ptr6 + 4) as *const u8));
                let v24 = match l8 {
                  0 => {
                    MysqlError::Success
                  }
                  1 => {
                    let e24 = {
                      let l9 = *((ptr6 + 8) as *const i32);
                      let l10 = *((ptr6 + 12) as *const i32);
                      let len11 = l10 as usize;
                      let bytes11 = Vec::from_raw_parts(l9 as *mut _, len11, len11);
                      
                      wit_bindgen::rt::string_lift(bytes11)
                    };
                    MysqlError::ConnectionFailed(e24)
                  }
                  2 => {
                    let e24 = {
                      let l12 = *((ptr6 + 8) as *const i32);
                      let l13 = *((ptr6 + 12) as *const i32);
                      let len14 = l13 as usize;
                      let bytes14 = Vec::from_raw_parts(l12 as *mut _, len14, len14);
                      
                      wit_bindgen::rt::string_lift(bytes14)
                    };
                    MysqlError::BadParameter(e24)
                  }
                  3 => {
                    let e24 = {
                      let l15 = *((ptr6 + 8) as *const i32);
                      let l16 = *((ptr6 + 12) as *const i32);
                      let len17 = l16 as usize;
                      let bytes17 = Vec::from_raw_parts(l15 as *mut _, len17, len17);
                      
                      wit_bindgen::rt::string_lift(bytes17)
                    };
                    MysqlError::QueryFailed(e24)
                  }
                  4 => {
                    let e24 = {
                      let l18 = *((ptr6 + 8) as *const i32);
                      let l19 = *((ptr6 + 12) as *const i32);
                      let len20 = l19 as usize;
                      let bytes20 = Vec::from_raw_parts(l18 as *mut _, len20, len20);
                      
                      wit_bindgen::rt::string_lift(bytes20)
                    };
                    MysqlError::ValueConversionFailed(e24)
                  }
                  n => {
                    debug_assert_eq!(n, 5, "invalid enum discriminant");
                    let e24 = {
                      let l21 = *((ptr6 + 8) as *const i32);
                      let l22 = *((ptr6 + 12) as *const i32);
                      let len23 = l22 as usize;
                      let bytes23 = Vec::from_raw_parts(l21 as *mut _, len23, len23);
                      
                      wit_bindgen::rt::string_lift(bytes23)
                    };
                    MysqlError::OtherError(e24)
                  }
                };
                
                v24
              };
              Err(e)
            }
            _ => wit_bindgen::rt::invalid_enum_discriminant(),
          }
        }
      }
      
    }
    
    
    #[allow(clippy::all)]
    pub mod redis_types {
      #[used]
      #[doc(hidden)]
      #[cfg(target_arch = "wasm32")]
      static __FORCE_SECTION_REF: fn() = super::super::super::__link_section;
      #[repr(u8)]
      #[derive(Clone, Copy, Eq, PartialEq)]
      pub enum Error {
        Success,
        Error,
      }
      impl Error{
        pub fn name(&self) -> &'static str {
          match self {
            Error::Success => "success",
            Error::Error => "error",
          }
        }
        pub fn message(&self) -> &'static str {
          match self {
            Error::Success => "",
            Error::Error => "",
          }
        }
      }
      impl ::core::fmt::Debug for Error{
        fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
          f.debug_struct("Error")
          .field("code", &(*self as i32))
          .field("name", &self.name())
          .field("message", &self.message())
          .finish()
        }
      }
      impl ::core::fmt::Display for Error{
        fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
          write!(f, "{} (error {})", self.name(), *self as i32)
        }
      }
      
      impl std::error::Error for Error{}
      
      impl Error{
        pub(crate) unsafe fn _lift(val: u8) -> Error{
          if !cfg!(debug_assertions) {
            return ::core::mem::transmute(val);
          }
          
          match val {
            0 => Error::Success,
            1 => Error::Error,
            
            _ => panic!("invalid enum discriminant"),
          }
        }
      }
      
      pub type Payload = wit_bindgen::rt::vec::Vec::<u8>;
      #[derive(Clone)]
      pub enum RedisParameter{
        Int64(i64),
        Binary(Payload),
      }
      impl ::core::fmt::Debug for RedisParameter {
        fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
          match self {
            RedisParameter::Int64(e) => {
              f.debug_tuple("RedisParameter::Int64").field(e).finish()
            }
            RedisParameter::Binary(e) => {
              f.debug_tuple("RedisParameter::Binary").field(e).finish()
            }
          }
        }
      }
      #[derive(Clone)]
      pub enum RedisResult{
        Nil,
        Status(wit_bindgen::rt::string::String),
        Int64(i64),
        Binary(Payload),
      }
      impl ::core::fmt::Debug for RedisResult {
        fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
          match self {
            RedisResult::Nil => {
              f.debug_tuple("RedisResult::Nil").finish()
            }
            RedisResult::Status(e) => {
              f.debug_tuple("RedisResult::Status").field(e).finish()
            }
            RedisResult::Int64(e) => {
              f.debug_tuple("RedisResult::Int64").field(e).finish()
            }
            RedisResult::Binary(e) => {
              f.debug_tuple("RedisResult::Binary").field(e).finish()
            }
          }
        }
      }
      
    }
    
    
    #[allow(clippy::all)]
    pub mod redis {
      #[used]
      #[doc(hidden)]
      #[cfg(target_arch = "wasm32")]
      static __FORCE_SECTION_REF: fn() = super::super::super::__link_section;
      pub type Payload = super::super::super::fermyon::spin::redis_types::Payload;
      pub type RedisParameter = super::super::super::fermyon::spin::redis_types::RedisParameter;
      pub type RedisResult = super::super::super::fermyon::spin::redis_types::RedisResult;
      pub type Error = super::super::super::fermyon::spin::redis_types::Error;
      #[allow(clippy::all)]
      pub fn publish(address: &str,channel: &str,payload: &Payload,) -> Result<(),Error>{
        
        #[allow(unused_imports)]
        use wit_bindgen::rt::{alloc, vec::Vec, string::String};
        unsafe {
          
          #[repr(align(1))]
          struct RetArea([u8; 2]);
          let mut ret_area = ::core::mem::MaybeUninit::<RetArea>::uninit();
          let vec0 = address;
          let ptr0 = vec0.as_ptr() as i32;
          let len0 = vec0.len() as i32;
          let vec1 = channel;
          let ptr1 = vec1.as_ptr() as i32;
          let len1 = vec1.len() as i32;
          let vec2 = payload;
          let ptr2 = vec2.as_ptr() as i32;
          let len2 = vec2.len() as i32;
          let ptr3 = ret_area.as_mut_ptr() as i32;
          #[cfg(target_arch = "wasm32")]
          #[link(wasm_import_module = "fermyon:spin/redis")]
          extern "C" {
            #[link_name = "publish"]
            fn wit_import(_: i32, _: i32, _: i32, _: i32, _: i32, _: i32, _: i32, );
          }
          
          #[cfg(not(target_arch = "wasm32"))]
          fn wit_import(_: i32, _: i32, _: i32, _: i32, _: i32, _: i32, _: i32, ){ unreachable!() }
          wit_import(ptr0, len0, ptr1, len1, ptr2, len2, ptr3);
          let l4 = i32::from(*((ptr3 + 0) as *const u8));
          match l4 {
            0 => {
              let e = ();
              Ok(e)
            }
            1 => {
              let e = {
                let l5 = i32::from(*((ptr3 + 1) as *const u8));
                
                super::super::super::fermyon::spin::redis_types::Error::_lift(l5 as u8)
              };
              Err(e)
            }
            _ => wit_bindgen::rt::invalid_enum_discriminant(),
          }
        }
      }
      #[allow(clippy::all)]
      pub fn get(address: &str,key: &str,) -> Result<Payload,Error>{
        
        #[allow(unused_imports)]
        use wit_bindgen::rt::{alloc, vec::Vec, string::String};
        unsafe {
          
          #[repr(align(4))]
          struct RetArea([u8; 12]);
          let mut ret_area = ::core::mem::MaybeUninit::<RetArea>::uninit();
          let vec0 = address;
          let ptr0 = vec0.as_ptr() as i32;
          let len0 = vec0.len() as i32;
          let vec1 = key;
          let ptr1 = vec1.as_ptr() as i32;
          let len1 = vec1.len() as i32;
          let ptr2 = ret_area.as_mut_ptr() as i32;
          #[cfg(target_arch = "wasm32")]
          #[link(wasm_import_module = "fermyon:spin/redis")]
          extern "C" {
            #[link_name = "get"]
            fn wit_import(_: i32, _: i32, _: i32, _: i32, _: i32, );
          }
          
          #[cfg(not(target_arch = "wasm32"))]
          fn wit_import(_: i32, _: i32, _: i32, _: i32, _: i32, ){ unreachable!() }
          wit_import(ptr0, len0, ptr1, len1, ptr2);
          let l3 = i32::from(*((ptr2 + 0) as *const u8));
          match l3 {
            0 => {
              let e = {
                let l4 = *((ptr2 + 4) as *const i32);
                let l5 = *((ptr2 + 8) as *const i32);
                let len6 = l5 as usize;
                
                Vec::from_raw_parts(l4 as *mut _, len6, len6)
              };
              Ok(e)
            }
            1 => {
              let e = {
                let l7 = i32::from(*((ptr2 + 4) as *const u8));
                
                super::super::super::fermyon::spin::redis_types::Error::_lift(l7 as u8)
              };
              Err(e)
            }
            _ => wit_bindgen::rt::invalid_enum_discriminant(),
          }
        }
      }
      #[allow(clippy::all)]
      pub fn set(address: &str,key: &str,value: &Payload,) -> Result<(),Error>{
        
        #[allow(unused_imports)]
        use wit_bindgen::rt::{alloc, vec::Vec, string::String};
        unsafe {
          
          #[repr(align(1))]
          struct RetArea([u8; 2]);
          let mut ret_area = ::core::mem::MaybeUninit::<RetArea>::uninit();
          let vec0 = address;
          let ptr0 = vec0.as_ptr() as i32;
          let len0 = vec0.len() as i32;
          let vec1 = key;
          let ptr1 = vec1.as_ptr() as i32;
          let len1 = vec1.len() as i32;
          let vec2 = value;
          let ptr2 = vec2.as_ptr() as i32;
          let len2 = vec2.len() as i32;
          let ptr3 = ret_area.as_mut_ptr() as i32;
          #[cfg(target_arch = "wasm32")]
          #[link(wasm_import_module = "fermyon:spin/redis")]
          extern "C" {
            #[link_name = "set"]
            fn wit_import(_: i32, _: i32, _: i32, _: i32, _: i32, _: i32, _: i32, );
          }
          
          #[cfg(not(target_arch = "wasm32"))]
          fn wit_import(_: i32, _: i32, _: i32, _: i32, _: i32, _: i32, _: i32, ){ unreachable!() }
          wit_import(ptr0, len0, ptr1, len1, ptr2, len2, ptr3);
          let l4 = i32::from(*((ptr3 + 0) as *const u8));
          match l4 {
            0 => {
              let e = ();
              Ok(e)
            }
            1 => {
              let e = {
                let l5 = i32::from(*((ptr3 + 1) as *const u8));
                
                super::super::super::fermyon::spin::redis_types::Error::_lift(l5 as u8)
              };
              Err(e)
            }
            _ => wit_bindgen::rt::invalid_enum_discriminant(),
          }
        }
      }
      #[allow(clippy::all)]
      pub fn incr(address: &str,key: &str,) -> Result<i64,Error>{
        
        #[allow(unused_imports)]
        use wit_bindgen::rt::{alloc, vec::Vec, string::String};
        unsafe {
          
          #[repr(align(8))]
          struct RetArea([u8; 16]);
          let mut ret_area = ::core::mem::MaybeUninit::<RetArea>::uninit();
          let vec0 = address;
          let ptr0 = vec0.as_ptr() as i32;
          let len0 = vec0.len() as i32;
          let vec1 = key;
          let ptr1 = vec1.as_ptr() as i32;
          let len1 = vec1.len() as i32;
          let ptr2 = ret_area.as_mut_ptr() as i32;
          #[cfg(target_arch = "wasm32")]
          #[link(wasm_import_module = "fermyon:spin/redis")]
          extern "C" {
            #[link_name = "incr"]
            fn wit_import(_: i32, _: i32, _: i32, _: i32, _: i32, );
          }
          
          #[cfg(not(target_arch = "wasm32"))]
          fn wit_import(_: i32, _: i32, _: i32, _: i32, _: i32, ){ unreachable!() }
          wit_import(ptr0, len0, ptr1, len1, ptr2);
          let l3 = i32::from(*((ptr2 + 0) as *const u8));
          match l3 {
            0 => {
              let e = {
                let l4 = *((ptr2 + 8) as *const i64);
                
                l4
              };
              Ok(e)
            }
            1 => {
              let e = {
                let l5 = i32::from(*((ptr2 + 8) as *const u8));
                
                super::super::super::fermyon::spin::redis_types::Error::_lift(l5 as u8)
              };
              Err(e)
            }
            _ => wit_bindgen::rt::invalid_enum_discriminant(),
          }
        }
      }
      #[allow(clippy::all)]
      pub fn del(address: &str,keys: &[wit_bindgen::rt::string::String],) -> Result<i64,Error>{
        
        #[allow(unused_imports)]
        use wit_bindgen::rt::{alloc, vec::Vec, string::String};
        unsafe {
          
          #[repr(align(8))]
          struct RetArea([u8; 16]);
          let mut ret_area = ::core::mem::MaybeUninit::<RetArea>::uninit();
          let vec0 = address;
          let ptr0 = vec0.as_ptr() as i32;
          let len0 = vec0.len() as i32;
          let vec2 = keys;
          let len2 = vec2.len() as i32;
          let layout2 = alloc::Layout::from_size_align_unchecked(vec2.len() * 8, 4);
          let result2 = if layout2.size() != 0
          {
            let ptr = alloc::alloc(layout2);
            if ptr.is_null()
            {
              alloc::handle_alloc_error(layout2);
            }
            ptr
          }else {{
            ::core::ptr::null_mut()
          }};
          for (i, e) in vec2.into_iter().enumerate() {
            let base = result2 as i32 + (i as i32) * 8;
            {
              let vec1 = e;
              let ptr1 = vec1.as_ptr() as i32;
              let len1 = vec1.len() as i32;
              *((base + 4) as *mut i32) = len1;
              *((base + 0) as *mut i32) = ptr1;
            }
          }
          let ptr3 = ret_area.as_mut_ptr() as i32;
          #[cfg(target_arch = "wasm32")]
          #[link(wasm_import_module = "fermyon:spin/redis")]
          extern "C" {
            #[link_name = "del"]
            fn wit_import(_: i32, _: i32, _: i32, _: i32, _: i32, );
          }
          
          #[cfg(not(target_arch = "wasm32"))]
          fn wit_import(_: i32, _: i32, _: i32, _: i32, _: i32, ){ unreachable!() }
          wit_import(ptr0, len0, result2 as i32, len2, ptr3);
          let l4 = i32::from(*((ptr3 + 0) as *const u8));
          if layout2.size() != 0 {
            alloc::dealloc(result2, layout2);
          }
          match l4 {
            0 => {
              let e = {
                let l5 = *((ptr3 + 8) as *const i64);
                
                l5
              };
              Ok(e)
            }
            1 => {
              let e = {
                let l6 = i32::from(*((ptr3 + 8) as *const u8));
                
                super::super::super::fermyon::spin::redis_types::Error::_lift(l6 as u8)
              };
              Err(e)
            }
            _ => wit_bindgen::rt::invalid_enum_discriminant(),
          }
        }
      }
      #[allow(clippy::all)]
      pub fn sadd(address: &str,key: &str,values: &[wit_bindgen::rt::string::String],) -> Result<i64,Error>{
        
        #[allow(unused_imports)]
        use wit_bindgen::rt::{alloc, vec::Vec, string::String};
        unsafe {
          
          #[repr(align(8))]
          struct RetArea([u8; 16]);
          let mut ret_area = ::core::mem::MaybeUninit::<RetArea>::uninit();
          let vec0 = address;
          let ptr0 = vec0.as_ptr() as i32;
          let len0 = vec0.len() as i32;
          let vec1 = key;
          let ptr1 = vec1.as_ptr() as i32;
          let len1 = vec1.len() as i32;
          let vec3 = values;
          let len3 = vec3.len() as i32;
          let layout3 = alloc::Layout::from_size_align_unchecked(vec3.len() * 8, 4);
          let result3 = if layout3.size() != 0
          {
            let ptr = alloc::alloc(layout3);
            if ptr.is_null()
            {
              alloc::handle_alloc_error(layout3);
            }
            ptr
          }else {{
            ::core::ptr::null_mut()
          }};
          for (i, e) in vec3.into_iter().enumerate() {
            let base = result3 as i32 + (i as i32) * 8;
            {
              let vec2 = e;
              let ptr2 = vec2.as_ptr() as i32;
              let len2 = vec2.len() as i32;
              *((base + 4) as *mut i32) = len2;
              *((base + 0) as *mut i32) = ptr2;
            }
          }
          let ptr4 = ret_area.as_mut_ptr() as i32;
          #[cfg(target_arch = "wasm32")]
          #[link(wasm_import_module = "fermyon:spin/redis")]
          extern "C" {
            #[link_name = "sadd"]
            fn wit_import(_: i32, _: i32, _: i32, _: i32, _: i32, _: i32, _: i32, );
          }
          
          #[cfg(not(target_arch = "wasm32"))]
          fn wit_import(_: i32, _: i32, _: i32, _: i32, _: i32, _: i32, _: i32, ){ unreachable!() }
          wit_import(ptr0, len0, ptr1, len1, result3 as i32, len3, ptr4);
          let l5 = i32::from(*((ptr4 + 0) as *const u8));
          if layout3.size() != 0 {
            alloc::dealloc(result3, layout3);
          }
          match l5 {
            0 => {
              let e = {
                let l6 = *((ptr4 + 8) as *const i64);
                
                l6
              };
              Ok(e)
            }
            1 => {
              let e = {
                let l7 = i32::from(*((ptr4 + 8) as *const u8));
                
                super::super::super::fermyon::spin::redis_types::Error::_lift(l7 as u8)
              };
              Err(e)
            }
            _ => wit_bindgen::rt::invalid_enum_discriminant(),
          }
        }
      }
      #[allow(clippy::all)]
      pub fn smembers(address: &str,key: &str,) -> Result<wit_bindgen::rt::vec::Vec::<wit_bindgen::rt::string::String>,Error>{
        
        #[allow(unused_imports)]
        use wit_bindgen::rt::{alloc, vec::Vec, string::String};
        unsafe {
          
          #[repr(align(4))]
          struct RetArea([u8; 12]);
          let mut ret_area = ::core::mem::MaybeUninit::<RetArea>::uninit();
          let vec0 = address;
          let ptr0 = vec0.as_ptr() as i32;
          let len0 = vec0.len() as i32;
          let vec1 = key;
          let ptr1 = vec1.as_ptr() as i32;
          let len1 = vec1.len() as i32;
          let ptr2 = ret_area.as_mut_ptr() as i32;
          #[cfg(target_arch = "wasm32")]
          #[link(wasm_import_module = "fermyon:spin/redis")]
          extern "C" {
            #[link_name = "smembers"]
            fn wit_import(_: i32, _: i32, _: i32, _: i32, _: i32, );
          }
          
          #[cfg(not(target_arch = "wasm32"))]
          fn wit_import(_: i32, _: i32, _: i32, _: i32, _: i32, ){ unreachable!() }
          wit_import(ptr0, len0, ptr1, len1, ptr2);
          let l3 = i32::from(*((ptr2 + 0) as *const u8));
          match l3 {
            0 => {
              let e = {
                let l4 = *((ptr2 + 4) as *const i32);
                let l5 = *((ptr2 + 8) as *const i32);
                let base9 = l4;
                let len9 = l5;
                let mut result9 = Vec::with_capacity(len9 as usize);
                for i in 0..len9 {
                  let base = base9 + i * 8;
                  let e9 = {
                    let l6 = *((base + 0) as *const i32);
                    let l7 = *((base + 4) as *const i32);
                    let len8 = l7 as usize;
                    let bytes8 = Vec::from_raw_parts(l6 as *mut _, len8, len8);
                    
                    wit_bindgen::rt::string_lift(bytes8)
                  };
                  result9.push(e9);
                }
                wit_bindgen::rt::dealloc(base9, (len9 as usize) * 8, 4);
                
                result9
              };
              Ok(e)
            }
            1 => {
              let e = {
                let l10 = i32::from(*((ptr2 + 4) as *const u8));
                
                super::super::super::fermyon::spin::redis_types::Error::_lift(l10 as u8)
              };
              Err(e)
            }
            _ => wit_bindgen::rt::invalid_enum_discriminant(),
          }
        }
      }
      #[allow(clippy::all)]
      pub fn srem(address: &str,key: &str,values: &[wit_bindgen::rt::string::String],) -> Result<i64,Error>{
        
        #[allow(unused_imports)]
        use wit_bindgen::rt::{alloc, vec::Vec, string::String};
        unsafe {
          
          #[repr(align(8))]
          struct RetArea([u8; 16]);
          let mut ret_area = ::core::mem::MaybeUninit::<RetArea>::uninit();
          let vec0 = address;
          let ptr0 = vec0.as_ptr() as i32;
          let len0 = vec0.len() as i32;
          let vec1 = key;
          let ptr1 = vec1.as_ptr() as i32;
          let len1 = vec1.len() as i32;
          let vec3 = values;
          let len3 = vec3.len() as i32;
          let layout3 = alloc::Layout::from_size_align_unchecked(vec3.len() * 8, 4);
          let result3 = if layout3.size() != 0
          {
            let ptr = alloc::alloc(layout3);
            if ptr.is_null()
            {
              alloc::handle_alloc_error(layout3);
            }
            ptr
          }else {{
            ::core::ptr::null_mut()
          }};
          for (i, e) in vec3.into_iter().enumerate() {
            let base = result3 as i32 + (i as i32) * 8;
            {
              let vec2 = e;
              let ptr2 = vec2.as_ptr() as i32;
              let len2 = vec2.len() as i32;
              *((base + 4) as *mut i32) = len2;
              *((base + 0) as *mut i32) = ptr2;
            }
          }
          let ptr4 = ret_area.as_mut_ptr() as i32;
          #[cfg(target_arch = "wasm32")]
          #[link(wasm_import_module = "fermyon:spin/redis")]
          extern "C" {
            #[link_name = "srem"]
            fn wit_import(_: i32, _: i32, _: i32, _: i32, _: i32, _: i32, _: i32, );
          }
          
          #[cfg(not(target_arch = "wasm32"))]
          fn wit_import(_: i32, _: i32, _: i32, _: i32, _: i32, _: i32, _: i32, ){ unreachable!() }
          wit_import(ptr0, len0, ptr1, len1, result3 as i32, len3, ptr4);
          let l5 = i32::from(*((ptr4 + 0) as *const u8));
          if layout3.size() != 0 {
            alloc::dealloc(result3, layout3);
          }
          match l5 {
            0 => {
              let e = {
                let l6 = *((ptr4 + 8) as *const i64);
                
                l6
              };
              Ok(e)
            }
            1 => {
              let e = {
                let l7 = i32::from(*((ptr4 + 8) as *const u8));
                
                super::super::super::fermyon::spin::redis_types::Error::_lift(l7 as u8)
              };
              Err(e)
            }
            _ => wit_bindgen::rt::invalid_enum_discriminant(),
          }
        }
      }
      #[allow(clippy::all)]
      pub fn execute(address: &str,command: &str,arguments: &[RedisParameter],) -> Result<wit_bindgen::rt::vec::Vec::<RedisResult>,Error>{
        
        #[allow(unused_imports)]
        use wit_bindgen::rt::{alloc, vec::Vec, string::String};
        unsafe {
          
          #[repr(align(4))]
          struct RetArea([u8; 12]);
          let mut ret_area = ::core::mem::MaybeUninit::<RetArea>::uninit();
          let vec0 = address;
          let ptr0 = vec0.as_ptr() as i32;
          let len0 = vec0.len() as i32;
          let vec1 = command;
          let ptr1 = vec1.as_ptr() as i32;
          let len1 = vec1.len() as i32;
          let vec4 = arguments;
          let len4 = vec4.len() as i32;
          let layout4 = alloc::Layout::from_size_align_unchecked(vec4.len() * 16, 8);
          let result4 = if layout4.size() != 0
          {
            let ptr = alloc::alloc(layout4);
            if ptr.is_null()
            {
              alloc::handle_alloc_error(layout4);
            }
            ptr
          }else {{
            ::core::ptr::null_mut()
          }};
          for (i, e) in vec4.into_iter().enumerate() {
            let base = result4 as i32 + (i as i32) * 16;
            {
              use super::super::super::fermyon::spin::redis_types::RedisParameter as V3;
              match e {
                V3::Int64(e) => {
                  *((base + 0) as *mut u8) = (0i32) as u8;
                  *((base + 8) as *mut i64) = wit_bindgen::rt::as_i64(e);
                },
                V3::Binary(e) => {
                  *((base + 0) as *mut u8) = (1i32) as u8;
                  let vec2 = e;
                  let ptr2 = vec2.as_ptr() as i32;
                  let len2 = vec2.len() as i32;
                  *((base + 12) as *mut i32) = len2;
                  *((base + 8) as *mut i32) = ptr2;
                },
              }
            }
          }
          let ptr5 = ret_area.as_mut_ptr() as i32;
          #[cfg(target_arch = "wasm32")]
          #[link(wasm_import_module = "fermyon:spin/redis")]
          extern "C" {
            #[link_name = "execute"]
            fn wit_import(_: i32, _: i32, _: i32, _: i32, _: i32, _: i32, _: i32, );
          }
          
          #[cfg(not(target_arch = "wasm32"))]
          fn wit_import(_: i32, _: i32, _: i32, _: i32, _: i32, _: i32, _: i32, ){ unreachable!() }
          wit_import(ptr0, len0, ptr1, len1, result4 as i32, len4, ptr5);
          let l6 = i32::from(*((ptr5 + 0) as *const u8));
          if layout4.size() != 0 {
            alloc::dealloc(result4, layout4);
          }
          match l6 {
            0 => {
              let e = {
                let l7 = *((ptr5 + 4) as *const i32);
                let l8 = *((ptr5 + 8) as *const i32);
                let base18 = l7;
                let len18 = l8;
                let mut result18 = Vec::with_capacity(len18 as usize);
                for i in 0..len18 {
                  let base = base18 + i * 16;
                  let e18 = {
                    let l9 = i32::from(*((base + 0) as *const u8));
                    use super::super::super::fermyon::spin::redis_types::RedisResult as V17;
                    let v17 = match l9 {
                      0 => {
                        V17::Nil
                      }
                      1 => {
                        let e17 = {
                          let l10 = *((base + 8) as *const i32);
                          let l11 = *((base + 12) as *const i32);
                          let len12 = l11 as usize;
                          let bytes12 = Vec::from_raw_parts(l10 as *mut _, len12, len12);
                          
                          wit_bindgen::rt::string_lift(bytes12)
                        };
                        V17::Status(e17)
                      }
                      2 => {
                        let e17 = {
                          let l13 = *((base + 8) as *const i64);
                          
                          l13
                        };
                        V17::Int64(e17)
                      }
                      n => {
                        debug_assert_eq!(n, 3, "invalid enum discriminant");
                        let e17 = {
                          let l14 = *((base + 8) as *const i32);
                          let l15 = *((base + 12) as *const i32);
                          let len16 = l15 as usize;
                          
                          Vec::from_raw_parts(l14 as *mut _, len16, len16)
                        };
                        V17::Binary(e17)
                      }
                    };
                    
                    v17
                  };
                  result18.push(e18);
                }
                wit_bindgen::rt::dealloc(base18, (len18 as usize) * 16, 8);
                
                result18
              };
              Ok(e)
            }
            1 => {
              let e = {
                let l19 = i32::from(*((ptr5 + 4) as *const u8));
                
                super::super::super::fermyon::spin::redis_types::Error::_lift(l19 as u8)
              };
              Err(e)
            }
            _ => wit_bindgen::rt::invalid_enum_discriminant(),
          }
        }
      }
      
    }
    
    
    #[allow(clippy::all)]
    pub mod llm {
      #[used]
      #[doc(hidden)]
      #[cfg(target_arch = "wasm32")]
      static __FORCE_SECTION_REF: fn() = super::super::super::__link_section;
      /// A Large Language Model.
      pub type InferencingModel = wit_bindgen::rt::string::String;
      /// Inference request parameters
      #[repr(C)]
      #[derive(Clone, Copy)]
      pub struct InferencingParams {
        /// The maximum tokens that should be inferred.
        /// 
        /// Note: the backing implementation may return less tokens.
        pub max_tokens: u32,
        /// The amount the model should avoid repeating tokens.
        pub repeat_penalty: f32,
        /// The number of tokens the model should apply the repeat penalty to.
        pub repeat_penalty_last_n_token_count: u32,
        /// The randomness with which the next token is selected.
        pub temperature: f32,
        /// The number of possible next tokens the model will choose from.
        pub top_k: u32,
        /// The probability total of next tokens the model will choose from.
        pub top_p: f32,
      }
      impl ::core::fmt::Debug for InferencingParams {
        fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
          f.debug_struct("InferencingParams").field("max-tokens", &self.max_tokens).field("repeat-penalty", &self.repeat_penalty).field("repeat-penalty-last-n-token-count", &self.repeat_penalty_last_n_token_count).field("temperature", &self.temperature).field("top-k", &self.top_k).field("top-p", &self.top_p).finish()
        }
      }
      /// The set of errors which may be raised by functions in this interface
      #[derive(Clone)]
      pub enum Error{
        ModelNotSupported,
        RuntimeError(wit_bindgen::rt::string::String),
        InvalidInput(wit_bindgen::rt::string::String),
      }
      impl ::core::fmt::Debug for Error {
        fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
          match self {
            Error::ModelNotSupported => {
              f.debug_tuple("Error::ModelNotSupported").finish()
            }
            Error::RuntimeError(e) => {
              f.debug_tuple("Error::RuntimeError").field(e).finish()
            }
            Error::InvalidInput(e) => {
              f.debug_tuple("Error::InvalidInput").field(e).finish()
            }
          }
        }
      }
      impl ::core::fmt::Display for Error {
        fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
          write!(f, "{:?}", self)
        }
      }
      
      impl std::error::Error for Error {}
      /// Usage information related to the inferencing result
      #[repr(C)]
      #[derive(Clone, Copy)]
      pub struct InferencingUsage {
        /// Number of tokens in the prompt
        pub prompt_token_count: u32,
        /// Number of tokens generated by the inferencing operation
        pub generated_token_count: u32,
      }
      impl ::core::fmt::Debug for InferencingUsage {
        fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
          f.debug_struct("InferencingUsage").field("prompt-token-count", &self.prompt_token_count).field("generated-token-count", &self.generated_token_count).finish()
        }
      }
      /// An inferencing result
      #[derive(Clone)]
      pub struct InferencingResult {
        /// The text generated by the model
        pub text: wit_bindgen::rt::string::String,
        /// Usage information about the inferencing request
        pub usage: InferencingUsage,
      }
      impl ::core::fmt::Debug for InferencingResult {
        fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
          f.debug_struct("InferencingResult").field("text", &self.text).field("usage", &self.usage).finish()
        }
      }
      /// The model used for generating embeddings
      pub type EmbeddingModel = wit_bindgen::rt::string::String;
      /// Usage related to an embeddings generation request
      #[repr(C)]
      #[derive(Clone, Copy)]
      pub struct EmbeddingsUsage {
        /// Number of tokens in the prompt
        pub prompt_token_count: u32,
      }
      impl ::core::fmt::Debug for EmbeddingsUsage {
        fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
          f.debug_struct("EmbeddingsUsage").field("prompt-token-count", &self.prompt_token_count).finish()
        }
      }
      /// Result of generating embeddings
      #[derive(Clone)]
      pub struct EmbeddingsResult {
        /// The embeddings generated by the request
        pub embeddings: wit_bindgen::rt::vec::Vec::<wit_bindgen::rt::vec::Vec::<f32>>,
        /// Usage related to the embeddings generation request
        pub usage: EmbeddingsUsage,
      }
      impl ::core::fmt::Debug for EmbeddingsResult {
        fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
          f.debug_struct("EmbeddingsResult").field("embeddings", &self.embeddings).field("usage", &self.usage).finish()
        }
      }
      #[allow(clippy::all)]
      /// Perform inferencing using the provided model and prompt with the given optional params
      pub fn infer(model: &InferencingModel,prompt: &str,params: Option<InferencingParams>,) -> Result<InferencingResult,Error>{
        
        #[allow(unused_imports)]
        use wit_bindgen::rt::{alloc, vec::Vec, string::String};
        unsafe {
          
          #[repr(align(4))]
          struct RetArea([u8; 20]);
          let mut ret_area = ::core::mem::MaybeUninit::<RetArea>::uninit();
          let vec0 = model;
          let ptr0 = vec0.as_ptr() as i32;
          let len0 = vec0.len() as i32;
          let vec1 = prompt;
          let ptr1 = vec1.as_ptr() as i32;
          let len1 = vec1.len() as i32;
          let (result3_0,result3_1,result3_2,result3_3,result3_4,result3_5,result3_6,) = match params {
            Some(e) => {
              let InferencingParams{ max_tokens:max_tokens2, repeat_penalty:repeat_penalty2, repeat_penalty_last_n_token_count:repeat_penalty_last_n_token_count2, temperature:temperature2, top_k:top_k2, top_p:top_p2, } = e;
              
              (1i32, wit_bindgen::rt::as_i32(max_tokens2), wit_bindgen::rt::as_f32(repeat_penalty2), wit_bindgen::rt::as_i32(repeat_penalty_last_n_token_count2), wit_bindgen::rt::as_f32(temperature2), wit_bindgen::rt::as_i32(top_k2), wit_bindgen::rt::as_f32(top_p2))
            },
            None => {
              (0i32, 0i32, 0.0f32, 0i32, 0.0f32, 0i32, 0.0f32)
            },
          };let ptr4 = ret_area.as_mut_ptr() as i32;
          #[cfg(target_arch = "wasm32")]
          #[link(wasm_import_module = "fermyon:spin/llm")]
          extern "C" {
            #[link_name = "infer"]
            fn wit_import(_: i32, _: i32, _: i32, _: i32, _: i32, _: i32, _: f32, _: i32, _: f32, _: i32, _: f32, _: i32, );
          }
          
          #[cfg(not(target_arch = "wasm32"))]
          fn wit_import(_: i32, _: i32, _: i32, _: i32, _: i32, _: i32, _: f32, _: i32, _: f32, _: i32, _: f32, _: i32, ){ unreachable!() }
          wit_import(ptr0, len0, ptr1, len1, result3_0, result3_1, result3_2, result3_3, result3_4, result3_5, result3_6, ptr4);
          let l5 = i32::from(*((ptr4 + 0) as *const u8));
          match l5 {
            0 => {
              let e = {
                let l6 = *((ptr4 + 4) as *const i32);
                let l7 = *((ptr4 + 8) as *const i32);
                let len8 = l7 as usize;
                let bytes8 = Vec::from_raw_parts(l6 as *mut _, len8, len8);
                let l9 = *((ptr4 + 12) as *const i32);
                let l10 = *((ptr4 + 16) as *const i32);
                
                InferencingResult{
                  text: wit_bindgen::rt::string_lift(bytes8),
                  usage: InferencingUsage{
                    prompt_token_count: l9 as u32,
                    generated_token_count: l10 as u32,
                  },
                }
              };
              Ok(e)
            }
            1 => {
              let e = {
                let l11 = i32::from(*((ptr4 + 4) as *const u8));
                let v18 = match l11 {
                  0 => {
                    Error::ModelNotSupported
                  }
                  1 => {
                    let e18 = {
                      let l12 = *((ptr4 + 8) as *const i32);
                      let l13 = *((ptr4 + 12) as *const i32);
                      let len14 = l13 as usize;
                      let bytes14 = Vec::from_raw_parts(l12 as *mut _, len14, len14);
                      
                      wit_bindgen::rt::string_lift(bytes14)
                    };
                    Error::RuntimeError(e18)
                  }
                  n => {
                    debug_assert_eq!(n, 2, "invalid enum discriminant");
                    let e18 = {
                      let l15 = *((ptr4 + 8) as *const i32);
                      let l16 = *((ptr4 + 12) as *const i32);
                      let len17 = l16 as usize;
                      let bytes17 = Vec::from_raw_parts(l15 as *mut _, len17, len17);
                      
                      wit_bindgen::rt::string_lift(bytes17)
                    };
                    Error::InvalidInput(e18)
                  }
                };
                
                v18
              };
              Err(e)
            }
            _ => wit_bindgen::rt::invalid_enum_discriminant(),
          }
        }
      }
      #[allow(clippy::all)]
      /// Generate embeddings for the supplied list of text
      pub fn generate_embeddings(model: &EmbeddingModel,text: &[wit_bindgen::rt::string::String],) -> Result<EmbeddingsResult,Error>{
        
        #[allow(unused_imports)]
        use wit_bindgen::rt::{alloc, vec::Vec, string::String};
        unsafe {
          
          #[repr(align(4))]
          struct RetArea([u8; 16]);
          let mut ret_area = ::core::mem::MaybeUninit::<RetArea>::uninit();
          let vec0 = model;
          let ptr0 = vec0.as_ptr() as i32;
          let len0 = vec0.len() as i32;
          let vec2 = text;
          let len2 = vec2.len() as i32;
          let layout2 = alloc::Layout::from_size_align_unchecked(vec2.len() * 8, 4);
          let result2 = if layout2.size() != 0
          {
            let ptr = alloc::alloc(layout2);
            if ptr.is_null()
            {
              alloc::handle_alloc_error(layout2);
            }
            ptr
          }else {{
            ::core::ptr::null_mut()
          }};
          for (i, e) in vec2.into_iter().enumerate() {
            let base = result2 as i32 + (i as i32) * 8;
            {
              let vec1 = e;
              let ptr1 = vec1.as_ptr() as i32;
              let len1 = vec1.len() as i32;
              *((base + 4) as *mut i32) = len1;
              *((base + 0) as *mut i32) = ptr1;
            }
          }
          let ptr3 = ret_area.as_mut_ptr() as i32;
          #[cfg(target_arch = "wasm32")]
          #[link(wasm_import_module = "fermyon:spin/llm")]
          extern "C" {
            #[link_name = "generate-embeddings"]
            fn wit_import(_: i32, _: i32, _: i32, _: i32, _: i32, );
          }
          
          #[cfg(not(target_arch = "wasm32"))]
          fn wit_import(_: i32, _: i32, _: i32, _: i32, _: i32, ){ unreachable!() }
          wit_import(ptr0, len0, result2 as i32, len2, ptr3);
          let l4 = i32::from(*((ptr3 + 0) as *const u8));
          if layout2.size() != 0 {
            alloc::dealloc(result2, layout2);
          }
          match l4 {
            0 => {
              let e = {
                let l5 = *((ptr3 + 4) as *const i32);
                let l6 = *((ptr3 + 8) as *const i32);
                let base10 = l5;
                let len10 = l6;
                let mut result10 = Vec::with_capacity(len10 as usize);
                for i in 0..len10 {
                  let base = base10 + i * 8;
                  let e10 = {
                    let l7 = *((base + 0) as *const i32);
                    let l8 = *((base + 4) as *const i32);
                    let len9 = l8 as usize;
                    
                    Vec::from_raw_parts(l7 as *mut _, len9, len9)
                  };
                  result10.push(e10);
                }
                wit_bindgen::rt::dealloc(base10, (len10 as usize) * 8, 4);
                let l11 = *((ptr3 + 12) as *const i32);
                
                EmbeddingsResult{
                  embeddings: result10,
                  usage: EmbeddingsUsage{
                    prompt_token_count: l11 as u32,
                  },
                }
              };
              Ok(e)
            }
            1 => {
              let e = {
                let l12 = i32::from(*((ptr3 + 4) as *const u8));
                let v19 = match l12 {
                  0 => {
                    Error::ModelNotSupported
                  }
                  1 => {
                    let e19 = {
                      let l13 = *((ptr3 + 8) as *const i32);
                      let l14 = *((ptr3 + 12) as *const i32);
                      let len15 = l14 as usize;
                      let bytes15 = Vec::from_raw_parts(l13 as *mut _, len15, len15);
                      
                      wit_bindgen::rt::string_lift(bytes15)
                    };
                    Error::RuntimeError(e19)
                  }
                  n => {
                    debug_assert_eq!(n, 2, "invalid enum discriminant");
                    let e19 = {
                      let l16 = *((ptr3 + 8) as *const i32);
                      let l17 = *((ptr3 + 12) as *const i32);
                      let len18 = l17 as usize;
                      let bytes18 = Vec::from_raw_parts(l16 as *mut _, len18, len18);
                      
                      wit_bindgen::rt::string_lift(bytes18)
                    };
                    Error::InvalidInput(e19)
                  }
                };
                
                v19
              };
              Err(e)
            }
            _ => wit_bindgen::rt::invalid_enum_discriminant(),
          }
        }
      }
      
    }
    
  }
  pub mod spin2_0_0 {
    
    #[allow(clippy::all)]
    pub mod sqlite {
      #[used]
      #[doc(hidden)]
      #[cfg(target_arch = "wasm32")]
      static __FORCE_SECTION_REF: fn() = super::super::super::__link_section;
      /// A handle to an open sqlite instance
      
      #[derive(Debug)]
      #[repr(transparent)]
      pub struct Connection{
        handle: wit_bindgen::rt::Resource<Connection>,
      }
      
      impl Connection{
        #[doc(hidden)]
        pub unsafe fn from_handle(handle: u32) -> Self {
          Self {
            handle: wit_bindgen::rt::Resource::from_handle(handle),
          }
        }
        
        #[doc(hidden)]
        pub fn into_handle(self) -> u32 {
          wit_bindgen::rt::Resource::into_handle(self.handle)
        }
        
        #[doc(hidden)]
        pub fn handle(&self) -> u32 {
          wit_bindgen::rt::Resource::handle(&self.handle)
        }
      }
      
      
      unsafe impl wit_bindgen::rt::WasmResource for Connection{
        #[inline]
        unsafe fn drop(handle: u32) {
          #[cfg(not(target_arch = "wasm32"))]
          unreachable!();
          
          #[cfg(target_arch = "wasm32")]
          {
            #[link(wasm_import_module = "fermyon:spin/sqlite@2.0.0")]
            extern "C" {
              #[link_name = "[resource-drop]connection"]
              fn drop(_: u32);
            }
            
            drop(handle);
          }
        }
      }
      
      /// The set of errors which may be raised by functions in this interface
      #[derive(Clone)]
      pub enum Error{
        /// The host does not recognize the database name requested.
        NoSuchDatabase,
        /// The requesting component does not have access to the specified database (which may or may not exist).
        AccessDenied,
        /// The provided connection is not valid
        InvalidConnection,
        /// The database has reached its capacity
        DatabaseFull,
        /// Some implementation-specific error has occurred (e.g. I/O)
        Io(wit_bindgen::rt::string::String),
      }
      impl ::core::fmt::Debug for Error {
        fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
          match self {
            Error::NoSuchDatabase => {
              f.debug_tuple("Error::NoSuchDatabase").finish()
            }
            Error::AccessDenied => {
              f.debug_tuple("Error::AccessDenied").finish()
            }
            Error::InvalidConnection => {
              f.debug_tuple("Error::InvalidConnection").finish()
            }
            Error::DatabaseFull => {
              f.debug_tuple("Error::DatabaseFull").finish()
            }
            Error::Io(e) => {
              f.debug_tuple("Error::Io").field(e).finish()
            }
          }
        }
      }
      impl ::core::fmt::Display for Error {
        fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
          write!(f, "{:?}", self)
        }
      }
      
      impl std::error::Error for Error {}
      /// A single column's result from a database query
      #[derive(Clone)]
      pub enum Value{
        Integer(i64),
        Real(f64),
        Text(wit_bindgen::rt::string::String),
        Blob(wit_bindgen::rt::vec::Vec::<u8>),
        Null,
      }
      impl ::core::fmt::Debug for Value {
        fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
          match self {
            Value::Integer(e) => {
              f.debug_tuple("Value::Integer").field(e).finish()
            }
            Value::Real(e) => {
              f.debug_tuple("Value::Real").field(e).finish()
            }
            Value::Text(e) => {
              f.debug_tuple("Value::Text").field(e).finish()
            }
            Value::Blob(e) => {
              f.debug_tuple("Value::Blob").field(e).finish()
            }
            Value::Null => {
              f.debug_tuple("Value::Null").finish()
            }
          }
        }
      }
      /// A set of values for each of the columns in a query-result
      #[derive(Clone)]
      pub struct RowResult {
        pub values: wit_bindgen::rt::vec::Vec::<Value>,
      }
      impl ::core::fmt::Debug for RowResult {
        fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
          f.debug_struct("RowResult").field("values", &self.values).finish()
        }
      }
      /// A result of a query
      #[derive(Clone)]
      pub struct QueryResult {
        /// The names of the columns retrieved in the query
        pub columns: wit_bindgen::rt::vec::Vec::<wit_bindgen::rt::string::String>,
        /// the row results each containing the values for all the columns for a given row
        pub rows: wit_bindgen::rt::vec::Vec::<RowResult>,
      }
      impl ::core::fmt::Debug for QueryResult {
        fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
          f.debug_struct("QueryResult").field("columns", &self.columns).field("rows", &self.rows).finish()
        }
      }
      impl Connection {
        #[allow(clippy::all)]
        /// Open a connection to a named database instance.
        /// 
        /// If `database` is "default", the default instance is opened.
        /// 
        /// `error::no-such-database` will be raised if the `name` is not recognized.
        pub fn open(database: &str,) -> Result<Connection,Error>{
          
          #[allow(unused_imports)]
          use wit_bindgen::rt::{alloc, vec::Vec, string::String};
          unsafe {
            
            #[repr(align(4))]
            struct RetArea([u8; 16]);
            let mut ret_area = ::core::mem::MaybeUninit::<RetArea>::uninit();
            let vec0 = database;
            let ptr0 = vec0.as_ptr() as i32;
            let len0 = vec0.len() as i32;
            let ptr1 = ret_area.as_mut_ptr() as i32;
            #[cfg(target_arch = "wasm32")]
            #[link(wasm_import_module = "fermyon:spin/sqlite@2.0.0")]
            extern "C" {
              #[link_name = "[static]connection.open"]
              fn wit_import(_: i32, _: i32, _: i32, );
            }
            
            #[cfg(not(target_arch = "wasm32"))]
            fn wit_import(_: i32, _: i32, _: i32, ){ unreachable!() }
            wit_import(ptr0, len0, ptr1);
            let l2 = i32::from(*((ptr1 + 0) as *const u8));
            match l2 {
              0 => {
                let e = {
                  let l3 = *((ptr1 + 4) as *const i32);
                  
                  Connection::from_handle(l3 as u32)
                };
                Ok(e)
              }
              1 => {
                let e = {
                  let l4 = i32::from(*((ptr1 + 4) as *const u8));
                  let v8 = match l4 {
                    0 => {
                      Error::NoSuchDatabase
                    }
                    1 => {
                      Error::AccessDenied
                    }
                    2 => {
                      Error::InvalidConnection
                    }
                    3 => {
                      Error::DatabaseFull
                    }
                    n => {
                      debug_assert_eq!(n, 4, "invalid enum discriminant");
                      let e8 = {
                        let l5 = *((ptr1 + 8) as *const i32);
                        let l6 = *((ptr1 + 12) as *const i32);
                        let len7 = l6 as usize;
                        let bytes7 = Vec::from_raw_parts(l5 as *mut _, len7, len7);
                        
                        wit_bindgen::rt::string_lift(bytes7)
                      };
                      Error::Io(e8)
                    }
                  };
                  
                  v8
                };
                Err(e)
              }
              _ => wit_bindgen::rt::invalid_enum_discriminant(),
            }
          }
        }
      }
      impl Connection {
        #[allow(clippy::all)]
        /// Execute a statement returning back data if there is any
        pub fn execute(&self,statement: &str,parameters: &[Value],) -> Result<QueryResult,Error>{
          
          #[allow(unused_imports)]
          use wit_bindgen::rt::{alloc, vec::Vec, string::String};
          unsafe {
            
            #[repr(align(4))]
            struct RetArea([u8; 20]);
            let mut ret_area = ::core::mem::MaybeUninit::<RetArea>::uninit();
            let vec0 = statement;
            let ptr0 = vec0.as_ptr() as i32;
            let len0 = vec0.len() as i32;
            let vec3 = parameters;
            let len3 = vec3.len() as i32;
            let layout3 = alloc::Layout::from_size_align_unchecked(vec3.len() * 16, 8);
            let result3 = if layout3.size() != 0
            {
              let ptr = alloc::alloc(layout3);
              if ptr.is_null()
              {
                alloc::handle_alloc_error(layout3);
              }
              ptr
            }else {{
              ::core::ptr::null_mut()
            }};
            for (i, e) in vec3.into_iter().enumerate() {
              let base = result3 as i32 + (i as i32) * 16;
              {
                match e {
                  Value::Integer(e) => {
                    *((base + 0) as *mut u8) = (0i32) as u8;
                    *((base + 8) as *mut i64) = wit_bindgen::rt::as_i64(e);
                  },
                  Value::Real(e) => {
                    *((base + 0) as *mut u8) = (1i32) as u8;
                    *((base + 8) as *mut f64) = wit_bindgen::rt::as_f64(e);
                  },
                  Value::Text(e) => {
                    *((base + 0) as *mut u8) = (2i32) as u8;
                    let vec1 = e;
                    let ptr1 = vec1.as_ptr() as i32;
                    let len1 = vec1.len() as i32;
                    *((base + 12) as *mut i32) = len1;
                    *((base + 8) as *mut i32) = ptr1;
                  },
                  Value::Blob(e) => {
                    *((base + 0) as *mut u8) = (3i32) as u8;
                    let vec2 = e;
                    let ptr2 = vec2.as_ptr() as i32;
                    let len2 = vec2.len() as i32;
                    *((base + 12) as *mut i32) = len2;
                    *((base + 8) as *mut i32) = ptr2;
                  },
                  Value::Null=> {
                    {
                      *((base + 0) as *mut u8) = (4i32) as u8;
                    }
                  }
                }
              }
            }
            let ptr4 = ret_area.as_mut_ptr() as i32;
            #[cfg(target_arch = "wasm32")]
            #[link(wasm_import_module = "fermyon:spin/sqlite@2.0.0")]
            extern "C" {
              #[link_name = "[method]connection.execute"]
              fn wit_import(_: i32, _: i32, _: i32, _: i32, _: i32, _: i32, );
            }
            
            #[cfg(not(target_arch = "wasm32"))]
            fn wit_import(_: i32, _: i32, _: i32, _: i32, _: i32, _: i32, ){ unreachable!() }
            wit_import((self).handle() as i32, ptr0, len0, result3 as i32, len3, ptr4);
            let l5 = i32::from(*((ptr4 + 0) as *const u8));
            if layout3.size() != 0 {
              alloc::dealloc(result3, layout3);
            }
            match l5 {
              0 => {
                let e = {
                  let l6 = *((ptr4 + 4) as *const i32);
                  let l7 = *((ptr4 + 8) as *const i32);
                  let base11 = l6;
                  let len11 = l7;
                  let mut result11 = Vec::with_capacity(len11 as usize);
                  for i in 0..len11 {
                    let base = base11 + i * 8;
                    let e11 = {
                      let l8 = *((base + 0) as *const i32);
                      let l9 = *((base + 4) as *const i32);
                      let len10 = l9 as usize;
                      let bytes10 = Vec::from_raw_parts(l8 as *mut _, len10, len10);
                      
                      wit_bindgen::rt::string_lift(bytes10)
                    };
                    result11.push(e11);
                  }
                  wit_bindgen::rt::dealloc(base11, (len11 as usize) * 8, 4);
                  let l12 = *((ptr4 + 12) as *const i32);
                  let l13 = *((ptr4 + 16) as *const i32);
                  let base27 = l12;
                  let len27 = l13;
                  let mut result27 = Vec::with_capacity(len27 as usize);
                  for i in 0..len27 {
                    let base = base27 + i * 8;
                    let e27 = {
                      let l14 = *((base + 0) as *const i32);
                      let l15 = *((base + 4) as *const i32);
                      let base26 = l14;
                      let len26 = l15;
                      let mut result26 = Vec::with_capacity(len26 as usize);
                      for i in 0..len26 {
                        let base = base26 + i * 16;
                        let e26 = {
                          let l16 = i32::from(*((base + 0) as *const u8));
                          let v25 = match l16 {
                            0 => {
                              let e25 = {
                                let l17 = *((base + 8) as *const i64);
                                
                                l17
                              };
                              Value::Integer(e25)
                            }
                            1 => {
                              let e25 = {
                                let l18 = *((base + 8) as *const f64);
                                
                                l18
                              };
                              Value::Real(e25)
                            }
                            2 => {
                              let e25 = {
                                let l19 = *((base + 8) as *const i32);
                                let l20 = *((base + 12) as *const i32);
                                let len21 = l20 as usize;
                                let bytes21 = Vec::from_raw_parts(l19 as *mut _, len21, len21);
                                
                                wit_bindgen::rt::string_lift(bytes21)
                              };
                              Value::Text(e25)
                            }
                            3 => {
                              let e25 = {
                                let l22 = *((base + 8) as *const i32);
                                let l23 = *((base + 12) as *const i32);
                                let len24 = l23 as usize;
                                
                                Vec::from_raw_parts(l22 as *mut _, len24, len24)
                              };
                              Value::Blob(e25)
                            }
                            n => {
                              debug_assert_eq!(n, 4, "invalid enum discriminant");
                              Value::Null
                            }
                          };
                          
                          v25
                        };
                        result26.push(e26);
                      }
                      wit_bindgen::rt::dealloc(base26, (len26 as usize) * 16, 8);
                      
                      RowResult{
                        values: result26,
                      }
                    };
                    result27.push(e27);
                  }
                  wit_bindgen::rt::dealloc(base27, (len27 as usize) * 8, 4);
                  
                  QueryResult{
                    columns: result11,
                    rows: result27,
                  }
                };
                Ok(e)
              }
              1 => {
                let e = {
                  let l28 = i32::from(*((ptr4 + 4) as *const u8));
                  let v32 = match l28 {
                    0 => {
                      Error::NoSuchDatabase
                    }
                    1 => {
                      Error::AccessDenied
                    }
                    2 => {
                      Error::InvalidConnection
                    }
                    3 => {
                      Error::DatabaseFull
                    }
                    n => {
                      debug_assert_eq!(n, 4, "invalid enum discriminant");
                      let e32 = {
                        let l29 = *((ptr4 + 8) as *const i32);
                        let l30 = *((ptr4 + 12) as *const i32);
                        let len31 = l30 as usize;
                        let bytes31 = Vec::from_raw_parts(l29 as *mut _, len31, len31);
                        
                        wit_bindgen::rt::string_lift(bytes31)
                      };
                      Error::Io(e32)
                    }
                  };
                  
                  v32
                };
                Err(e)
              }
              _ => wit_bindgen::rt::invalid_enum_discriminant(),
            }
          }
        }
      }
      
    }
    
    
    #[allow(clippy::all)]
    pub mod key_value {
      #[used]
      #[doc(hidden)]
      #[cfg(target_arch = "wasm32")]
      static __FORCE_SECTION_REF: fn() = super::super::super::__link_section;
      /// An open key-value store
      
      #[derive(Debug)]
      #[repr(transparent)]
      pub struct Store{
        handle: wit_bindgen::rt::Resource<Store>,
      }
      
      impl Store{
        #[doc(hidden)]
        pub unsafe fn from_handle(handle: u32) -> Self {
          Self {
            handle: wit_bindgen::rt::Resource::from_handle(handle),
          }
        }
        
        #[doc(hidden)]
        pub fn into_handle(self) -> u32 {
          wit_bindgen::rt::Resource::into_handle(self.handle)
        }
        
        #[doc(hidden)]
        pub fn handle(&self) -> u32 {
          wit_bindgen::rt::Resource::handle(&self.handle)
        }
      }
      
      
      unsafe impl wit_bindgen::rt::WasmResource for Store{
        #[inline]
        unsafe fn drop(handle: u32) {
          #[cfg(not(target_arch = "wasm32"))]
          unreachable!();
          
          #[cfg(target_arch = "wasm32")]
          {
            #[link(wasm_import_module = "fermyon:spin/key-value@2.0.0")]
            extern "C" {
              #[link_name = "[resource-drop]store"]
              fn drop(_: u32);
            }
            
            drop(handle);
          }
        }
      }
      
      /// The set of errors which may be raised by functions in this interface
      #[derive(Clone)]
      pub enum Error{
        /// Too many stores have been opened simultaneously. Closing one or more
        /// stores prior to retrying may address this.
        StoreTableFull,
        /// The host does not recognize the store name requested.  Defining and
        /// configuring a store with that name in a runtime configuration file
        /// may address this.
        NoSuchStore,
        /// The requesting component does not have access to the specified store
        /// (which may or may not exist).
        AccessDenied,
        /// The store handle provided is not recognized, i.e. it was either never
        /// opened or has been closed.
        InvalidStore,
        /// No key-value tuple exists for the specified key in the specified
        /// store.
        NoSuchKey,
        /// Some implementation-specific error has occurred (e.g. I/O)
        Io(wit_bindgen::rt::string::String),
      }
      impl ::core::fmt::Debug for Error {
        fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
          match self {
            Error::StoreTableFull => {
              f.debug_tuple("Error::StoreTableFull").finish()
            }
            Error::NoSuchStore => {
              f.debug_tuple("Error::NoSuchStore").finish()
            }
            Error::AccessDenied => {
              f.debug_tuple("Error::AccessDenied").finish()
            }
            Error::InvalidStore => {
              f.debug_tuple("Error::InvalidStore").finish()
            }
            Error::NoSuchKey => {
              f.debug_tuple("Error::NoSuchKey").finish()
            }
            Error::Io(e) => {
              f.debug_tuple("Error::Io").field(e).finish()
            }
          }
        }
      }
      impl ::core::fmt::Display for Error {
        fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
          write!(f, "{:?}", self)
        }
      }
      
      impl std::error::Error for Error {}
      impl Store {
        #[allow(clippy::all)]
        /// Open the store with the specified name.
        /// 
        /// If `name` is "default", the default store is opened.  Otherwise,
        /// `name` must refer to a store defined and configured in a runtime
        /// configuration file supplied with the application.
        /// 
        /// `error::no-such-store` will be raised if the `name` is not recognized.
        pub fn open(name: &str,) -> Result<Store,Error>{
          
          #[allow(unused_imports)]
          use wit_bindgen::rt::{alloc, vec::Vec, string::String};
          unsafe {
            
            #[repr(align(4))]
            struct RetArea([u8; 16]);
            let mut ret_area = ::core::mem::MaybeUninit::<RetArea>::uninit();
            let vec0 = name;
            let ptr0 = vec0.as_ptr() as i32;
            let len0 = vec0.len() as i32;
            let ptr1 = ret_area.as_mut_ptr() as i32;
            #[cfg(target_arch = "wasm32")]
            #[link(wasm_import_module = "fermyon:spin/key-value@2.0.0")]
            extern "C" {
              #[link_name = "[static]store.open"]
              fn wit_import(_: i32, _: i32, _: i32, );
            }
            
            #[cfg(not(target_arch = "wasm32"))]
            fn wit_import(_: i32, _: i32, _: i32, ){ unreachable!() }
            wit_import(ptr0, len0, ptr1);
            let l2 = i32::from(*((ptr1 + 0) as *const u8));
            match l2 {
              0 => {
                let e = {
                  let l3 = *((ptr1 + 4) as *const i32);
                  
                  Store::from_handle(l3 as u32)
                };
                Ok(e)
              }
              1 => {
                let e = {
                  let l4 = i32::from(*((ptr1 + 4) as *const u8));
                  let v8 = match l4 {
                    0 => {
                      Error::StoreTableFull
                    }
                    1 => {
                      Error::NoSuchStore
                    }
                    2 => {
                      Error::AccessDenied
                    }
                    3 => {
                      Error::InvalidStore
                    }
                    4 => {
                      Error::NoSuchKey
                    }
                    n => {
                      debug_assert_eq!(n, 5, "invalid enum discriminant");
                      let e8 = {
                        let l5 = *((ptr1 + 8) as *const i32);
                        let l6 = *((ptr1 + 12) as *const i32);
                        let len7 = l6 as usize;
                        let bytes7 = Vec::from_raw_parts(l5 as *mut _, len7, len7);
                        
                        wit_bindgen::rt::string_lift(bytes7)
                      };
                      Error::Io(e8)
                    }
                  };
                  
                  v8
                };
                Err(e)
              }
              _ => wit_bindgen::rt::invalid_enum_discriminant(),
            }
          }
        }
      }
      impl Store {
        #[allow(clippy::all)]
        /// Get the value associated with the specified `key` from the specified
        /// `store`.
        /// 
        /// `error::invalid-store` will be raised if `store` is not a valid handle
        /// to an open store, and `error::no-such-key` will be raised if there is no
        /// tuple for `key` in `store`.
        pub fn get(&self,key: &str,) -> Result<wit_bindgen::rt::vec::Vec::<u8>,Error>{
          
          #[allow(unused_imports)]
          use wit_bindgen::rt::{alloc, vec::Vec, string::String};
          unsafe {
            
            #[repr(align(4))]
            struct RetArea([u8; 16]);
            let mut ret_area = ::core::mem::MaybeUninit::<RetArea>::uninit();
            let vec0 = key;
            let ptr0 = vec0.as_ptr() as i32;
            let len0 = vec0.len() as i32;
            let ptr1 = ret_area.as_mut_ptr() as i32;
            #[cfg(target_arch = "wasm32")]
            #[link(wasm_import_module = "fermyon:spin/key-value@2.0.0")]
            extern "C" {
              #[link_name = "[method]store.get"]
              fn wit_import(_: i32, _: i32, _: i32, _: i32, );
            }
            
            #[cfg(not(target_arch = "wasm32"))]
            fn wit_import(_: i32, _: i32, _: i32, _: i32, ){ unreachable!() }
            wit_import((self).handle() as i32, ptr0, len0, ptr1);
            let l2 = i32::from(*((ptr1 + 0) as *const u8));
            match l2 {
              0 => {
                let e = {
                  let l3 = *((ptr1 + 4) as *const i32);
                  let l4 = *((ptr1 + 8) as *const i32);
                  let len5 = l4 as usize;
                  
                  Vec::from_raw_parts(l3 as *mut _, len5, len5)
                };
                Ok(e)
              }
              1 => {
                let e = {
                  let l6 = i32::from(*((ptr1 + 4) as *const u8));
                  let v10 = match l6 {
                    0 => {
                      Error::StoreTableFull
                    }
                    1 => {
                      Error::NoSuchStore
                    }
                    2 => {
                      Error::AccessDenied
                    }
                    3 => {
                      Error::InvalidStore
                    }
                    4 => {
                      Error::NoSuchKey
                    }
                    n => {
                      debug_assert_eq!(n, 5, "invalid enum discriminant");
                      let e10 = {
                        let l7 = *((ptr1 + 8) as *const i32);
                        let l8 = *((ptr1 + 12) as *const i32);
                        let len9 = l8 as usize;
                        let bytes9 = Vec::from_raw_parts(l7 as *mut _, len9, len9);
                        
                        wit_bindgen::rt::string_lift(bytes9)
                      };
                      Error::Io(e10)
                    }
                  };
                  
                  v10
                };
                Err(e)
              }
              _ => wit_bindgen::rt::invalid_enum_discriminant(),
            }
          }
        }
      }
      impl Store {
        #[allow(clippy::all)]
        /// Set the `value` associated with the specified `key` in the specified
        /// `store`, overwriting any existing value.
        /// 
        /// `error::invalid-store` will be raised if `store` is not a valid handle
        /// to an open store.
        pub fn set(&self,key: &str,value: &[u8],) -> Result<(),Error>{
          
          #[allow(unused_imports)]
          use wit_bindgen::rt::{alloc, vec::Vec, string::String};
          unsafe {
            
            #[repr(align(4))]
            struct RetArea([u8; 16]);
            let mut ret_area = ::core::mem::MaybeUninit::<RetArea>::uninit();
            let vec0 = key;
            let ptr0 = vec0.as_ptr() as i32;
            let len0 = vec0.len() as i32;
            let vec1 = value;
            let ptr1 = vec1.as_ptr() as i32;
            let len1 = vec1.len() as i32;
            let ptr2 = ret_area.as_mut_ptr() as i32;
            #[cfg(target_arch = "wasm32")]
            #[link(wasm_import_module = "fermyon:spin/key-value@2.0.0")]
            extern "C" {
              #[link_name = "[method]store.set"]
              fn wit_import(_: i32, _: i32, _: i32, _: i32, _: i32, _: i32, );
            }
            
            #[cfg(not(target_arch = "wasm32"))]
            fn wit_import(_: i32, _: i32, _: i32, _: i32, _: i32, _: i32, ){ unreachable!() }
            wit_import((self).handle() as i32, ptr0, len0, ptr1, len1, ptr2);
            let l3 = i32::from(*((ptr2 + 0) as *const u8));
            match l3 {
              0 => {
                let e = ();
                Ok(e)
              }
              1 => {
                let e = {
                  let l4 = i32::from(*((ptr2 + 4) as *const u8));
                  let v8 = match l4 {
                    0 => {
                      Error::StoreTableFull
                    }
                    1 => {
                      Error::NoSuchStore
                    }
                    2 => {
                      Error::AccessDenied
                    }
                    3 => {
                      Error::InvalidStore
                    }
                    4 => {
                      Error::NoSuchKey
                    }
                    n => {
                      debug_assert_eq!(n, 5, "invalid enum discriminant");
                      let e8 = {
                        let l5 = *((ptr2 + 8) as *const i32);
                        let l6 = *((ptr2 + 12) as *const i32);
                        let len7 = l6 as usize;
                        let bytes7 = Vec::from_raw_parts(l5 as *mut _, len7, len7);
                        
                        wit_bindgen::rt::string_lift(bytes7)
                      };
                      Error::Io(e8)
                    }
                  };
                  
                  v8
                };
                Err(e)
              }
              _ => wit_bindgen::rt::invalid_enum_discriminant(),
            }
          }
        }
      }
      impl Store {
        #[allow(clippy::all)]
        /// Delete the tuple with the specified `key` from the specified `store`.
        /// 
        /// `error::invalid-store` will be raised if `store` is not a valid handle
        /// to an open store.  No error is raised if a tuple did not previously
        /// exist for `key`.
        pub fn delete(&self,key: &str,) -> Result<(),Error>{
          
          #[allow(unused_imports)]
          use wit_bindgen::rt::{alloc, vec::Vec, string::String};
          unsafe {
            
            #[repr(align(4))]
            struct RetArea([u8; 16]);
            let mut ret_area = ::core::mem::MaybeUninit::<RetArea>::uninit();
            let vec0 = key;
            let ptr0 = vec0.as_ptr() as i32;
            let len0 = vec0.len() as i32;
            let ptr1 = ret_area.as_mut_ptr() as i32;
            #[cfg(target_arch = "wasm32")]
            #[link(wasm_import_module = "fermyon:spin/key-value@2.0.0")]
            extern "C" {
              #[link_name = "[method]store.delete"]
              fn wit_import(_: i32, _: i32, _: i32, _: i32, );
            }
            
            #[cfg(not(target_arch = "wasm32"))]
            fn wit_import(_: i32, _: i32, _: i32, _: i32, ){ unreachable!() }
            wit_import((self).handle() as i32, ptr0, len0, ptr1);
            let l2 = i32::from(*((ptr1 + 0) as *const u8));
            match l2 {
              0 => {
                let e = ();
                Ok(e)
              }
              1 => {
                let e = {
                  let l3 = i32::from(*((ptr1 + 4) as *const u8));
                  let v7 = match l3 {
                    0 => {
                      Error::StoreTableFull
                    }
                    1 => {
                      Error::NoSuchStore
                    }
                    2 => {
                      Error::AccessDenied
                    }
                    3 => {
                      Error::InvalidStore
                    }
                    4 => {
                      Error::NoSuchKey
                    }
                    n => {
                      debug_assert_eq!(n, 5, "invalid enum discriminant");
                      let e7 = {
                        let l4 = *((ptr1 + 8) as *const i32);
                        let l5 = *((ptr1 + 12) as *const i32);
                        let len6 = l5 as usize;
                        let bytes6 = Vec::from_raw_parts(l4 as *mut _, len6, len6);
                        
                        wit_bindgen::rt::string_lift(bytes6)
                      };
                      Error::Io(e7)
                    }
                  };
                  
                  v7
                };
                Err(e)
              }
              _ => wit_bindgen::rt::invalid_enum_discriminant(),
            }
          }
        }
      }
      impl Store {
        #[allow(clippy::all)]
        /// Return whether a tuple exists for the specified `key` in the specified
        /// `store`.
        /// 
        /// `error::invalid-store` will be raised if `store` is not a valid handle
        /// to an open store.
        pub fn exists(&self,key: &str,) -> Result<bool,Error>{
          
          #[allow(unused_imports)]
          use wit_bindgen::rt::{alloc, vec::Vec, string::String};
          unsafe {
            
            #[repr(align(4))]
            struct RetArea([u8; 16]);
            let mut ret_area = ::core::mem::MaybeUninit::<RetArea>::uninit();
            let vec0 = key;
            let ptr0 = vec0.as_ptr() as i32;
            let len0 = vec0.len() as i32;
            let ptr1 = ret_area.as_mut_ptr() as i32;
            #[cfg(target_arch = "wasm32")]
            #[link(wasm_import_module = "fermyon:spin/key-value@2.0.0")]
            extern "C" {
              #[link_name = "[method]store.exists"]
              fn wit_import(_: i32, _: i32, _: i32, _: i32, );
            }
            
            #[cfg(not(target_arch = "wasm32"))]
            fn wit_import(_: i32, _: i32, _: i32, _: i32, ){ unreachable!() }
            wit_import((self).handle() as i32, ptr0, len0, ptr1);
            let l2 = i32::from(*((ptr1 + 0) as *const u8));
            match l2 {
              0 => {
                let e = {
                  let l3 = i32::from(*((ptr1 + 4) as *const u8));
                  
                  wit_bindgen::rt::bool_lift(l3 as u8)
                };
                Ok(e)
              }
              1 => {
                let e = {
                  let l4 = i32::from(*((ptr1 + 4) as *const u8));
                  let v8 = match l4 {
                    0 => {
                      Error::StoreTableFull
                    }
                    1 => {
                      Error::NoSuchStore
                    }
                    2 => {
                      Error::AccessDenied
                    }
                    3 => {
                      Error::InvalidStore
                    }
                    4 => {
                      Error::NoSuchKey
                    }
                    n => {
                      debug_assert_eq!(n, 5, "invalid enum discriminant");
                      let e8 = {
                        let l5 = *((ptr1 + 8) as *const i32);
                        let l6 = *((ptr1 + 12) as *const i32);
                        let len7 = l6 as usize;
                        let bytes7 = Vec::from_raw_parts(l5 as *mut _, len7, len7);
                        
                        wit_bindgen::rt::string_lift(bytes7)
                      };
                      Error::Io(e8)
                    }
                  };
                  
                  v8
                };
                Err(e)
              }
              _ => wit_bindgen::rt::invalid_enum_discriminant(),
            }
          }
        }
      }
      impl Store {
        #[allow(clippy::all)]
        /// Return a list of all the keys in the specified `store`.
        /// 
        /// `error::invalid-store` will be raised if `store` is not a valid handle
        /// to an open store.
        pub fn get_keys(&self,) -> Result<wit_bindgen::rt::vec::Vec::<wit_bindgen::rt::string::String>,Error>{
          
          #[allow(unused_imports)]
          use wit_bindgen::rt::{alloc, vec::Vec, string::String};
          unsafe {
            
            #[repr(align(4))]
            struct RetArea([u8; 16]);
            let mut ret_area = ::core::mem::MaybeUninit::<RetArea>::uninit();
            let ptr0 = ret_area.as_mut_ptr() as i32;
            #[cfg(target_arch = "wasm32")]
            #[link(wasm_import_module = "fermyon:spin/key-value@2.0.0")]
            extern "C" {
              #[link_name = "[method]store.get-keys"]
              fn wit_import(_: i32, _: i32, );
            }
            
            #[cfg(not(target_arch = "wasm32"))]
            fn wit_import(_: i32, _: i32, ){ unreachable!() }
            wit_import((self).handle() as i32, ptr0);
            let l1 = i32::from(*((ptr0 + 0) as *const u8));
            match l1 {
              0 => {
                let e = {
                  let l2 = *((ptr0 + 4) as *const i32);
                  let l3 = *((ptr0 + 8) as *const i32);
                  let base7 = l2;
                  let len7 = l3;
                  let mut result7 = Vec::with_capacity(len7 as usize);
                  for i in 0..len7 {
                    let base = base7 + i * 8;
                    let e7 = {
                      let l4 = *((base + 0) as *const i32);
                      let l5 = *((base + 4) as *const i32);
                      let len6 = l5 as usize;
                      let bytes6 = Vec::from_raw_parts(l4 as *mut _, len6, len6);
                      
                      wit_bindgen::rt::string_lift(bytes6)
                    };
                    result7.push(e7);
                  }
                  wit_bindgen::rt::dealloc(base7, (len7 as usize) * 8, 4);
                  
                  result7
                };
                Ok(e)
              }
              1 => {
                let e = {
                  let l8 = i32::from(*((ptr0 + 4) as *const u8));
                  let v12 = match l8 {
                    0 => {
                      Error::StoreTableFull
                    }
                    1 => {
                      Error::NoSuchStore
                    }
                    2 => {
                      Error::AccessDenied
                    }
                    3 => {
                      Error::InvalidStore
                    }
                    4 => {
                      Error::NoSuchKey
                    }
                    n => {
                      debug_assert_eq!(n, 5, "invalid enum discriminant");
                      let e12 = {
                        let l9 = *((ptr0 + 8) as *const i32);
                        let l10 = *((ptr0 + 12) as *const i32);
                        let len11 = l10 as usize;
                        let bytes11 = Vec::from_raw_parts(l9 as *mut _, len11, len11);
                        
                        wit_bindgen::rt::string_lift(bytes11)
                      };
                      Error::Io(e12)
                    }
                  };
                  
                  v12
                };
                Err(e)
              }
              _ => wit_bindgen::rt::invalid_enum_discriminant(),
            }
          }
        }
      }
      
    }
    
  }
}
pub mod wasi {
  pub mod logging {
    
    #[allow(clippy::all)]
    pub mod logging {
      #[used]
      #[doc(hidden)]
      #[cfg(target_arch = "wasm32")]
      static __FORCE_SECTION_REF: fn() = super::super::super::__link_section;
      /// A log level, describing a kind of message.
      #[repr(u8)]
      #[derive(Clone, Copy, Eq, PartialEq)]
      pub enum Level {
        /// Describes messages about the values of variables and the flow of
        /// control within a program.
        Trace,
        /// Describes messages likely to be of interest to someone debugging a
        /// program.
        Debug,
        /// Describes messages likely to be of interest to someone monitoring a
        /// program.
        Info,
        /// Describes messages indicating hazardous situations.
        Warn,
        /// Describes messages indicating serious errors.
        Error,
        /// Describes messages indicating fatal errors.
        Critical,
      }
      impl ::core::fmt::Debug for Level {
        fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
          match self {
            Level::Trace => {
              f.debug_tuple("Level::Trace").finish()
            }
            Level::Debug => {
              f.debug_tuple("Level::Debug").finish()
            }
            Level::Info => {
              f.debug_tuple("Level::Info").finish()
            }
            Level::Warn => {
              f.debug_tuple("Level::Warn").finish()
            }
            Level::Error => {
              f.debug_tuple("Level::Error").finish()
            }
            Level::Critical => {
              f.debug_tuple("Level::Critical").finish()
            }
          }
        }
      }
      
      impl Level{
        pub(crate) unsafe fn _lift(val: u8) -> Level{
          if !cfg!(debug_assertions) {
            return ::core::mem::transmute(val);
          }
          
          match val {
            0 => Level::Trace,
            1 => Level::Debug,
            2 => Level::Info,
            3 => Level::Warn,
            4 => Level::Error,
            5 => Level::Critical,
            
            _ => panic!("invalid enum discriminant"),
          }
        }
      }
      
      #[allow(clippy::all)]
      /// Emit a log message.
      /// 
      /// A log message has a `level` describing what kind of message is being
      /// sent, a context, which is an uninterpreted string meant to help
      /// consumers group similar messages, and a string containing the message
      /// text.
      pub fn log(level: Level,context: &str,message: &str,){
        
        #[allow(unused_imports)]
        use wit_bindgen::rt::{alloc, vec::Vec, string::String};
        unsafe {
          let vec0 = context;
          let ptr0 = vec0.as_ptr() as i32;
          let len0 = vec0.len() as i32;
          let vec1 = message;
          let ptr1 = vec1.as_ptr() as i32;
          let len1 = vec1.len() as i32;
          
          #[cfg(target_arch = "wasm32")]
          #[link(wasm_import_module = "wasi:logging/logging")]
          extern "C" {
            #[link_name = "log"]
            fn wit_import(_: i32, _: i32, _: i32, _: i32, _: i32, );
          }
          
          #[cfg(not(target_arch = "wasm32"))]
          fn wit_import(_: i32, _: i32, _: i32, _: i32, _: i32, ){ unreachable!() }
          wit_import(level.clone() as i32, ptr0, len0, ptr1, len1);
        }
      }
      
    }
    
  }
}
pub mod exports {
  pub mod fermyon {
    pub mod spin {
      
      #[allow(clippy::all)]
      pub mod inbound_http {
        #[used]
        #[doc(hidden)]
        #[cfg(target_arch = "wasm32")]
        static __FORCE_SECTION_REF: fn() = super::super::super::super::__link_section;
        pub type Request = super::super::super::super::fermyon::spin::http_types::Request;
        pub type Response = super::super::super::super::fermyon::spin::http_types::Response;
        const _: () = {
          
          #[doc(hidden)]
          #[export_name = "fermyon:spin/inbound-http#handle-request"]
          #[allow(non_snake_case)]
          unsafe extern "C" fn __export_handle_request(arg0: i32,arg1: i32,arg2: i32,arg3: i32,arg4: i32,arg5: i32,arg6: i32,arg7: i32,arg8: i32,arg9: i32,) -> i32 {
            #[allow(unused_imports)]
            use wit_bindgen::rt::{alloc, vec::Vec, string::String};
            
            // Before executing any other code, use this function to run all static
            // constructors, if they have not yet been run. This is a hack required
            // to work around wasi-libc ctors calling import functions to initialize
            // the environment.
            //
            // This functionality will be removed once rust 1.69.0 is stable, at which
            // point wasi-libc will no longer have this behavior.
            //
            // See
            // https://github.com/bytecodealliance/preview2-prototyping/issues/99
            // for more details.
            #[cfg(target_arch="wasm32")]
            wit_bindgen::rt::run_ctors_once();
            
            let len0 = arg2 as usize;
            let bytes0 = Vec::from_raw_parts(arg1 as *mut _, len0, len0);
            let base7 = arg3;
            let len7 = arg4;
            let mut result7 = Vec::with_capacity(len7 as usize);
            for i in 0..len7 {
              let base = base7 + i * 16;
              let e7 = {
                let l1 = *((base + 0) as *const i32);
                let l2 = *((base + 4) as *const i32);
                let len3 = l2 as usize;
                let bytes3 = Vec::from_raw_parts(l1 as *mut _, len3, len3);
                let l4 = *((base + 8) as *const i32);
                let l5 = *((base + 12) as *const i32);
                let len6 = l5 as usize;
                let bytes6 = Vec::from_raw_parts(l4 as *mut _, len6, len6);
                
                (wit_bindgen::rt::string_lift(bytes3), wit_bindgen::rt::string_lift(bytes6))
              };
              result7.push(e7);
            }
            wit_bindgen::rt::dealloc(base7, (len7 as usize) * 16, 4);
            let base14 = arg5;
            let len14 = arg6;
            let mut result14 = Vec::with_capacity(len14 as usize);
            for i in 0..len14 {
              let base = base14 + i * 16;
              let e14 = {
                let l8 = *((base + 0) as *const i32);
                let l9 = *((base + 4) as *const i32);
                let len10 = l9 as usize;
                let bytes10 = Vec::from_raw_parts(l8 as *mut _, len10, len10);
                let l11 = *((base + 8) as *const i32);
                let l12 = *((base + 12) as *const i32);
                let len13 = l12 as usize;
                let bytes13 = Vec::from_raw_parts(l11 as *mut _, len13, len13);
                
                (wit_bindgen::rt::string_lift(bytes10), wit_bindgen::rt::string_lift(bytes13))
              };
              result14.push(e14);
            }
            wit_bindgen::rt::dealloc(base14, (len14 as usize) * 16, 4);
            let result16 = <_GuestImpl as Guest>::handle_request(super::super::super::super::fermyon::spin::http_types::Request{
              method: super::super::super::super::fermyon::spin::http_types::Method::_lift(arg0 as u8),
              uri: wit_bindgen::rt::string_lift(bytes0),
              headers: result7,
              params: result14,
              body: match arg7 {
                0 => None,
                1 => {
                  let e = {
                    let len15 = arg9 as usize;
                    
                    Vec::from_raw_parts(arg8 as *mut _, len15, len15)
                  };
                  Some(e)
                }
                _ => wit_bindgen::rt::invalid_enum_discriminant(),
              },
            });
            let ptr17 = _RET_AREA.0.as_mut_ptr() as i32;
            let super::super::super::super::fermyon::spin::http_types::Response{ status:status18, headers:headers18, body:body18, } = result16;
            *((ptr17 + 0) as *mut u16) = (wit_bindgen::rt::as_i32(status18)) as u16;
            match headers18 {
              Some(e) => {
                *((ptr17 + 4) as *mut u8) = (1i32) as u8;
                let vec22 = e;
                let len22 = vec22.len() as i32;
                let layout22 = alloc::Layout::from_size_align_unchecked(vec22.len() * 16, 4);
                let result22 = if layout22.size() != 0
                {
                  let ptr = alloc::alloc(layout22);
                  if ptr.is_null()
                  {
                    alloc::handle_alloc_error(layout22);
                  }
                  ptr
                }else {{
                  ::core::ptr::null_mut()
                }};
                for (i, e) in vec22.into_iter().enumerate() {
                  let base = result22 as i32 + (i as i32) * 16;
                  {
                    let (t19_0, t19_1, ) = e;
                    let vec20 = (t19_0.into_bytes()).into_boxed_slice();
                    let ptr20 = vec20.as_ptr() as i32;
                    let len20 = vec20.len() as i32;
                    ::core::mem::forget(vec20);
                    *((base + 4) as *mut i32) = len20;
                    *((base + 0) as *mut i32) = ptr20;
                    let vec21 = (t19_1.into_bytes()).into_boxed_slice();
                    let ptr21 = vec21.as_ptr() as i32;
                    let len21 = vec21.len() as i32;
                    ::core::mem::forget(vec21);
                    *((base + 12) as *mut i32) = len21;
                    *((base + 8) as *mut i32) = ptr21;
                  }
                }
                *((ptr17 + 12) as *mut i32) = len22;
                *((ptr17 + 8) as *mut i32) = result22 as i32;
              },
              None => {
                {
                  *((ptr17 + 4) as *mut u8) = (0i32) as u8;
                }
              },
            };match body18 {
              Some(e) => {
                *((ptr17 + 16) as *mut u8) = (1i32) as u8;
                let vec23 = (e).into_boxed_slice();
                let ptr23 = vec23.as_ptr() as i32;
                let len23 = vec23.len() as i32;
                ::core::mem::forget(vec23);
                *((ptr17 + 24) as *mut i32) = len23;
                *((ptr17 + 20) as *mut i32) = ptr23;
              },
              None => {
                {
                  *((ptr17 + 16) as *mut u8) = (0i32) as u8;
                }
              },
            };ptr17
          }
          
          const _: () = {
            #[doc(hidden)]
            #[export_name = "cabi_post_fermyon:spin/inbound-http#handle-request"]
            #[allow(non_snake_case)]
            unsafe extern "C" fn __post_return_handle_request(arg0: i32,) {
              let l0 = i32::from(*((arg0 + 4) as *const u8));
              match l0 {
                0 => (),
                _ => {
                  let l5 = *((arg0 + 8) as *const i32);
                  let l6 = *((arg0 + 12) as *const i32);
                  let base7 = l5;
                  let len7 = l6;
                  for i in 0..len7 {
                    let base = base7 + i *16;
                    {
                      let l1 = *((base + 0) as *const i32);
                      let l2 = *((base + 4) as *const i32);
                      wit_bindgen::rt::dealloc(l1, (l2) as usize, 1);
                      let l3 = *((base + 8) as *const i32);
                      let l4 = *((base + 12) as *const i32);
                      wit_bindgen::rt::dealloc(l3, (l4) as usize, 1);
                    }
                  }
                  wit_bindgen::rt::dealloc(base7, (len7 as usize) * 16, 4);
                },
              }
              let l8 = i32::from(*((arg0 + 16) as *const u8));
              match l8 {
                0 => (),
                _ => {
                  let l9 = *((arg0 + 20) as *const i32);
                  let l10 = *((arg0 + 24) as *const i32);
                  let base11 = l9;
                  let len11 = l10;
                  wit_bindgen::rt::dealloc(base11, (len11 as usize) * 1, 1);
                },
              }
            }
          };
        };
        use super::super::super::super::Stub as _GuestImpl;
        pub trait Guest {
          fn handle_request(req: Request,) -> Response;
        }
        
        #[allow(unused_imports)]
        use wit_bindgen::rt::{alloc, vec::Vec, string::String};
        
        #[repr(align(4))]
        struct _RetArea([u8; 28]);
        static mut _RET_AREA: _RetArea = _RetArea([0; 28]);
        
      }
      
    }
  }
}

#[cfg(target_arch = "wasm32")]
#[link_section = "component-type:http-trigger"]
#[doc(hidden)]
pub static __WIT_BINDGEN_COMPONENT_TYPE: [u8; 21779] = [3, 0, 12, 104, 116, 116, 112, 45, 116, 114, 105, 103, 103, 101, 114, 0, 97, 115, 109, 13, 0, 1, 0, 7, 141, 141, 1, 1, 65, 12, 1, 66, 24, 4, 0, 5, 115, 116, 111, 114, 101, 3, 1, 1, 113, 6, 16, 115, 116, 111, 114, 101, 45, 116, 97, 98, 108, 101, 45, 102, 117, 108, 108, 0, 0, 13, 110, 111, 45, 115, 117, 99, 104, 45, 115, 116, 111, 114, 101, 0, 0, 13, 97, 99, 99, 101, 115, 115, 45, 100, 101, 110, 105, 101, 100, 0, 0, 13, 105, 110, 118, 97, 108, 105, 100, 45, 115, 116, 111, 114, 101, 0, 0, 11, 110, 111, 45, 115, 117, 99, 104, 45, 107, 101, 121, 0, 0, 2, 105, 111, 1, 115, 0, 4, 0, 5, 101, 114, 114, 111, 114, 3, 0, 1, 1, 105, 0, 1, 106, 1, 3, 1, 2, 1, 64, 1, 4, 110, 97, 109, 101, 115, 0, 4, 4, 0, 18, 91, 115, 116, 97, 116, 105, 99, 93, 115, 116, 111, 114, 101, 46, 111, 112, 101, 110, 1, 5, 1, 104, 0, 1, 112, 125, 1, 106, 1, 7, 1, 2, 1, 64, 2, 4, 115, 101, 108, 102, 6, 3, 107, 101, 121, 115, 0, 8, 4, 0, 17, 91, 109, 101, 116, 104, 111, 100, 93, 115, 116, 111, 114, 101, 46, 103, 101, 116, 1, 9, 1, 106, 0, 1, 2, 1, 64, 3, 4, 115, 101, 108, 102, 6, 3, 107, 101, 121, 115, 5, 118, 97, 108, 117, 101, 7, 0, 10, 4, 0, 17, 91, 109, 101, 116, 104, 111, 100, 93, 115, 116, 111, 114, 101, 46, 115, 101, 116, 1, 11, 1, 64, 2, 4, 115, 101, 108, 102, 6, 3, 107, 101, 121, 115, 0, 10, 4, 0, 20, 91, 109, 101, 116, 104, 111, 100, 93, 115, 116, 111, 114, 101, 46, 100, 101, 108, 101, 116, 101, 1, 12, 1, 106, 1, 127, 1, 2, 1, 64, 2, 4, 115, 101, 108, 102, 6, 3, 107, 101, 121, 115, 0, 13, 4, 0, 20, 91, 109, 101, 116, 104, 111, 100, 93, 115, 116, 111, 114, 101, 46, 101, 120, 105, 115, 116, 115, 1, 14, 1, 112, 115, 1, 106, 1, 15, 1, 2, 1, 64, 1, 4, 115, 101, 108, 102, 6, 0, 16, 4, 0, 22, 91, 109, 101, 116, 104, 111, 100, 93, 115, 116, 111, 114, 101, 46, 103, 101, 116, 45, 107, 101, 121, 115, 1, 17, 4, 1, 28, 102, 101, 114, 109, 121, 111, 110, 58, 115, 112, 105, 110, 47, 107, 101, 121, 45, 118, 97, 108, 117, 101, 64, 50, 46, 48, 46, 48, 5, 0, 1, 66, 21, 4, 0, 10, 99, 111, 110, 110, 101, 99, 116, 105, 111, 110, 3, 1, 1, 113, 5, 16, 110, 111, 45, 115, 117, 99, 104, 45, 100, 97, 116, 97, 98, 97, 115, 101, 0, 0, 13, 97, 99, 99, 101, 115, 115, 45, 100, 101, 110, 105, 101, 100, 0, 0, 18, 105, 110, 118, 97, 108, 105, 100, 45, 99, 111, 110, 110, 101, 99, 116, 105, 111, 110, 0, 0, 13, 100, 97, 116, 97, 98, 97, 115, 101, 45, 102, 117, 108, 108, 0, 0, 2, 105, 111, 1, 115, 0, 4, 0, 5, 101, 114, 114, 111, 114, 3, 0, 1, 1, 112, 125, 1, 113, 5, 7, 105, 110, 116, 101, 103, 101, 114, 1, 120, 0, 4, 114, 101, 97, 108, 1, 117, 0, 4, 116, 101, 120, 116, 1, 115, 0, 4, 98, 108, 111, 98, 1, 3, 0, 4, 110, 117, 108, 108, 0, 0, 4, 0, 5, 118, 97, 108, 117, 101, 3, 0, 4, 1, 112, 5, 1, 114, 1, 6, 118, 97, 108, 117, 101, 115, 6, 4, 0, 10, 114, 111, 119, 45, 114, 101, 115, 117, 108, 116, 3, 0, 7, 1, 112, 115, 1, 112, 8, 1, 114, 2, 7, 99, 111, 108, 117, 109, 110, 115, 9, 4, 114, 111, 119, 115, 10, 4, 0, 12, 113, 117, 101, 114, 121, 45, 114, 101, 115, 117, 108, 116, 3, 0, 11, 1, 105, 0, 1, 106, 1, 13, 1, 2, 1, 64, 1, 8, 100, 97, 116, 97, 98, 97, 115, 101, 115, 0, 14, 4, 0, 23, 91, 115, 116, 97, 116, 105, 99, 93, 99, 111, 110, 110, 101, 99, 116, 105, 111, 110, 46, 111, 112, 101, 110, 1, 15, 1, 104, 0, 1, 106, 1, 12, 1, 2, 1, 64, 3, 4, 115, 101, 108, 102, 16, 9, 115, 116, 97, 116, 101, 109, 101, 110, 116, 115, 10, 112, 97, 114, 97, 109, 101, 116, 101, 114, 115, 6, 0, 17, 4, 0, 26, 91, 109, 101, 116, 104, 111, 100, 93, 99, 111, 110, 110, 101, 99, 116, 105, 111, 110, 46, 101, 120, 101, 99, 117, 116, 101, 1, 18, 4, 1, 25, 102, 101, 114, 109, 121, 111, 110, 58, 115, 112, 105, 110, 47, 115, 113, 108, 105, 116, 101, 64, 50, 46, 48, 46, 48, 5, 1, 1, 65, 39, 1, 66, 21, 4, 0, 10, 99, 111, 110, 110, 101, 99, 116, 105, 111, 110, 3, 1, 1, 113, 5, 16, 110, 111, 45, 115, 117, 99, 104, 45, 100, 97, 116, 97, 98, 97, 115, 101, 0, 0, 13, 97, 99, 99, 101, 115, 115, 45, 100, 101, 110, 105, 101, 100, 0, 0, 18, 105, 110, 118, 97, 108, 105, 100, 45, 99, 111, 110, 110, 101, 99, 116, 105, 111, 110, 0, 0, 13, 100, 97, 116, 97, 98, 97, 115, 101, 45, 102, 117, 108, 108, 0, 0, 2, 105, 111, 1, 115, 0, 4, 0, 5, 101, 114, 114, 111, 114, 3, 0, 1, 1, 112, 125, 1, 113, 5, 7, 105, 110, 116, 101, 103, 101, 114, 1, 120, 0, 4, 114, 101, 97, 108, 1, 117, 0, 4, 116, 101, 120, 116, 1, 115, 0, 4, 98, 108, 111, 98, 1, 3, 0, 4, 110, 117, 108, 108, 0, 0, 4, 0, 5, 118, 97, 108, 117, 101, 3, 0, 4, 1, 112, 5, 1, 114, 1, 6, 118, 97, 108, 117, 101, 115, 6, 4, 0, 10, 114, 111, 119, 45, 114, 101, 115, 117, 108, 116, 3, 0, 7, 1, 112, 115, 1, 112, 8, 1, 114, 2, 7, 99, 111, 108, 117, 109, 110, 115, 9, 4, 114, 111, 119, 115, 10, 4, 0, 12, 113, 117, 101, 114, 121, 45, 114, 101, 115, 117, 108, 116, 3, 0, 11, 1, 105, 0, 1, 106, 1, 13, 1, 2, 1, 64, 1, 8, 100, 97, 116, 97, 98, 97, 115, 101, 115, 0, 14, 4, 0, 23, 91, 115, 116, 97, 116, 105, 99, 93, 99, 111, 110, 110, 101, 99, 116, 105, 111, 110, 46, 111, 112, 101, 110, 1, 15, 1, 104, 0, 1, 106, 1, 12, 1, 2, 1, 64, 3, 4, 115, 101, 108, 102, 16, 9, 115, 116, 97, 116, 101, 109, 101, 110, 116, 115, 10, 112, 97, 114, 97, 109, 101, 116, 101, 114, 115, 6, 0, 17, 4, 0, 26, 91, 109, 101, 116, 104, 111, 100, 93, 99, 111, 110, 110, 101, 99, 116, 105, 111, 110, 46, 101, 120, 101, 99, 117, 116, 101, 1, 18, 3, 1, 25, 102, 101, 114, 109, 121, 111, 110, 58, 115, 112, 105, 110, 47, 115, 113, 108, 105, 116, 101, 64, 50, 46, 48, 46, 48, 5, 0, 1, 66, 24, 4, 0, 5, 115, 116, 111, 114, 101, 3, 1, 1, 113, 6, 16, 115, 116, 111, 114, 101, 45, 116, 97, 98, 108, 101, 45, 102, 117, 108, 108, 0, 0, 13, 110, 111, 45, 115, 117, 99, 104, 45, 115, 116, 111, 114, 101, 0, 0, 13, 97, 99, 99, 101, 115, 115, 45, 100, 101, 110, 105, 101, 100, 0, 0, 13, 105, 110, 118, 97, 108, 105, 100, 45, 115, 116, 111, 114, 101, 0, 0, 11, 110, 111, 45, 115, 117, 99, 104, 45, 107, 101, 121, 0, 0, 2, 105, 111, 1, 115, 0, 4, 0, 5, 101, 114, 114, 111, 114, 3, 0, 1, 1, 105, 0, 1, 106, 1, 3, 1, 2, 1, 64, 1, 4, 110, 97, 109, 101, 115, 0, 4, 4, 0, 18, 91, 115, 116, 97, 116, 105, 99, 93, 115, 116, 111, 114, 101, 46, 111, 112, 101, 110, 1, 5, 1, 104, 0, 1, 112, 125, 1, 106, 1, 7, 1, 2, 1, 64, 2, 4, 115, 101, 108, 102, 6, 3, 107, 101, 121, 115, 0, 8, 4, 0, 17, 91, 109, 101, 116, 104, 111, 100, 93, 115, 116, 111, 114, 101, 46, 103, 101, 116, 1, 9, 1, 106, 0, 1, 2, 1, 64, 3, 4, 115, 101, 108, 102, 6, 3, 107, 101, 121, 115, 5, 118, 97, 108, 117, 101, 7, 0, 10, 4, 0, 17, 91, 109, 101, 116, 104, 111, 100, 93, 115, 116, 111, 114, 101, 46, 115, 101, 116, 1, 11, 1, 64, 2, 4, 115, 101, 108, 102, 6, 3, 107, 101, 121, 115, 0, 10, 4, 0, 20, 91, 109, 101, 116, 104, 111, 100, 93, 115, 116, 111, 114, 101, 46, 100, 101, 108, 101, 116, 101, 1, 12, 1, 106, 1, 127, 1, 2, 1, 64, 2, 4, 115, 101, 108, 102, 6, 3, 107, 101, 121, 115, 0, 13, 4, 0, 20, 91, 109, 101, 116, 104, 111, 100, 93, 115, 116, 111, 114, 101, 46, 101, 120, 105, 115, 116, 115, 1, 14, 1, 112, 115, 1, 106, 1, 15, 1, 2, 1, 64, 1, 4, 115, 101, 108, 102, 6, 0, 16, 4, 0, 22, 91, 109, 101, 116, 104, 111, 100, 93, 115, 116, 111, 114, 101, 46, 103, 101, 116, 45, 107, 101, 121, 115, 1, 17, 3, 1, 28, 102, 101, 114, 109, 121, 111, 110, 58, 115, 112, 105, 110, 47, 107, 101, 121, 45, 118, 97, 108, 117, 101, 64, 50, 46, 48, 46, 48, 5, 1, 1, 66, 21, 1, 123, 4, 0, 11, 104, 116, 116, 112, 45, 115, 116, 97, 116, 117, 115, 3, 0, 0, 1, 112, 125, 4, 0, 4, 98, 111, 100, 121, 3, 0, 2, 1, 111, 2, 115, 115, 1, 112, 4, 4, 0, 7, 104, 101, 97, 100, 101, 114, 115, 3, 0, 5, 1, 112, 4, 4, 0, 6, 112, 97, 114, 97, 109, 115, 3, 0, 7, 1, 115, 4, 0, 3, 117, 114, 105, 3, 0, 9, 1, 109, 7, 3, 103, 101, 116, 4, 112, 111, 115, 116, 3, 112, 117, 116, 6, 100, 101, 108, 101, 116, 101, 5, 112, 97, 116, 99, 104, 4, 104, 101, 97, 100, 7, 111, 112, 116, 105, 111, 110, 115, 4, 0, 6, 109, 101, 116, 104, 111, 100, 3, 0, 11, 1, 107, 3, 1, 114, 5, 6, 109, 101, 116, 104, 111, 100, 12, 3, 117, 114, 105, 10, 7, 104, 101, 97, 100, 101, 114, 115, 6, 6, 112, 97, 114, 97, 109, 115, 8, 4, 98, 111, 100, 121, 13, 4, 0, 7, 114, 101, 113, 117, 101, 115, 116, 3, 0, 14, 1, 107, 6, 1, 114, 3, 6, 115, 116, 97, 116, 117, 115, 1, 7, 104, 101, 97, 100, 101, 114, 115, 16, 4, 98, 111, 100, 121, 13, 4, 0, 8, 114, 101, 115, 112, 111, 110, 115, 101, 3, 0, 17, 1, 109, 6, 7, 115, 117, 99, 99, 101, 115, 115, 23, 100, 101, 115, 116, 105, 110, 97, 116, 105, 111, 110, 45, 110, 111, 116, 45, 97, 108, 108, 111, 119, 101, 100, 11, 105, 110, 118, 97, 108, 105, 100, 45, 117, 114, 108, 13, 114, 101, 113, 117, 101, 115, 116, 45, 101, 114, 114, 111, 114, 13, 114, 117, 110, 116, 105, 109, 101, 45, 101, 114, 114, 111, 114, 17, 116, 111, 111, 45, 109, 97, 110, 121, 45, 114, 101, 113, 117, 101, 115, 116, 115, 4, 0, 10, 104, 116, 116, 112, 45, 101, 114, 114, 111, 114, 3, 0, 19, 3, 1, 23, 102, 101, 114, 109, 121, 111, 110, 58, 115, 112, 105, 110, 47, 104, 116, 116, 112, 45, 116, 121, 112, 101, 115, 5, 2, 1, 66, 8, 1, 109, 2, 7, 115, 117, 99, 99, 101, 115, 115, 5, 101, 114, 114, 111, 114, 4, 0, 5, 101, 114, 114, 111, 114, 3, 0, 0, 1, 112, 125, 4, 0, 7, 112, 97, 121, 108, 111, 97, 100, 3, 0, 2, 1, 113, 2, 5, 105, 110, 116, 54, 52, 1, 120, 0, 6, 98, 105, 110, 97, 114, 121, 1, 3, 0, 4, 0, 15, 114, 101, 100, 105, 115, 45, 112, 97, 114, 97, 109, 101, 116, 101, 114, 3, 0, 4, 1, 113, 4, 3, 110, 105, 108, 0, 0, 6, 115, 116, 97, 116, 117, 115, 1, 115, 0, 5, 105, 110, 116, 54, 52, 1, 120, 0, 6, 98, 105, 110, 97, 114, 121, 1, 3, 0, 4, 0, 12, 114, 101, 100, 105, 115, 45, 114, 101, 115, 117, 108, 116, 3, 0, 6, 3, 1, 24, 102, 101, 114, 109, 121, 111, 110, 58, 115, 112, 105, 110, 47, 114, 101, 100, 105, 115, 45, 116, 121, 112, 101, 115, 5, 3, 1, 66, 5, 1, 113, 4, 8, 112, 114, 111, 118, 105, 100, 101, 114, 1, 115, 0, 11, 105, 110, 118, 97, 108, 105, 100, 45, 107, 101, 121, 1, 115, 0, 14, 105, 110, 118, 97, 108, 105, 100, 45, 115, 99, 104, 101, 109, 97, 1, 115, 0, 5, 111, 116, 104, 101, 114, 1, 115, 0, 4, 0, 5, 101, 114, 114, 111, 114, 3, 0, 0, 1, 106, 1, 115, 1, 1, 1, 64, 1, 3, 107, 101, 121, 115, 0, 2, 4, 0, 10, 103, 101, 116, 45, 99, 111, 110, 102, 105, 103, 1, 3, 3, 1, 19, 102, 101, 114, 109, 121, 111, 110, 58, 115, 112, 105, 110, 47, 99, 111, 110, 102, 105, 103, 5, 4, 2, 3, 0, 2, 7, 114, 101, 113, 117, 101, 115, 116, 2, 3, 0, 2, 8, 114, 101, 115, 112, 111, 110, 115, 101, 2, 3, 0, 2, 10, 104, 116, 116, 112, 45, 101, 114, 114, 111, 114, 1, 66, 9, 2, 3, 2, 1, 5, 4, 0, 7, 114, 101, 113, 117, 101, 115, 116, 3, 0, 0, 2, 3, 2, 1, 6, 4, 0, 8, 114, 101, 115, 112, 111, 110, 115, 101, 3, 0, 2, 2, 3, 2, 1, 7, 4, 0, 10, 104, 116, 116, 112, 45, 101, 114, 114, 111, 114, 3, 0, 4, 1, 106, 1, 3, 1, 5, 1, 64, 1, 3, 114, 101, 113, 1, 0, 6, 4, 0, 12, 115, 101, 110, 100, 45, 114, 101, 113, 117, 101, 115, 116, 1, 7, 3, 1, 17, 102, 101, 114, 109, 121, 111, 110, 58, 115, 112, 105, 110, 47, 104, 116, 116, 112, 5, 8, 1, 66, 15, 1, 109, 14, 7, 98, 111, 111, 108, 101, 97, 110, 4, 105, 110, 116, 56, 5, 105, 110, 116, 49, 54, 5, 105, 110, 116, 51, 50, 5, 105, 110, 116, 54, 52, 5, 117, 105, 110, 116, 56, 6, 117, 105, 110, 116, 49, 54, 6, 117, 105, 110, 116, 51, 50, 6, 117, 105, 110, 116, 54, 52, 10, 102, 108, 111, 97, 116, 105, 110, 103, 51, 50, 10, 102, 108, 111, 97, 116, 105, 110, 103, 54, 52, 3, 115, 116, 114, 6, 98, 105, 110, 97, 114, 121, 5, 111, 116, 104, 101, 114, 4, 0, 12, 100, 98, 45, 100, 97, 116, 97, 45, 116, 121, 112, 101, 3, 0, 0, 1, 112, 125, 1, 113, 15, 7, 98, 111, 111, 108, 101, 97, 110, 1, 127, 0, 4, 105, 110, 116, 56, 1, 126, 0, 5, 105, 110, 116, 49, 54, 1, 124, 0, 5, 105, 110, 116, 51, 50, 1, 122, 0, 5, 105, 110, 116, 54, 52, 1, 120, 0, 5, 117, 105, 110, 116, 56, 1, 125, 0, 6, 117, 105, 110, 116, 49, 54, 1, 123, 0, 6, 117, 105, 110, 116, 51, 50, 1, 121, 0, 6, 117, 105, 110, 116, 54, 52, 1, 119, 0, 10, 102, 108, 111, 97, 116, 105, 110, 103, 51, 50, 1, 118, 0, 10, 102, 108, 111, 97, 116, 105, 110, 103, 54, 52, 1, 117, 0, 3, 115, 116, 114, 1, 115, 0, 6, 98, 105, 110, 97, 114, 121, 1, 2, 0, 7, 100, 98, 45, 110, 117, 108, 108, 0, 0, 11, 117, 110, 115, 117, 112, 112, 111, 114, 116, 101, 100, 0, 0, 4, 0, 8, 100, 98, 45, 118, 97, 108, 117, 101, 3, 0, 3, 1, 113, 14, 7, 98, 111, 111, 108, 101, 97, 110, 1, 127, 0, 4, 105, 110, 116, 56, 1, 126, 0, 5, 105, 110, 116, 49, 54, 1, 124, 0, 5, 105, 110, 116, 51, 50, 1, 122, 0, 5, 105, 110, 116, 54, 52, 1, 120, 0, 5, 117, 105, 110, 116, 56, 1, 125, 0, 6, 117, 105, 110, 116, 49, 54, 1, 123, 0, 6, 117, 105, 110, 116, 51, 50, 1, 121, 0, 6, 117, 105, 110, 116, 54, 52, 1, 119, 0, 10, 102, 108, 111, 97, 116, 105, 110, 103, 51, 50, 1, 118, 0, 10, 102, 108, 111, 97, 116, 105, 110, 103, 54, 52, 1, 117, 0, 3, 115, 116, 114, 1, 115, 0, 6, 98, 105, 110, 97, 114, 121, 1, 2, 0, 7, 100, 98, 45, 110, 117, 108, 108, 0, 0, 4, 0, 15, 112, 97, 114, 97, 109, 101, 116, 101, 114, 45, 118, 97, 108, 117, 101, 3, 0, 5, 1, 114, 2, 4, 110, 97, 109, 101, 115, 9, 100, 97, 116, 97, 45, 116, 121, 112, 101, 1, 4, 0, 6, 99, 111, 108, 117, 109, 110, 3, 0, 7, 1, 112, 4, 4, 0, 3, 114, 111, 119, 3, 0, 9, 1, 112, 8, 1, 112, 10, 1, 114, 2, 7, 99, 111, 108, 117, 109, 110, 115, 11, 4, 114, 111, 119, 115, 12, 4, 0, 7, 114, 111, 119, 45, 115, 101, 116, 3, 0, 13, 3, 1, 24, 102, 101, 114, 109, 121, 111, 110, 58, 115, 112, 105, 110, 47, 114, 100, 98, 109, 115, 45, 116, 121, 112, 101, 115, 5, 9, 2, 3, 0, 6, 15, 112, 97, 114, 97, 109, 101, 116, 101, 114, 45, 118, 97, 108, 117, 101, 2, 3, 0, 6, 7, 114, 111, 119, 45, 115, 101, 116, 1, 66, 13, 2, 3, 2, 1, 10, 4, 0, 15, 112, 97, 114, 97, 109, 101, 116, 101, 114, 45, 118, 97, 108, 117, 101, 3, 0, 0, 2, 3, 2, 1, 11, 4, 0, 7, 114, 111, 119, 45, 115, 101, 116, 3, 0, 2, 1, 113, 6, 7, 115, 117, 99, 99, 101, 115, 115, 0, 0, 17, 99, 111, 110, 110, 101, 99, 116, 105, 111, 110, 45, 102, 97, 105, 108, 101, 100, 1, 115, 0, 13, 98, 97, 100, 45, 112, 97, 114, 97, 109, 101, 116, 101, 114, 1, 115, 0, 12, 113, 117, 101, 114, 121, 45, 102, 97, 105, 108, 101, 100, 1, 115, 0, 23, 118, 97, 108, 117, 101, 45, 99, 111, 110, 118, 101, 114, 115, 105, 111, 110, 45, 102, 97, 105, 108, 101, 100, 1, 115, 0, 11, 111, 116, 104, 101, 114, 45, 101, 114, 114, 111, 114, 1, 115, 0, 4, 0, 8, 112, 103, 45, 101, 114, 114, 111, 114, 3, 0, 4, 1, 112, 1, 1, 106, 1, 3, 1, 5, 1, 64, 3, 7, 97, 100, 100, 114, 101, 115, 115, 115, 9, 115, 116, 97, 116, 101, 109, 101, 110, 116, 115, 6, 112, 97, 114, 97, 109, 115, 6, 0, 7, 4, 0, 5, 113, 117, 101, 114, 121, 1, 8, 1, 106, 1, 119, 1, 5, 1, 64, 3, 7, 97, 100, 100, 114, 101, 115, 115, 115, 9, 115, 116, 97, 116, 101, 109, 101, 110, 116, 115, 6, 112, 97, 114, 97, 109, 115, 6, 0, 9, 4, 0, 7, 101, 120, 101, 99, 117, 116, 101, 1, 10, 3, 1, 21, 102, 101, 114, 109, 121, 111, 110, 58, 115, 112, 105, 110, 47, 112, 111, 115, 116, 103, 114, 101, 115, 5, 12, 1, 66, 13, 2, 3, 2, 1, 10, 4, 0, 15, 112, 97, 114, 97, 109, 101, 116, 101, 114, 45, 118, 97, 108, 117, 101, 3, 0, 0, 2, 3, 2, 1, 11, 4, 0, 7, 114, 111, 119, 45, 115, 101, 116, 3, 0, 2, 1, 113, 6, 7, 115, 117, 99, 99, 101, 115, 115, 0, 0, 17, 99, 111, 110, 110, 101, 99, 116, 105, 111, 110, 45, 102, 97, 105, 108, 101, 100, 1, 115, 0, 13, 98, 97, 100, 45, 112, 97, 114, 97, 109, 101, 116, 101, 114, 1, 115, 0, 12, 113, 117, 101, 114, 121, 45, 102, 97, 105, 108, 101, 100, 1, 115, 0, 23, 118, 97, 108, 117, 101, 45, 99, 111, 110, 118, 101, 114, 115, 105, 111, 110, 45, 102, 97, 105, 108, 101, 100, 1, 115, 0, 11, 111, 116, 104, 101, 114, 45, 101, 114, 114, 111, 114, 1, 115, 0, 4, 0, 11, 109, 121, 115, 113, 108, 45, 101, 114, 114, 111, 114, 3, 0, 4, 1, 112, 1, 1, 106, 1, 3, 1, 5, 1, 64, 3, 7, 97, 100, 100, 114, 101, 115, 115, 115, 9, 115, 116, 97, 116, 101, 109, 101, 110, 116, 115, 6, 112, 97, 114, 97, 109, 115, 6, 0, 7, 4, 0, 5, 113, 117, 101, 114, 121, 1, 8, 1, 106, 0, 1, 5, 1, 64, 3, 7, 97, 100, 100, 114, 101, 115, 115, 115, 9, 115, 116, 97, 116, 101, 109, 101, 110, 116, 115, 6, 112, 97, 114, 97, 109, 115, 6, 0, 9, 4, 0, 7, 101, 120, 101, 99, 117, 116, 101, 1, 10, 3, 1, 18, 102, 101, 114, 109, 121, 111, 110, 58, 115, 112, 105, 110, 47, 109, 121, 115, 113, 108, 5, 13, 1, 66, 22, 1, 121, 4, 0, 10, 99, 111, 110, 110, 101, 99, 116, 105, 111, 110, 3, 0, 0, 1, 113, 5, 16, 110, 111, 45, 115, 117, 99, 104, 45, 100, 97, 116, 97, 98, 97, 115, 101, 0, 0, 13, 97, 99, 99, 101, 115, 115, 45, 100, 101, 110, 105, 101, 100, 0, 0, 18, 105, 110, 118, 97, 108, 105, 100, 45, 99, 111, 110, 110, 101, 99, 116, 105, 111, 110, 0, 0, 13, 100, 97, 116, 97, 98, 97, 115, 101, 45, 102, 117, 108, 108, 0, 0, 2, 105, 111, 1, 115, 0, 4, 0, 5, 101, 114, 114, 111, 114, 3, 0, 2, 1, 112, 125, 1, 113, 5, 7, 105, 110, 116, 101, 103, 101, 114, 1, 120, 0, 4, 114, 101, 97, 108, 1, 117, 0, 4, 116, 101, 120, 116, 1, 115, 0, 4, 98, 108, 111, 98, 1, 4, 0, 4, 110, 117, 108, 108, 0, 0, 4, 0, 5, 118, 97, 108, 117, 101, 3, 0, 5, 1, 112, 6, 1, 114, 1, 6, 118, 97, 108, 117, 101, 115, 7, 4, 0, 10, 114, 111, 119, 45, 114, 101, 115, 117, 108, 116, 3, 0, 8, 1, 112, 115, 1, 112, 9, 1, 114, 2, 7, 99, 111, 108, 117, 109, 110, 115, 10, 4, 114, 111, 119, 115, 11, 4, 0, 12, 113, 117, 101, 114, 121, 45, 114, 101, 115, 117, 108, 116, 3, 0, 12, 1, 106, 1, 1, 1, 3, 1, 64, 1, 8, 100, 97, 116, 97, 98, 97, 115, 101, 115, 0, 14, 4, 0, 4, 111, 112, 101, 110, 1, 15, 1, 106, 1, 13, 1, 3, 1, 64, 3, 4, 99, 111, 110, 110, 1, 9, 115, 116, 97, 116, 101, 109, 101, 110, 116, 115, 10, 112, 97, 114, 97, 109, 101, 116, 101, 114, 115, 7, 0, 16, 4, 0, 7, 101, 120, 101, 99, 117, 116, 101, 1, 17, 1, 64, 1, 4, 99, 111, 110, 110, 1, 1, 0, 4, 0, 5, 99, 108, 111, 115, 101, 1, 18, 3, 1, 19, 102, 101, 114, 109, 121, 111, 110, 58, 115, 112, 105, 110, 47, 115, 113, 108, 105, 116, 101, 5, 14, 2, 3, 0, 3, 7, 112, 97, 121, 108, 111, 97, 100, 2, 3, 0, 3, 15, 114, 101, 100, 105, 115, 45, 112, 97, 114, 97, 109, 101, 116, 101, 114, 2, 3, 0, 3, 12, 114, 101, 100, 105, 115, 45, 114, 101, 115, 117, 108, 116, 2, 3, 0, 3, 5, 101, 114, 114, 111, 114, 1, 66, 33, 2, 3, 2, 1, 15, 4, 0, 7, 112, 97, 121, 108, 111, 97, 100, 3, 0, 0, 2, 3, 2, 1, 16, 4, 0, 15, 114, 101, 100, 105, 115, 45, 112, 97, 114, 97, 109, 101, 116, 101, 114, 3, 0, 2, 2, 3, 2, 1, 17, 4, 0, 12, 114, 101, 100, 105, 115, 45, 114, 101, 115, 117, 108, 116, 3, 0, 4, 2, 3, 2, 1, 18, 4, 0, 5, 101, 114, 114, 111, 114, 3, 0, 6, 1, 106, 0, 1, 7, 1, 64, 3, 7, 97, 100, 100, 114, 101, 115, 115, 115, 7, 99, 104, 97, 110, 110, 101, 108, 115, 7, 112, 97, 121, 108, 111, 97, 100, 1, 0, 8, 4, 0, 7, 112, 117, 98, 108, 105, 115, 104, 1, 9, 1, 106, 1, 1, 1, 7, 1, 64, 2, 7, 97, 100, 100, 114, 101, 115, 115, 115, 3, 107, 101, 121, 115, 0, 10, 4, 0, 3, 103, 101, 116, 1, 11, 1, 64, 3, 7, 97, 100, 100, 114, 101, 115, 115, 115, 3, 107, 101, 121, 115, 5, 118, 97, 108, 117, 101, 1, 0, 8, 4, 0, 3, 115, 101, 116, 1, 12, 1, 106, 1, 120, 1, 7, 1, 64, 2, 7, 97, 100, 100, 114, 101, 115, 115, 115, 3, 107, 101, 121, 115, 0, 13, 4, 0, 4, 105, 110, 99, 114, 1, 14, 1, 112, 115, 1, 64, 2, 7, 97, 100, 100, 114, 101, 115, 115, 115, 4, 107, 101, 121, 115, 15, 0, 13, 4, 0, 3, 100, 101, 108, 1, 16, 1, 64, 3, 7, 97, 100, 100, 114, 101, 115, 115, 115, 3, 107, 101, 121, 115, 6, 118, 97, 108, 117, 101, 115, 15, 0, 13, 4, 0, 4, 115, 97, 100, 100, 1, 17, 1, 106, 1, 15, 1, 7, 1, 64, 2, 7, 97, 100, 100, 114, 101, 115, 115, 115, 3, 107, 101, 121, 115, 0, 18, 4, 0, 8, 115, 109, 101, 109, 98, 101, 114, 115, 1, 19, 4, 0, 4, 115, 114, 101, 109, 1, 17, 1, 112, 3, 1, 112, 5, 1, 106, 1, 21, 1, 7, 1, 64, 3, 7, 97, 100, 100, 114, 101, 115, 115, 115, 7, 99, 111, 109, 109, 97, 110, 100, 115, 9, 97, 114, 103, 117, 109, 101, 110, 116, 115, 20, 0, 22, 4, 0, 7, 101, 120, 101, 99, 117, 116, 101, 1, 23, 3, 1, 18, 102, 101, 114, 109, 121, 111, 110, 58, 115, 112, 105, 110, 47, 114, 101, 100, 105, 115, 5, 19, 1, 66, 25, 1, 121, 4, 0, 5, 115, 116, 111, 114, 101, 3, 0, 0, 1, 113, 6, 16, 115, 116, 111, 114, 101, 45, 116, 97, 98, 108, 101, 45, 102, 117, 108, 108, 0, 0, 13, 110, 111, 45, 115, 117, 99, 104, 45, 115, 116, 111, 114, 101, 0, 0, 13, 97, 99, 99, 101, 115, 115, 45, 100, 101, 110, 105, 101, 100, 0, 0, 13, 105, 110, 118, 97, 108, 105, 100, 45, 115, 116, 111, 114, 101, 0, 0, 11, 110, 111, 45, 115, 117, 99, 104, 45, 107, 101, 121, 0, 0, 2, 105, 111, 1, 115, 0, 4, 0, 5, 101, 114, 114, 111, 114, 3, 0, 2, 1, 106, 1, 1, 1, 3, 1, 64, 1, 4, 110, 97, 109, 101, 115, 0, 4, 4, 0, 4, 111, 112, 101, 110, 1, 5, 1, 112, 125, 1, 106, 1, 6, 1, 3, 1, 64, 2, 5, 115, 116, 111, 114, 101, 1, 3, 107, 101, 121, 115, 0, 7, 4, 0, 3, 103, 101, 116, 1, 8, 1, 106, 0, 1, 3, 1, 64, 3, 5, 115, 116, 111, 114, 101, 1, 3, 107, 101, 121, 115, 5, 118, 97, 108, 117, 101, 6, 0, 9, 4, 0, 3, 115, 101, 116, 1, 10, 1, 64, 2, 5, 115, 116, 111, 114, 101, 1, 3, 107, 101, 121, 115, 0, 9, 4, 0, 6, 100, 101, 108, 101, 116, 101, 1, 11, 1, 106, 1, 127, 1, 3, 1, 64, 2, 5, 115, 116, 111, 114, 101, 1, 3, 107, 101, 121, 115, 0, 12, 4, 0, 6, 101, 120, 105, 115, 116, 115, 1, 13, 1, 112, 115, 1, 106, 1, 14, 1, 3, 1, 64, 1, 5, 115, 116, 111, 114, 101, 1, 0, 15, 4, 0, 8, 103, 101, 116, 45, 107, 101, 121, 115, 1, 16, 1, 64, 1, 5, 115, 116, 111, 114, 101, 1, 1, 0, 4, 0, 5, 99, 108, 111, 115, 101, 1, 17, 3, 1, 22, 102, 101, 114, 109, 121, 111, 110, 58, 115, 112, 105, 110, 47, 107, 101, 121, 45, 118, 97, 108, 117, 101, 5, 20, 1, 66, 26, 1, 115, 4, 0, 17, 105, 110, 102, 101, 114, 101, 110, 99, 105, 110, 103, 45, 109, 111, 100, 101, 108, 3, 0, 0, 1, 114, 6, 10, 109, 97, 120, 45, 116, 111, 107, 101, 110, 115, 121, 14, 114, 101, 112, 101, 97, 116, 45, 112, 101, 110, 97, 108, 116, 121, 118, 33, 114, 101, 112, 101, 97, 116, 45, 112, 101, 110, 97, 108, 116, 121, 45, 108, 97, 115, 116, 45, 110, 45, 116, 111, 107, 101, 110, 45, 99, 111, 117, 110, 116, 121, 11, 116, 101, 109, 112, 101, 114, 97, 116, 117, 114, 101, 118, 5, 116, 111, 112, 45, 107, 121, 5, 116, 111, 112, 45, 112, 118, 4, 0, 18, 105, 110, 102, 101, 114, 101, 110, 99, 105, 110, 103, 45, 112, 97, 114, 97, 109, 115, 3, 0, 2, 1, 113, 3, 19, 109, 111, 100, 101, 108, 45, 110, 111, 116, 45, 115, 117, 112, 112, 111, 114, 116, 101, 100, 0, 0, 13, 114, 117, 110, 116, 105, 109, 101, 45, 101, 114, 114, 111, 114, 1, 115, 0, 13, 105, 110, 118, 97, 108, 105, 100, 45, 105, 110, 112, 117, 116, 1, 115, 0, 4, 0, 5, 101, 114, 114, 111, 114, 3, 0, 4, 1, 114, 2, 18, 112, 114, 111, 109, 112, 116, 45, 116, 111, 107, 101, 110, 45, 99, 111, 117, 110, 116, 121, 21, 103, 101, 110, 101, 114, 97, 116, 101, 100, 45, 116, 111, 107, 101, 110, 45, 99, 111, 117, 110, 116, 121, 4, 0, 17, 105, 110, 102, 101, 114, 101, 110, 99, 105, 110, 103, 45, 117, 115, 97, 103, 101, 3, 0, 6, 1, 114, 2, 4, 116, 101, 120, 116, 115, 5, 117, 115, 97, 103, 101, 7, 4, 0, 18, 105, 110, 102, 101, 114, 101, 110, 99, 105, 110, 103, 45, 114, 101, 115, 117, 108, 116, 3, 0, 8, 1, 115, 4, 0, 15, 101, 109, 98, 101, 100, 100, 105, 110, 103, 45, 109, 111, 100, 101, 108, 3, 0, 10, 1, 114, 1, 18, 112, 114, 111, 109, 112, 116, 45, 116, 111, 107, 101, 110, 45, 99, 111, 117, 110, 116, 121, 4, 0, 16, 101, 109, 98, 101, 100, 100, 105, 110, 103, 115, 45, 117, 115, 97, 103, 101, 3, 0, 12, 1, 112, 118, 1, 112, 14, 1, 114, 2, 10, 101, 109, 98, 101, 100, 100, 105, 110, 103, 115, 15, 5, 117, 115, 97, 103, 101, 13, 4, 0, 17, 101, 109, 98, 101, 100, 100, 105, 110, 103, 115, 45, 114, 101, 115, 117, 108, 116, 3, 0, 16, 1, 107, 3, 1, 106, 1, 9, 1, 5, 1, 64, 3, 5, 109, 111, 100, 101, 108, 1, 6, 112, 114, 111, 109, 112, 116, 115, 6, 112, 97, 114, 97, 109, 115, 18, 0, 19, 4, 0, 5, 105, 110, 102, 101, 114, 1, 20, 1, 112, 115, 1, 106, 1, 17, 1, 5, 1, 64, 2, 5, 109, 111, 100, 101, 108, 11, 4, 116, 101, 120, 116, 21, 0, 22, 4, 0, 19, 103, 101, 110, 101, 114, 97, 116, 101, 45, 101, 109, 98, 101, 100, 100, 105, 110, 103, 115, 1, 23, 3, 1, 16, 102, 101, 114, 109, 121, 111, 110, 58, 115, 112, 105, 110, 47, 108, 108, 109, 5, 21, 1, 66, 6, 2, 3, 2, 1, 5, 4, 0, 7, 114, 101, 113, 117, 101, 115, 116, 3, 0, 0, 2, 3, 2, 1, 6, 4, 0, 8, 114, 101, 115, 112, 111, 110, 115, 101, 3, 0, 2, 1, 64, 1, 3, 114, 101, 113, 1, 0, 3, 4, 0, 14, 104, 97, 110, 100, 108, 101, 45, 114, 101, 113, 117, 101, 115, 116, 1, 4, 4, 1, 25, 102, 101, 114, 109, 121, 111, 110, 58, 115, 112, 105, 110, 47, 105, 110, 98, 111, 117, 110, 100, 45, 104, 116, 116, 112, 5, 22, 1, 66, 7, 2, 3, 2, 1, 15, 4, 0, 7, 112, 97, 121, 108, 111, 97, 100, 3, 0, 0, 2, 3, 2, 1, 18, 4, 0, 5, 101, 114, 114, 111, 114, 3, 0, 2, 1, 106, 0, 1, 3, 1, 64, 1, 7, 109, 101, 115, 115, 97, 103, 101, 1, 0, 4, 4, 0, 14, 104, 97, 110, 100, 108, 101, 45, 109, 101, 115, 115, 97, 103, 101, 1, 5, 4, 1, 26, 102, 101, 114, 109, 121, 111, 110, 58, 115, 112, 105, 110, 47, 105, 110, 98, 111, 117, 110, 100, 45, 114, 101, 100, 105, 115, 5, 23, 4, 1, 23, 102, 101, 114, 109, 121, 111, 110, 58, 115, 112, 105, 110, 47, 104, 111, 115, 116, 64, 50, 46, 48, 46, 48, 4, 2, 1, 65, 33, 1, 66, 4, 1, 109, 6, 5, 116, 114, 97, 99, 101, 5, 100, 101, 98, 117, 103, 4, 105, 110, 102, 111, 4, 119, 97, 114, 110, 5, 101, 114, 114, 111, 114, 8, 99, 114, 105, 116, 105, 99, 97, 108, 4, 0, 5, 108, 101, 118, 101, 108, 3, 0, 0, 1, 64, 3, 5, 108, 101, 118, 101, 108, 1, 7, 99, 111, 110, 116, 101, 120, 116, 115, 7, 109, 101, 115, 115, 97, 103, 101, 115, 1, 0, 4, 0, 3, 108, 111, 103, 1, 2, 3, 1, 20, 119, 97, 115, 105, 58, 108, 111, 103, 103, 105, 110, 103, 47, 108, 111, 103, 103, 105, 110, 103, 5, 0, 1, 66, 5, 1, 113, 4, 8, 112, 114, 111, 118, 105, 100, 101, 114, 1, 115, 0, 11, 105, 110, 118, 97, 108, 105, 100, 45, 107, 101, 121, 1, 115, 0, 14, 105, 110, 118, 97, 108, 105, 100, 45, 115, 99, 104, 101, 109, 97, 1, 115, 0, 5, 111, 116, 104, 101, 114, 1, 115, 0, 4, 0, 5, 101, 114, 114, 111, 114, 3, 0, 0, 1, 106, 1, 115, 1, 1, 1, 64, 1, 3, 107, 101, 121, 115, 0, 2, 4, 0, 10, 103, 101, 116, 45, 99, 111, 110, 102, 105, 103, 1, 3, 3, 1, 19, 102, 101, 114, 109, 121, 111, 110, 58, 115, 112, 105, 110, 47, 99, 111, 110, 102, 105, 103, 5, 1, 1, 66, 21, 1, 123, 4, 0, 11, 104, 116, 116, 112, 45, 115, 116, 97, 116, 117, 115, 3, 0, 0, 1, 112, 125, 4, 0, 4, 98, 111, 100, 121, 3, 0, 2, 1, 111, 2, 115, 115, 1, 112, 4, 4, 0, 7, 104, 101, 97, 100, 101, 114, 115, 3, 0, 5, 1, 112, 4, 4, 0, 6, 112, 97, 114, 97, 109, 115, 3, 0, 7, 1, 115, 4, 0, 3, 117, 114, 105, 3, 0, 9, 1, 109, 7, 3, 103, 101, 116, 4, 112, 111, 115, 116, 3, 112, 117, 116, 6, 100, 101, 108, 101, 116, 101, 5, 112, 97, 116, 99, 104, 4, 104, 101, 97, 100, 7, 111, 112, 116, 105, 111, 110, 115, 4, 0, 6, 109, 101, 116, 104, 111, 100, 3, 0, 11, 1, 107, 3, 1, 114, 5, 6, 109, 101, 116, 104, 111, 100, 12, 3, 117, 114, 105, 10, 7, 104, 101, 97, 100, 101, 114, 115, 6, 6, 112, 97, 114, 97, 109, 115, 8, 4, 98, 111, 100, 121, 13, 4, 0, 7, 114, 101, 113, 117, 101, 115, 116, 3, 0, 14, 1, 107, 6, 1, 114, 3, 6, 115, 116, 97, 116, 117, 115, 1, 7, 104, 101, 97, 100, 101, 114, 115, 16, 4, 98, 111, 100, 121, 13, 4, 0, 8, 114, 101, 115, 112, 111, 110, 115, 101, 3, 0, 17, 1, 109, 6, 7, 115, 117, 99, 99, 101, 115, 115, 23, 100, 101, 115, 116, 105, 110, 97, 116, 105, 111, 110, 45, 110, 111, 116, 45, 97, 108, 108, 111, 119, 101, 100, 11, 105, 110, 118, 97, 108, 105, 100, 45, 117, 114, 108, 13, 114, 101, 113, 117, 101, 115, 116, 45, 101, 114, 114, 111, 114, 13, 114, 117, 110, 116, 105, 109, 101, 45, 101, 114, 114, 111, 114, 17, 116, 111, 111, 45, 109, 97, 110, 121, 45, 114, 101, 113, 117, 101, 115, 116, 115, 4, 0, 10, 104, 116, 116, 112, 45, 101, 114, 114, 111, 114, 3, 0, 19, 3, 1, 23, 102, 101, 114, 109, 121, 111, 110, 58, 115, 112, 105, 110, 47, 104, 116, 116, 112, 45, 116, 121, 112, 101, 115, 5, 2, 2, 3, 0, 2, 7, 114, 101, 113, 117, 101, 115, 116, 2, 3, 0, 2, 8, 114, 101, 115, 112, 111, 110, 115, 101, 2, 3, 0, 2, 10, 104, 116, 116, 112, 45, 101, 114, 114, 111, 114, 1, 66, 9, 2, 3, 2, 1, 3, 4, 0, 7, 114, 101, 113, 117, 101, 115, 116, 3, 0, 0, 2, 3, 2, 1, 4, 4, 0, 8, 114, 101, 115, 112, 111, 110, 115, 101, 3, 0, 2, 2, 3, 2, 1, 5, 4, 0, 10, 104, 116, 116, 112, 45, 101, 114, 114, 111, 114, 3, 0, 4, 1, 106, 1, 3, 1, 5, 1, 64, 1, 3, 114, 101, 113, 1, 0, 6, 4, 0, 12, 115, 101, 110, 100, 45, 114, 101, 113, 117, 101, 115, 116, 1, 7, 3, 1, 17, 102, 101, 114, 109, 121, 111, 110, 58, 115, 112, 105, 110, 47, 104, 116, 116, 112, 5, 6, 1, 66, 15, 1, 109, 14, 7, 98, 111, 111, 108, 101, 97, 110, 4, 105, 110, 116, 56, 5, 105, 110, 116, 49, 54, 5, 105, 110, 116, 51, 50, 5, 105, 110, 116, 54, 52, 5, 117, 105, 110, 116, 56, 6, 117, 105, 110, 116, 49, 54, 6, 117, 105, 110, 116, 51, 50, 6, 117, 105, 110, 116, 54, 52, 10, 102, 108, 111, 97, 116, 105, 110, 103, 51, 50, 10, 102, 108, 111, 97, 116, 105, 110, 103, 54, 52, 3, 115, 116, 114, 6, 98, 105, 110, 97, 114, 121, 5, 111, 116, 104, 101, 114, 4, 0, 12, 100, 98, 45, 100, 97, 116, 97, 45, 116, 121, 112, 101, 3, 0, 0, 1, 112, 125, 1, 113, 15, 7, 98, 111, 111, 108, 101, 97, 110, 1, 127, 0, 4, 105, 110, 116, 56, 1, 126, 0, 5, 105, 110, 116, 49, 54, 1, 124, 0, 5, 105, 110, 116, 51, 50, 1, 122, 0, 5, 105, 110, 116, 54, 52, 1, 120, 0, 5, 117, 105, 110, 116, 56, 1, 125, 0, 6, 117, 105, 110, 116, 49, 54, 1, 123, 0, 6, 117, 105, 110, 116, 51, 50, 1, 121, 0, 6, 117, 105, 110, 116, 54, 52, 1, 119, 0, 10, 102, 108, 111, 97, 116, 105, 110, 103, 51, 50, 1, 118, 0, 10, 102, 108, 111, 97, 116, 105, 110, 103, 54, 52, 1, 117, 0, 3, 115, 116, 114, 1, 115, 0, 6, 98, 105, 110, 97, 114, 121, 1, 2, 0, 7, 100, 98, 45, 110, 117, 108, 108, 0, 0, 11, 117, 110, 115, 117, 112, 112, 111, 114, 116, 101, 100, 0, 0, 4, 0, 8, 100, 98, 45, 118, 97, 108, 117, 101, 3, 0, 3, 1, 113, 14, 7, 98, 111, 111, 108, 101, 97, 110, 1, 127, 0, 4, 105, 110, 116, 56, 1, 126, 0, 5, 105, 110, 116, 49, 54, 1, 124, 0, 5, 105, 110, 116, 51, 50, 1, 122, 0, 5, 105, 110, 116, 54, 52, 1, 120, 0, 5, 117, 105, 110, 116, 56, 1, 125, 0, 6, 117, 105, 110, 116, 49, 54, 1, 123, 0, 6, 117, 105, 110, 116, 51, 50, 1, 121, 0, 6, 117, 105, 110, 116, 54, 52, 1, 119, 0, 10, 102, 108, 111, 97, 116, 105, 110, 103, 51, 50, 1, 118, 0, 10, 102, 108, 111, 97, 116, 105, 110, 103, 54, 52, 1, 117, 0, 3, 115, 116, 114, 1, 115, 0, 6, 98, 105, 110, 97, 114, 121, 1, 2, 0, 7, 100, 98, 45, 110, 117, 108, 108, 0, 0, 4, 0, 15, 112, 97, 114, 97, 109, 101, 116, 101, 114, 45, 118, 97, 108, 117, 101, 3, 0, 5, 1, 114, 2, 4, 110, 97, 109, 101, 115, 9, 100, 97, 116, 97, 45, 116, 121, 112, 101, 1, 4, 0, 6, 99, 111, 108, 117, 109, 110, 3, 0, 7, 1, 112, 4, 4, 0, 3, 114, 111, 119, 3, 0, 9, 1, 112, 8, 1, 112, 10, 1, 114, 2, 7, 99, 111, 108, 117, 109, 110, 115, 11, 4, 114, 111, 119, 115, 12, 4, 0, 7, 114, 111, 119, 45, 115, 101, 116, 3, 0, 13, 3, 1, 24, 102, 101, 114, 109, 121, 111, 110, 58, 115, 112, 105, 110, 47, 114, 100, 98, 109, 115, 45, 116, 121, 112, 101, 115, 5, 7, 2, 3, 0, 4, 15, 112, 97, 114, 97, 109, 101, 116, 101, 114, 45, 118, 97, 108, 117, 101, 2, 3, 0, 4, 7, 114, 111, 119, 45, 115, 101, 116, 1, 66, 13, 2, 3, 2, 1, 8, 4, 0, 15, 112, 97, 114, 97, 109, 101, 116, 101, 114, 45, 118, 97, 108, 117, 101, 3, 0, 0, 2, 3, 2, 1, 9, 4, 0, 7, 114, 111, 119, 45, 115, 101, 116, 3, 0, 2, 1, 113, 6, 7, 115, 117, 99, 99, 101, 115, 115, 0, 0, 17, 99, 111, 110, 110, 101, 99, 116, 105, 111, 110, 45, 102, 97, 105, 108, 101, 100, 1, 115, 0, 13, 98, 97, 100, 45, 112, 97, 114, 97, 109, 101, 116, 101, 114, 1, 115, 0, 12, 113, 117, 101, 114, 121, 45, 102, 97, 105, 108, 101, 100, 1, 115, 0, 23, 118, 97, 108, 117, 101, 45, 99, 111, 110, 118, 101, 114, 115, 105, 111, 110, 45, 102, 97, 105, 108, 101, 100, 1, 115, 0, 11, 111, 116, 104, 101, 114, 45, 101, 114, 114, 111, 114, 1, 115, 0, 4, 0, 8, 112, 103, 45, 101, 114, 114, 111, 114, 3, 0, 4, 1, 112, 1, 1, 106, 1, 3, 1, 5, 1, 64, 3, 7, 97, 100, 100, 114, 101, 115, 115, 115, 9, 115, 116, 97, 116, 101, 109, 101, 110, 116, 115, 6, 112, 97, 114, 97, 109, 115, 6, 0, 7, 4, 0, 5, 113, 117, 101, 114, 121, 1, 8, 1, 106, 1, 119, 1, 5, 1, 64, 3, 7, 97, 100, 100, 114, 101, 115, 115, 115, 9, 115, 116, 97, 116, 101, 109, 101, 110, 116, 115, 6, 112, 97, 114, 97, 109, 115, 6, 0, 9, 4, 0, 7, 101, 120, 101, 99, 117, 116, 101, 1, 10, 3, 1, 21, 102, 101, 114, 109, 121, 111, 110, 58, 115, 112, 105, 110, 47, 112, 111, 115, 116, 103, 114, 101, 115, 5, 10, 1, 66, 13, 2, 3, 2, 1, 8, 4, 0, 15, 112, 97, 114, 97, 109, 101, 116, 101, 114, 45, 118, 97, 108, 117, 101, 3, 0, 0, 2, 3, 2, 1, 9, 4, 0, 7, 114, 111, 119, 45, 115, 101, 116, 3, 0, 2, 1, 113, 6, 7, 115, 117, 99, 99, 101, 115, 115, 0, 0, 17, 99, 111, 110, 110, 101, 99, 116, 105, 111, 110, 45, 102, 97, 105, 108, 101, 100, 1, 115, 0, 13, 98, 97, 100, 45, 112, 97, 114, 97, 109, 101, 116, 101, 114, 1, 115, 0, 12, 113, 117, 101, 114, 121, 45, 102, 97, 105, 108, 101, 100, 1, 115, 0, 23, 118, 97, 108, 117, 101, 45, 99, 111, 110, 118, 101, 114, 115, 105, 111, 110, 45, 102, 97, 105, 108, 101, 100, 1, 115, 0, 11, 111, 116, 104, 101, 114, 45, 101, 114, 114, 111, 114, 1, 115, 0, 4, 0, 11, 109, 121, 115, 113, 108, 45, 101, 114, 114, 111, 114, 3, 0, 4, 1, 112, 1, 1, 106, 1, 3, 1, 5, 1, 64, 3, 7, 97, 100, 100, 114, 101, 115, 115, 115, 9, 115, 116, 97, 116, 101, 109, 101, 110, 116, 115, 6, 112, 97, 114, 97, 109, 115, 6, 0, 7, 4, 0, 5, 113, 117, 101, 114, 121, 1, 8, 1, 106, 0, 1, 5, 1, 64, 3, 7, 97, 100, 100, 114, 101, 115, 115, 115, 9, 115, 116, 97, 116, 101, 109, 101, 110, 116, 115, 6, 112, 97, 114, 97, 109, 115, 6, 0, 9, 4, 0, 7, 101, 120, 101, 99, 117, 116, 101, 1, 10, 3, 1, 18, 102, 101, 114, 109, 121, 111, 110, 58, 115, 112, 105, 110, 47, 109, 121, 115, 113, 108, 5, 11, 1, 66, 8, 1, 109, 2, 7, 115, 117, 99, 99, 101, 115, 115, 5, 101, 114, 114, 111, 114, 4, 0, 5, 101, 114, 114, 111, 114, 3, 0, 0, 1, 112, 125, 4, 0, 7, 112, 97, 121, 108, 111, 97, 100, 3, 0, 2, 1, 113, 2, 5, 105, 110, 116, 54, 52, 1, 120, 0, 6, 98, 105, 110, 97, 114, 121, 1, 3, 0, 4, 0, 15, 114, 101, 100, 105, 115, 45, 112, 97, 114, 97, 109, 101, 116, 101, 114, 3, 0, 4, 1, 113, 4, 3, 110, 105, 108, 0, 0, 6, 115, 116, 97, 116, 117, 115, 1, 115, 0, 5, 105, 110, 116, 54, 52, 1, 120, 0, 6, 98, 105, 110, 97, 114, 121, 1, 3, 0, 4, 0, 12, 114, 101, 100, 105, 115, 45, 114, 101, 115, 117, 108, 116, 3, 0, 6, 3, 1, 24, 102, 101, 114, 109, 121, 111, 110, 58, 115, 112, 105, 110, 47, 114, 101, 100, 105, 115, 45, 116, 121, 112, 101, 115, 5, 12, 2, 3, 0, 7, 7, 112, 97, 121, 108, 111, 97, 100, 2, 3, 0, 7, 15, 114, 101, 100, 105, 115, 45, 112, 97, 114, 97, 109, 101, 116, 101, 114, 2, 3, 0, 7, 12, 114, 101, 100, 105, 115, 45, 114, 101, 115, 117, 108, 116, 2, 3, 0, 7, 5, 101, 114, 114, 111, 114, 1, 66, 33, 2, 3, 2, 1, 13, 4, 0, 7, 112, 97, 121, 108, 111, 97, 100, 3, 0, 0, 2, 3, 2, 1, 14, 4, 0, 15, 114, 101, 100, 105, 115, 45, 112, 97, 114, 97, 109, 101, 116, 101, 114, 3, 0, 2, 2, 3, 2, 1, 15, 4, 0, 12, 114, 101, 100, 105, 115, 45, 114, 101, 115, 117, 108, 116, 3, 0, 4, 2, 3, 2, 1, 16, 4, 0, 5, 101, 114, 114, 111, 114, 3, 0, 6, 1, 106, 0, 1, 7, 1, 64, 3, 7, 97, 100, 100, 114, 101, 115, 115, 115, 7, 99, 104, 97, 110, 110, 101, 108, 115, 7, 112, 97, 121, 108, 111, 97, 100, 1, 0, 8, 4, 0, 7, 112, 117, 98, 108, 105, 115, 104, 1, 9, 1, 106, 1, 1, 1, 7, 1, 64, 2, 7, 97, 100, 100, 114, 101, 115, 115, 115, 3, 107, 101, 121, 115, 0, 10, 4, 0, 3, 103, 101, 116, 1, 11, 1, 64, 3, 7, 97, 100, 100, 114, 101, 115, 115, 115, 3, 107, 101, 121, 115, 5, 118, 97, 108, 117, 101, 1, 0, 8, 4, 0, 3, 115, 101, 116, 1, 12, 1, 106, 1, 120, 1, 7, 1, 64, 2, 7, 97, 100, 100, 114, 101, 115, 115, 115, 3, 107, 101, 121, 115, 0, 13, 4, 0, 4, 105, 110, 99, 114, 1, 14, 1, 112, 115, 1, 64, 2, 7, 97, 100, 100, 114, 101, 115, 115, 115, 4, 107, 101, 121, 115, 15, 0, 13, 4, 0, 3, 100, 101, 108, 1, 16, 1, 64, 3, 7, 97, 100, 100, 114, 101, 115, 115, 115, 3, 107, 101, 121, 115, 6, 118, 97, 108, 117, 101, 115, 15, 0, 13, 4, 0, 4, 115, 97, 100, 100, 1, 17, 1, 106, 1, 15, 1, 7, 1, 64, 2, 7, 97, 100, 100, 114, 101, 115, 115, 115, 3, 107, 101, 121, 115, 0, 18, 4, 0, 8, 115, 109, 101, 109, 98, 101, 114, 115, 1, 19, 4, 0, 4, 115, 114, 101, 109, 1, 17, 1, 112, 3, 1, 112, 5, 1, 106, 1, 21, 1, 7, 1, 64, 3, 7, 97, 100, 100, 114, 101, 115, 115, 115, 7, 99, 111, 109, 109, 97, 110, 100, 115, 9, 97, 114, 103, 117, 109, 101, 110, 116, 115, 20, 0, 22, 4, 0, 7, 101, 120, 101, 99, 117, 116, 101, 1, 23, 3, 1, 18, 102, 101, 114, 109, 121, 111, 110, 58, 115, 112, 105, 110, 47, 114, 101, 100, 105, 115, 5, 17, 1, 66, 26, 1, 115, 4, 0, 17, 105, 110, 102, 101, 114, 101, 110, 99, 105, 110, 103, 45, 109, 111, 100, 101, 108, 3, 0, 0, 1, 114, 6, 10, 109, 97, 120, 45, 116, 111, 107, 101, 110, 115, 121, 14, 114, 101, 112, 101, 97, 116, 45, 112, 101, 110, 97, 108, 116, 121, 118, 33, 114, 101, 112, 101, 97, 116, 45, 112, 101, 110, 97, 108, 116, 121, 45, 108, 97, 115, 116, 45, 110, 45, 116, 111, 107, 101, 110, 45, 99, 111, 117, 110, 116, 121, 11, 116, 101, 109, 112, 101, 114, 97, 116, 117, 114, 101, 118, 5, 116, 111, 112, 45, 107, 121, 5, 116, 111, 112, 45, 112, 118, 4, 0, 18, 105, 110, 102, 101, 114, 101, 110, 99, 105, 110, 103, 45, 112, 97, 114, 97, 109, 115, 3, 0, 2, 1, 113, 3, 19, 109, 111, 100, 101, 108, 45, 110, 111, 116, 45, 115, 117, 112, 112, 111, 114, 116, 101, 100, 0, 0, 13, 114, 117, 110, 116, 105, 109, 101, 45, 101, 114, 114, 111, 114, 1, 115, 0, 13, 105, 110, 118, 97, 108, 105, 100, 45, 105, 110, 112, 117, 116, 1, 115, 0, 4, 0, 5, 101, 114, 114, 111, 114, 3, 0, 4, 1, 114, 2, 18, 112, 114, 111, 109, 112, 116, 45, 116, 111, 107, 101, 110, 45, 99, 111, 117, 110, 116, 121, 21, 103, 101, 110, 101, 114, 97, 116, 101, 100, 45, 116, 111, 107, 101, 110, 45, 99, 111, 117, 110, 116, 121, 4, 0, 17, 105, 110, 102, 101, 114, 101, 110, 99, 105, 110, 103, 45, 117, 115, 97, 103, 101, 3, 0, 6, 1, 114, 2, 4, 116, 101, 120, 116, 115, 5, 117, 115, 97, 103, 101, 7, 4, 0, 18, 105, 110, 102, 101, 114, 101, 110, 99, 105, 110, 103, 45, 114, 101, 115, 117, 108, 116, 3, 0, 8, 1, 115, 4, 0, 15, 101, 109, 98, 101, 100, 100, 105, 110, 103, 45, 109, 111, 100, 101, 108, 3, 0, 10, 1, 114, 1, 18, 112, 114, 111, 109, 112, 116, 45, 116, 111, 107, 101, 110, 45, 99, 111, 117, 110, 116, 121, 4, 0, 16, 101, 109, 98, 101, 100, 100, 105, 110, 103, 115, 45, 117, 115, 97, 103, 101, 3, 0, 12, 1, 112, 118, 1, 112, 14, 1, 114, 2, 10, 101, 109, 98, 101, 100, 100, 105, 110, 103, 115, 15, 5, 117, 115, 97, 103, 101, 13, 4, 0, 17, 101, 109, 98, 101, 100, 100, 105, 110, 103, 115, 45, 114, 101, 115, 117, 108, 116, 3, 0, 16, 1, 107, 3, 1, 106, 1, 9, 1, 5, 1, 64, 3, 5, 109, 111, 100, 101, 108, 1, 6, 112, 114, 111, 109, 112, 116, 115, 6, 112, 97, 114, 97, 109, 115, 18, 0, 19, 4, 0, 5, 105, 110, 102, 101, 114, 1, 20, 1, 112, 115, 1, 106, 1, 17, 1, 5, 1, 64, 2, 5, 109, 111, 100, 101, 108, 11, 4, 116, 101, 120, 116, 21, 0, 22, 4, 0, 19, 103, 101, 110, 101, 114, 97, 116, 101, 45, 101, 109, 98, 101, 100, 100, 105, 110, 103, 115, 1, 23, 3, 1, 16, 102, 101, 114, 109, 121, 111, 110, 58, 115, 112, 105, 110, 47, 108, 108, 109, 5, 18, 1, 66, 21, 4, 0, 10, 99, 111, 110, 110, 101, 99, 116, 105, 111, 110, 3, 1, 1, 113, 5, 16, 110, 111, 45, 115, 117, 99, 104, 45, 100, 97, 116, 97, 98, 97, 115, 101, 0, 0, 13, 97, 99, 99, 101, 115, 115, 45, 100, 101, 110, 105, 101, 100, 0, 0, 18, 105, 110, 118, 97, 108, 105, 100, 45, 99, 111, 110, 110, 101, 99, 116, 105, 111, 110, 0, 0, 13, 100, 97, 116, 97, 98, 97, 115, 101, 45, 102, 117, 108, 108, 0, 0, 2, 105, 111, 1, 115, 0, 4, 0, 5, 101, 114, 114, 111, 114, 3, 0, 1, 1, 112, 125, 1, 113, 5, 7, 105, 110, 116, 101, 103, 101, 114, 1, 120, 0, 4, 114, 101, 97, 108, 1, 117, 0, 4, 116, 101, 120, 116, 1, 115, 0, 4, 98, 108, 111, 98, 1, 3, 0, 4, 110, 117, 108, 108, 0, 0, 4, 0, 5, 118, 97, 108, 117, 101, 3, 0, 4, 1, 112, 5, 1, 114, 1, 6, 118, 97, 108, 117, 101, 115, 6, 4, 0, 10, 114, 111, 119, 45, 114, 101, 115, 117, 108, 116, 3, 0, 7, 1, 112, 115, 1, 112, 8, 1, 114, 2, 7, 99, 111, 108, 117, 109, 110, 115, 9, 4, 114, 111, 119, 115, 10, 4, 0, 12, 113, 117, 101, 114, 121, 45, 114, 101, 115, 117, 108, 116, 3, 0, 11, 1, 105, 0, 1, 106, 1, 13, 1, 2, 1, 64, 1, 8, 100, 97, 116, 97, 98, 97, 115, 101, 115, 0, 14, 4, 0, 23, 91, 115, 116, 97, 116, 105, 99, 93, 99, 111, 110, 110, 101, 99, 116, 105, 111, 110, 46, 111, 112, 101, 110, 1, 15, 1, 104, 0, 1, 106, 1, 12, 1, 2, 1, 64, 3, 4, 115, 101, 108, 102, 16, 9, 115, 116, 97, 116, 101, 109, 101, 110, 116, 115, 10, 112, 97, 114, 97, 109, 101, 116, 101, 114, 115, 6, 0, 17, 4, 0, 26, 91, 109, 101, 116, 104, 111, 100, 93, 99, 111, 110, 110, 101, 99, 116, 105, 111, 110, 46, 101, 120, 101, 99, 117, 116, 101, 1, 18, 3, 1, 25, 102, 101, 114, 109, 121, 111, 110, 58, 115, 112, 105, 110, 47, 115, 113, 108, 105, 116, 101, 64, 50, 46, 48, 46, 48, 5, 19, 1, 66, 24, 4, 0, 5, 115, 116, 111, 114, 101, 3, 1, 1, 113, 6, 16, 115, 116, 111, 114, 101, 45, 116, 97, 98, 108, 101, 45, 102, 117, 108, 108, 0, 0, 13, 110, 111, 45, 115, 117, 99, 104, 45, 115, 116, 111, 114, 101, 0, 0, 13, 97, 99, 99, 101, 115, 115, 45, 100, 101, 110, 105, 101, 100, 0, 0, 13, 105, 110, 118, 97, 108, 105, 100, 45, 115, 116, 111, 114, 101, 0, 0, 11, 110, 111, 45, 115, 117, 99, 104, 45, 107, 101, 121, 0, 0, 2, 105, 111, 1, 115, 0, 4, 0, 5, 101, 114, 114, 111, 114, 3, 0, 1, 1, 105, 0, 1, 106, 1, 3, 1, 2, 1, 64, 1, 4, 110, 97, 109, 101, 115, 0, 4, 4, 0, 18, 91, 115, 116, 97, 116, 105, 99, 93, 115, 116, 111, 114, 101, 46, 111, 112, 101, 110, 1, 5, 1, 104, 0, 1, 112, 125, 1, 106, 1, 7, 1, 2, 1, 64, 2, 4, 115, 101, 108, 102, 6, 3, 107, 101, 121, 115, 0, 8, 4, 0, 17, 91, 109, 101, 116, 104, 111, 100, 93, 115, 116, 111, 114, 101, 46, 103, 101, 116, 1, 9, 1, 106, 0, 1, 2, 1, 64, 3, 4, 115, 101, 108, 102, 6, 3, 107, 101, 121, 115, 5, 118, 97, 108, 117, 101, 7, 0, 10, 4, 0, 17, 91, 109, 101, 116, 104, 111, 100, 93, 115, 116, 111, 114, 101, 46, 115, 101, 116, 1, 11, 1, 64, 2, 4, 115, 101, 108, 102, 6, 3, 107, 101, 121, 115, 0, 10, 4, 0, 20, 91, 109, 101, 116, 104, 111, 100, 93, 115, 116, 111, 114, 101, 46, 100, 101, 108, 101, 116, 101, 1, 12, 1, 106, 1, 127, 1, 2, 1, 64, 2, 4, 115, 101, 108, 102, 6, 3, 107, 101, 121, 115, 0, 13, 4, 0, 20, 91, 109, 101, 116, 104, 111, 100, 93, 115, 116, 111, 114, 101, 46, 101, 120, 105, 115, 116, 115, 1, 14, 1, 112, 115, 1, 106, 1, 15, 1, 2, 1, 64, 1, 4, 115, 101, 108, 102, 6, 0, 16, 4, 0, 22, 91, 109, 101, 116, 104, 111, 100, 93, 115, 116, 111, 114, 101, 46, 103, 101, 116, 45, 107, 101, 121, 115, 1, 17, 3, 1, 28, 102, 101, 114, 109, 121, 111, 110, 58, 115, 112, 105, 110, 47, 107, 101, 121, 45, 118, 97, 108, 117, 101, 64, 50, 46, 48, 46, 48, 5, 20, 4, 1, 27, 102, 101, 114, 109, 121, 111, 110, 58, 115, 112, 105, 110, 47, 112, 108, 97, 116, 102, 111, 114, 109, 64, 50, 46, 48, 46, 48, 4, 3, 1, 65, 35, 1, 66, 8, 1, 109, 2, 7, 115, 117, 99, 99, 101, 115, 115, 5, 101, 114, 114, 111, 114, 4, 0, 5, 101, 114, 114, 111, 114, 3, 0, 0, 1, 112, 125, 4, 0, 7, 112, 97, 121, 108, 111, 97, 100, 3, 0, 2, 1, 113, 2, 5, 105, 110, 116, 54, 52, 1, 120, 0, 6, 98, 105, 110, 97, 114, 121, 1, 3, 0, 4, 0, 15, 114, 101, 100, 105, 115, 45, 112, 97, 114, 97, 109, 101, 116, 101, 114, 3, 0, 4, 1, 113, 4, 3, 110, 105, 108, 0, 0, 6, 115, 116, 97, 116, 117, 115, 1, 115, 0, 5, 105, 110, 116, 54, 52, 1, 120, 0, 6, 98, 105, 110, 97, 114, 121, 1, 3, 0, 4, 0, 12, 114, 101, 100, 105, 115, 45, 114, 101, 115, 117, 108, 116, 3, 0, 6, 3, 1, 24, 102, 101, 114, 109, 121, 111, 110, 58, 115, 112, 105, 110, 47, 114, 101, 100, 105, 115, 45, 116, 121, 112, 101, 115, 5, 0, 1, 66, 4, 1, 109, 6, 5, 116, 114, 97, 99, 101, 5, 100, 101, 98, 117, 103, 4, 105, 110, 102, 111, 4, 119, 97, 114, 110, 5, 101, 114, 114, 111, 114, 8, 99, 114, 105, 116, 105, 99, 97, 108, 4, 0, 5, 108, 101, 118, 101, 108, 3, 0, 0, 1, 64, 3, 5, 108, 101, 118, 101, 108, 1, 7, 99, 111, 110, 116, 101, 120, 116, 115, 7, 109, 101, 115, 115, 97, 103, 101, 115, 1, 0, 4, 0, 3, 108, 111, 103, 1, 2, 3, 1, 20, 119, 97, 115, 105, 58, 108, 111, 103, 103, 105, 110, 103, 47, 108, 111, 103, 103, 105, 110, 103, 5, 1, 1, 66, 5, 1, 113, 4, 8, 112, 114, 111, 118, 105, 100, 101, 114, 1, 115, 0, 11, 105, 110, 118, 97, 108, 105, 100, 45, 107, 101, 121, 1, 115, 0, 14, 105, 110, 118, 97, 108, 105, 100, 45, 115, 99, 104, 101, 109, 97, 1, 115, 0, 5, 111, 116, 104, 101, 114, 1, 115, 0, 4, 0, 5, 101, 114, 114, 111, 114, 3, 0, 0, 1, 106, 1, 115, 1, 1, 1, 64, 1, 3, 107, 101, 121, 115, 0, 2, 4, 0, 10, 103, 101, 116, 45, 99, 111, 110, 102, 105, 103, 1, 3, 3, 1, 19, 102, 101, 114, 109, 121, 111, 110, 58, 115, 112, 105, 110, 47, 99, 111, 110, 102, 105, 103, 5, 2, 1, 66, 21, 1, 123, 4, 0, 11, 104, 116, 116, 112, 45, 115, 116, 97, 116, 117, 115, 3, 0, 0, 1, 112, 125, 4, 0, 4, 98, 111, 100, 121, 3, 0, 2, 1, 111, 2, 115, 115, 1, 112, 4, 4, 0, 7, 104, 101, 97, 100, 101, 114, 115, 3, 0, 5, 1, 112, 4, 4, 0, 6, 112, 97, 114, 97, 109, 115, 3, 0, 7, 1, 115, 4, 0, 3, 117, 114, 105, 3, 0, 9, 1, 109, 7, 3, 103, 101, 116, 4, 112, 111, 115, 116, 3, 112, 117, 116, 6, 100, 101, 108, 101, 116, 101, 5, 112, 97, 116, 99, 104, 4, 104, 101, 97, 100, 7, 111, 112, 116, 105, 111, 110, 115, 4, 0, 6, 109, 101, 116, 104, 111, 100, 3, 0, 11, 1, 107, 3, 1, 114, 5, 6, 109, 101, 116, 104, 111, 100, 12, 3, 117, 114, 105, 10, 7, 104, 101, 97, 100, 101, 114, 115, 6, 6, 112, 97, 114, 97, 109, 115, 8, 4, 98, 111, 100, 121, 13, 4, 0, 7, 114, 101, 113, 117, 101, 115, 116, 3, 0, 14, 1, 107, 6, 1, 114, 3, 6, 115, 116, 97, 116, 117, 115, 1, 7, 104, 101, 97, 100, 101, 114, 115, 16, 4, 98, 111, 100, 121, 13, 4, 0, 8, 114, 101, 115, 112, 111, 110, 115, 101, 3, 0, 17, 1, 109, 6, 7, 115, 117, 99, 99, 101, 115, 115, 23, 100, 101, 115, 116, 105, 110, 97, 116, 105, 111, 110, 45, 110, 111, 116, 45, 97, 108, 108, 111, 119, 101, 100, 11, 105, 110, 118, 97, 108, 105, 100, 45, 117, 114, 108, 13, 114, 101, 113, 117, 101, 115, 116, 45, 101, 114, 114, 111, 114, 13, 114, 117, 110, 116, 105, 109, 101, 45, 101, 114, 114, 111, 114, 17, 116, 111, 111, 45, 109, 97, 110, 121, 45, 114, 101, 113, 117, 101, 115, 116, 115, 4, 0, 10, 104, 116, 116, 112, 45, 101, 114, 114, 111, 114, 3, 0, 19, 3, 1, 23, 102, 101, 114, 109, 121, 111, 110, 58, 115, 112, 105, 110, 47, 104, 116, 116, 112, 45, 116, 121, 112, 101, 115, 5, 3, 2, 3, 0, 3, 7, 114, 101, 113, 117, 101, 115, 116, 2, 3, 0, 3, 8, 114, 101, 115, 112, 111, 110, 115, 101, 2, 3, 0, 3, 10, 104, 116, 116, 112, 45, 101, 114, 114, 111, 114, 1, 66, 9, 2, 3, 2, 1, 4, 4, 0, 7, 114, 101, 113, 117, 101, 115, 116, 3, 0, 0, 2, 3, 2, 1, 5, 4, 0, 8, 114, 101, 115, 112, 111, 110, 115, 101, 3, 0, 2, 2, 3, 2, 1, 6, 4, 0, 10, 104, 116, 116, 112, 45, 101, 114, 114, 111, 114, 3, 0, 4, 1, 106, 1, 3, 1, 5, 1, 64, 1, 3, 114, 101, 113, 1, 0, 6, 4, 0, 12, 115, 101, 110, 100, 45, 114, 101, 113, 117, 101, 115, 116, 1, 7, 3, 1, 17, 102, 101, 114, 109, 121, 111, 110, 58, 115, 112, 105, 110, 47, 104, 116, 116, 112, 5, 7, 1, 66, 15, 1, 109, 14, 7, 98, 111, 111, 108, 101, 97, 110, 4, 105, 110, 116, 56, 5, 105, 110, 116, 49, 54, 5, 105, 110, 116, 51, 50, 5, 105, 110, 116, 54, 52, 5, 117, 105, 110, 116, 56, 6, 117, 105, 110, 116, 49, 54, 6, 117, 105, 110, 116, 51, 50, 6, 117, 105, 110, 116, 54, 52, 10, 102, 108, 111, 97, 116, 105, 110, 103, 51, 50, 10, 102, 108, 111, 97, 116, 105, 110, 103, 54, 52, 3, 115, 116, 114, 6, 98, 105, 110, 97, 114, 121, 5, 111, 116, 104, 101, 114, 4, 0, 12, 100, 98, 45, 100, 97, 116, 97, 45, 116, 121, 112, 101, 3, 0, 0, 1, 112, 125, 1, 113, 15, 7, 98, 111, 111, 108, 101, 97, 110, 1, 127, 0, 4, 105, 110, 116, 56, 1, 126, 0, 5, 105, 110, 116, 49, 54, 1, 124, 0, 5, 105, 110, 116, 51, 50, 1, 122, 0, 5, 105, 110, 116, 54, 52, 1, 120, 0, 5, 117, 105, 110, 116, 56, 1, 125, 0, 6, 117, 105, 110, 116, 49, 54, 1, 123, 0, 6, 117, 105, 110, 116, 51, 50, 1, 121, 0, 6, 117, 105, 110, 116, 54, 52, 1, 119, 0, 10, 102, 108, 111, 97, 116, 105, 110, 103, 51, 50, 1, 118, 0, 10, 102, 108, 111, 97, 116, 105, 110, 103, 54, 52, 1, 117, 0, 3, 115, 116, 114, 1, 115, 0, 6, 98, 105, 110, 97, 114, 121, 1, 2, 0, 7, 100, 98, 45, 110, 117, 108, 108, 0, 0, 11, 117, 110, 115, 117, 112, 112, 111, 114, 116, 101, 100, 0, 0, 4, 0, 8, 100, 98, 45, 118, 97, 108, 117, 101, 3, 0, 3, 1, 113, 14, 7, 98, 111, 111, 108, 101, 97, 110, 1, 127, 0, 4, 105, 110, 116, 56, 1, 126, 0, 5, 105, 110, 116, 49, 54, 1, 124, 0, 5, 105, 110, 116, 51, 50, 1, 122, 0, 5, 105, 110, 116, 54, 52, 1, 120, 0, 5, 117, 105, 110, 116, 56, 1, 125, 0, 6, 117, 105, 110, 116, 49, 54, 1, 123, 0, 6, 117, 105, 110, 116, 51, 50, 1, 121, 0, 6, 117, 105, 110, 116, 54, 52, 1, 119, 0, 10, 102, 108, 111, 97, 116, 105, 110, 103, 51, 50, 1, 118, 0, 10, 102, 108, 111, 97, 116, 105, 110, 103, 54, 52, 1, 117, 0, 3, 115, 116, 114, 1, 115, 0, 6, 98, 105, 110, 97, 114, 121, 1, 2, 0, 7, 100, 98, 45, 110, 117, 108, 108, 0, 0, 4, 0, 15, 112, 97, 114, 97, 109, 101, 116, 101, 114, 45, 118, 97, 108, 117, 101, 3, 0, 5, 1, 114, 2, 4, 110, 97, 109, 101, 115, 9, 100, 97, 116, 97, 45, 116, 121, 112, 101, 1, 4, 0, 6, 99, 111, 108, 117, 109, 110, 3, 0, 7, 1, 112, 4, 4, 0, 3, 114, 111, 119, 3, 0, 9, 1, 112, 8, 1, 112, 10, 1, 114, 2, 7, 99, 111, 108, 117, 109, 110, 115, 11, 4, 114, 111, 119, 115, 12, 4, 0, 7, 114, 111, 119, 45, 115, 101, 116, 3, 0, 13, 3, 1, 24, 102, 101, 114, 109, 121, 111, 110, 58, 115, 112, 105, 110, 47, 114, 100, 98, 109, 115, 45, 116, 121, 112, 101, 115, 5, 8, 2, 3, 0, 5, 15, 112, 97, 114, 97, 109, 101, 116, 101, 114, 45, 118, 97, 108, 117, 101, 2, 3, 0, 5, 7, 114, 111, 119, 45, 115, 101, 116, 1, 66, 13, 2, 3, 2, 1, 9, 4, 0, 15, 112, 97, 114, 97, 109, 101, 116, 101, 114, 45, 118, 97, 108, 117, 101, 3, 0, 0, 2, 3, 2, 1, 10, 4, 0, 7, 114, 111, 119, 45, 115, 101, 116, 3, 0, 2, 1, 113, 6, 7, 115, 117, 99, 99, 101, 115, 115, 0, 0, 17, 99, 111, 110, 110, 101, 99, 116, 105, 111, 110, 45, 102, 97, 105, 108, 101, 100, 1, 115, 0, 13, 98, 97, 100, 45, 112, 97, 114, 97, 109, 101, 116, 101, 114, 1, 115, 0, 12, 113, 117, 101, 114, 121, 45, 102, 97, 105, 108, 101, 100, 1, 115, 0, 23, 118, 97, 108, 117, 101, 45, 99, 111, 110, 118, 101, 114, 115, 105, 111, 110, 45, 102, 97, 105, 108, 101, 100, 1, 115, 0, 11, 111, 116, 104, 101, 114, 45, 101, 114, 114, 111, 114, 1, 115, 0, 4, 0, 8, 112, 103, 45, 101, 114, 114, 111, 114, 3, 0, 4, 1, 112, 1, 1, 106, 1, 3, 1, 5, 1, 64, 3, 7, 97, 100, 100, 114, 101, 115, 115, 115, 9, 115, 116, 97, 116, 101, 109, 101, 110, 116, 115, 6, 112, 97, 114, 97, 109, 115, 6, 0, 7, 4, 0, 5, 113, 117, 101, 114, 121, 1, 8, 1, 106, 1, 119, 1, 5, 1, 64, 3, 7, 97, 100, 100, 114, 101, 115, 115, 115, 9, 115, 116, 97, 116, 101, 109, 101, 110, 116, 115, 6, 112, 97, 114, 97, 109, 115, 6, 0, 9, 4, 0, 7, 101, 120, 101, 99, 117, 116, 101, 1, 10, 3, 1, 21, 102, 101, 114, 109, 121, 111, 110, 58, 115, 112, 105, 110, 47, 112, 111, 115, 116, 103, 114, 101, 115, 5, 11, 1, 66, 13, 2, 3, 2, 1, 9, 4, 0, 15, 112, 97, 114, 97, 109, 101, 116, 101, 114, 45, 118, 97, 108, 117, 101, 3, 0, 0, 2, 3, 2, 1, 10, 4, 0, 7, 114, 111, 119, 45, 115, 101, 116, 3, 0, 2, 1, 113, 6, 7, 115, 117, 99, 99, 101, 115, 115, 0, 0, 17, 99, 111, 110, 110, 101, 99, 116, 105, 111, 110, 45, 102, 97, 105, 108, 101, 100, 1, 115, 0, 13, 98, 97, 100, 45, 112, 97, 114, 97, 109, 101, 116, 101, 114, 1, 115, 0, 12, 113, 117, 101, 114, 121, 45, 102, 97, 105, 108, 101, 100, 1, 115, 0, 23, 118, 97, 108, 117, 101, 45, 99, 111, 110, 118, 101, 114, 115, 105, 111, 110, 45, 102, 97, 105, 108, 101, 100, 1, 115, 0, 11, 111, 116, 104, 101, 114, 45, 101, 114, 114, 111, 114, 1, 115, 0, 4, 0, 11, 109, 121, 115, 113, 108, 45, 101, 114, 114, 111, 114, 3, 0, 4, 1, 112, 1, 1, 106, 1, 3, 1, 5, 1, 64, 3, 7, 97, 100, 100, 114, 101, 115, 115, 115, 9, 115, 116, 97, 116, 101, 109, 101, 110, 116, 115, 6, 112, 97, 114, 97, 109, 115, 6, 0, 7, 4, 0, 5, 113, 117, 101, 114, 121, 1, 8, 1, 106, 0, 1, 5, 1, 64, 3, 7, 97, 100, 100, 114, 101, 115, 115, 115, 9, 115, 116, 97, 116, 101, 109, 101, 110, 116, 115, 6, 112, 97, 114, 97, 109, 115, 6, 0, 9, 4, 0, 7, 101, 120, 101, 99, 117, 116, 101, 1, 10, 3, 1, 18, 102, 101, 114, 109, 121, 111, 110, 58, 115, 112, 105, 110, 47, 109, 121, 115, 113, 108, 5, 12, 2, 3, 0, 0, 7, 112, 97, 121, 108, 111, 97, 100, 2, 3, 0, 0, 15, 114, 101, 100, 105, 115, 45, 112, 97, 114, 97, 109, 101, 116, 101, 114, 2, 3, 0, 0, 12, 114, 101, 100, 105, 115, 45, 114, 101, 115, 117, 108, 116, 2, 3, 0, 0, 5, 101, 114, 114, 111, 114, 1, 66, 33, 2, 3, 2, 1, 13, 4, 0, 7, 112, 97, 121, 108, 111, 97, 100, 3, 0, 0, 2, 3, 2, 1, 14, 4, 0, 15, 114, 101, 100, 105, 115, 45, 112, 97, 114, 97, 109, 101, 116, 101, 114, 3, 0, 2, 2, 3, 2, 1, 15, 4, 0, 12, 114, 101, 100, 105, 115, 45, 114, 101, 115, 117, 108, 116, 3, 0, 4, 2, 3, 2, 1, 16, 4, 0, 5, 101, 114, 114, 111, 114, 3, 0, 6, 1, 106, 0, 1, 7, 1, 64, 3, 7, 97, 100, 100, 114, 101, 115, 115, 115, 7, 99, 104, 97, 110, 110, 101, 108, 115, 7, 112, 97, 121, 108, 111, 97, 100, 1, 0, 8, 4, 0, 7, 112, 117, 98, 108, 105, 115, 104, 1, 9, 1, 106, 1, 1, 1, 7, 1, 64, 2, 7, 97, 100, 100, 114, 101, 115, 115, 115, 3, 107, 101, 121, 115, 0, 10, 4, 0, 3, 103, 101, 116, 1, 11, 1, 64, 3, 7, 97, 100, 100, 114, 101, 115, 115, 115, 3, 107, 101, 121, 115, 5, 118, 97, 108, 117, 101, 1, 0, 8, 4, 0, 3, 115, 101, 116, 1, 12, 1, 106, 1, 120, 1, 7, 1, 64, 2, 7, 97, 100, 100, 114, 101, 115, 115, 115, 3, 107, 101, 121, 115, 0, 13, 4, 0, 4, 105, 110, 99, 114, 1, 14, 1, 112, 115, 1, 64, 2, 7, 97, 100, 100, 114, 101, 115, 115, 115, 4, 107, 101, 121, 115, 15, 0, 13, 4, 0, 3, 100, 101, 108, 1, 16, 1, 64, 3, 7, 97, 100, 100, 114, 101, 115, 115, 115, 3, 107, 101, 121, 115, 6, 118, 97, 108, 117, 101, 115, 15, 0, 13, 4, 0, 4, 115, 97, 100, 100, 1, 17, 1, 106, 1, 15, 1, 7, 1, 64, 2, 7, 97, 100, 100, 114, 101, 115, 115, 115, 3, 107, 101, 121, 115, 0, 18, 4, 0, 8, 115, 109, 101, 109, 98, 101, 114, 115, 1, 19, 4, 0, 4, 115, 114, 101, 109, 1, 17, 1, 112, 3, 1, 112, 5, 1, 106, 1, 21, 1, 7, 1, 64, 3, 7, 97, 100, 100, 114, 101, 115, 115, 115, 7, 99, 111, 109, 109, 97, 110, 100, 115, 9, 97, 114, 103, 117, 109, 101, 110, 116, 115, 20, 0, 22, 4, 0, 7, 101, 120, 101, 99, 117, 116, 101, 1, 23, 3, 1, 18, 102, 101, 114, 109, 121, 111, 110, 58, 115, 112, 105, 110, 47, 114, 101, 100, 105, 115, 5, 17, 1, 66, 26, 1, 115, 4, 0, 17, 105, 110, 102, 101, 114, 101, 110, 99, 105, 110, 103, 45, 109, 111, 100, 101, 108, 3, 0, 0, 1, 114, 6, 10, 109, 97, 120, 45, 116, 111, 107, 101, 110, 115, 121, 14, 114, 101, 112, 101, 97, 116, 45, 112, 101, 110, 97, 108, 116, 121, 118, 33, 114, 101, 112, 101, 97, 116, 45, 112, 101, 110, 97, 108, 116, 121, 45, 108, 97, 115, 116, 45, 110, 45, 116, 111, 107, 101, 110, 45, 99, 111, 117, 110, 116, 121, 11, 116, 101, 109, 112, 101, 114, 97, 116, 117, 114, 101, 118, 5, 116, 111, 112, 45, 107, 121, 5, 116, 111, 112, 45, 112, 118, 4, 0, 18, 105, 110, 102, 101, 114, 101, 110, 99, 105, 110, 103, 45, 112, 97, 114, 97, 109, 115, 3, 0, 2, 1, 113, 3, 19, 109, 111, 100, 101, 108, 45, 110, 111, 116, 45, 115, 117, 112, 112, 111, 114, 116, 101, 100, 0, 0, 13, 114, 117, 110, 116, 105, 109, 101, 45, 101, 114, 114, 111, 114, 1, 115, 0, 13, 105, 110, 118, 97, 108, 105, 100, 45, 105, 110, 112, 117, 116, 1, 115, 0, 4, 0, 5, 101, 114, 114, 111, 114, 3, 0, 4, 1, 114, 2, 18, 112, 114, 111, 109, 112, 116, 45, 116, 111, 107, 101, 110, 45, 99, 111, 117, 110, 116, 121, 21, 103, 101, 110, 101, 114, 97, 116, 101, 100, 45, 116, 111, 107, 101, 110, 45, 99, 111, 117, 110, 116, 121, 4, 0, 17, 105, 110, 102, 101, 114, 101, 110, 99, 105, 110, 103, 45, 117, 115, 97, 103, 101, 3, 0, 6, 1, 114, 2, 4, 116, 101, 120, 116, 115, 5, 117, 115, 97, 103, 101, 7, 4, 0, 18, 105, 110, 102, 101, 114, 101, 110, 99, 105, 110, 103, 45, 114, 101, 115, 117, 108, 116, 3, 0, 8, 1, 115, 4, 0, 15, 101, 109, 98, 101, 100, 100, 105, 110, 103, 45, 109, 111, 100, 101, 108, 3, 0, 10, 1, 114, 1, 18, 112, 114, 111, 109, 112, 116, 45, 116, 111, 107, 101, 110, 45, 99, 111, 117, 110, 116, 121, 4, 0, 16, 101, 109, 98, 101, 100, 100, 105, 110, 103, 115, 45, 117, 115, 97, 103, 101, 3, 0, 12, 1, 112, 118, 1, 112, 14, 1, 114, 2, 10, 101, 109, 98, 101, 100, 100, 105, 110, 103, 115, 15, 5, 117, 115, 97, 103, 101, 13, 4, 0, 17, 101, 109, 98, 101, 100, 100, 105, 110, 103, 115, 45, 114, 101, 115, 117, 108, 116, 3, 0, 16, 1, 107, 3, 1, 106, 1, 9, 1, 5, 1, 64, 3, 5, 109, 111, 100, 101, 108, 1, 6, 112, 114, 111, 109, 112, 116, 115, 6, 112, 97, 114, 97, 109, 115, 18, 0, 19, 4, 0, 5, 105, 110, 102, 101, 114, 1, 20, 1, 112, 115, 1, 106, 1, 17, 1, 5, 1, 64, 2, 5, 109, 111, 100, 101, 108, 11, 4, 116, 101, 120, 116, 21, 0, 22, 4, 0, 19, 103, 101, 110, 101, 114, 97, 116, 101, 45, 101, 109, 98, 101, 100, 100, 105, 110, 103, 115, 1, 23, 3, 1, 16, 102, 101, 114, 109, 121, 111, 110, 58, 115, 112, 105, 110, 47, 108, 108, 109, 5, 18, 1, 66, 21, 4, 0, 10, 99, 111, 110, 110, 101, 99, 116, 105, 111, 110, 3, 1, 1, 113, 5, 16, 110, 111, 45, 115, 117, 99, 104, 45, 100, 97, 116, 97, 98, 97, 115, 101, 0, 0, 13, 97, 99, 99, 101, 115, 115, 45, 100, 101, 110, 105, 101, 100, 0, 0, 18, 105, 110, 118, 97, 108, 105, 100, 45, 99, 111, 110, 110, 101, 99, 116, 105, 111, 110, 0, 0, 13, 100, 97, 116, 97, 98, 97, 115, 101, 45, 102, 117, 108, 108, 0, 0, 2, 105, 111, 1, 115, 0, 4, 0, 5, 101, 114, 114, 111, 114, 3, 0, 1, 1, 112, 125, 1, 113, 5, 7, 105, 110, 116, 101, 103, 101, 114, 1, 120, 0, 4, 114, 101, 97, 108, 1, 117, 0, 4, 116, 101, 120, 116, 1, 115, 0, 4, 98, 108, 111, 98, 1, 3, 0, 4, 110, 117, 108, 108, 0, 0, 4, 0, 5, 118, 97, 108, 117, 101, 3, 0, 4, 1, 112, 5, 1, 114, 1, 6, 118, 97, 108, 117, 101, 115, 6, 4, 0, 10, 114, 111, 119, 45, 114, 101, 115, 117, 108, 116, 3, 0, 7, 1, 112, 115, 1, 112, 8, 1, 114, 2, 7, 99, 111, 108, 117, 109, 110, 115, 9, 4, 114, 111, 119, 115, 10, 4, 0, 12, 113, 117, 101, 114, 121, 45, 114, 101, 115, 117, 108, 116, 3, 0, 11, 1, 105, 0, 1, 106, 1, 13, 1, 2, 1, 64, 1, 8, 100, 97, 116, 97, 98, 97, 115, 101, 115, 0, 14, 4, 0, 23, 91, 115, 116, 97, 116, 105, 99, 93, 99, 111, 110, 110, 101, 99, 116, 105, 111, 110, 46, 111, 112, 101, 110, 1, 15, 1, 104, 0, 1, 106, 1, 12, 1, 2, 1, 64, 3, 4, 115, 101, 108, 102, 16, 9, 115, 116, 97, 116, 101, 109, 101, 110, 116, 115, 10, 112, 97, 114, 97, 109, 101, 116, 101, 114, 115, 6, 0, 17, 4, 0, 26, 91, 109, 101, 116, 104, 111, 100, 93, 99, 111, 110, 110, 101, 99, 116, 105, 111, 110, 46, 101, 120, 101, 99, 117, 116, 101, 1, 18, 3, 1, 25, 102, 101, 114, 109, 121, 111, 110, 58, 115, 112, 105, 110, 47, 115, 113, 108, 105, 116, 101, 64, 50, 46, 48, 46, 48, 5, 19, 1, 66, 24, 4, 0, 5, 115, 116, 111, 114, 101, 3, 1, 1, 113, 6, 16, 115, 116, 111, 114, 101, 45, 116, 97, 98, 108, 101, 45, 102, 117, 108, 108, 0, 0, 13, 110, 111, 45, 115, 117, 99, 104, 45, 115, 116, 111, 114, 101, 0, 0, 13, 97, 99, 99, 101, 115, 115, 45, 100, 101, 110, 105, 101, 100, 0, 0, 13, 105, 110, 118, 97, 108, 105, 100, 45, 115, 116, 111, 114, 101, 0, 0, 11, 110, 111, 45, 115, 117, 99, 104, 45, 107, 101, 121, 0, 0, 2, 105, 111, 1, 115, 0, 4, 0, 5, 101, 114, 114, 111, 114, 3, 0, 1, 1, 105, 0, 1, 106, 1, 3, 1, 2, 1, 64, 1, 4, 110, 97, 109, 101, 115, 0, 4, 4, 0, 18, 91, 115, 116, 97, 116, 105, 99, 93, 115, 116, 111, 114, 101, 46, 111, 112, 101, 110, 1, 5, 1, 104, 0, 1, 112, 125, 1, 106, 1, 7, 1, 2, 1, 64, 2, 4, 115, 101, 108, 102, 6, 3, 107, 101, 121, 115, 0, 8, 4, 0, 17, 91, 109, 101, 116, 104, 111, 100, 93, 115, 116, 111, 114, 101, 46, 103, 101, 116, 1, 9, 1, 106, 0, 1, 2, 1, 64, 3, 4, 115, 101, 108, 102, 6, 3, 107, 101, 121, 115, 5, 118, 97, 108, 117, 101, 7, 0, 10, 4, 0, 17, 91, 109, 101, 116, 104, 111, 100, 93, 115, 116, 111, 114, 101, 46, 115, 101, 116, 1, 11, 1, 64, 2, 4, 115, 101, 108, 102, 6, 3, 107, 101, 121, 115, 0, 10, 4, 0, 20, 91, 109, 101, 116, 104, 111, 100, 93, 115, 116, 111, 114, 101, 46, 100, 101, 108, 101, 116, 101, 1, 12, 1, 106, 1, 127, 1, 2, 1, 64, 2, 4, 115, 101, 108, 102, 6, 3, 107, 101, 121, 115, 0, 13, 4, 0, 20, 91, 109, 101, 116, 104, 111, 100, 93, 115, 116, 111, 114, 101, 46, 101, 120, 105, 115, 116, 115, 1, 14, 1, 112, 115, 1, 106, 1, 15, 1, 2, 1, 64, 1, 4, 115, 101, 108, 102, 6, 0, 16, 4, 0, 22, 91, 109, 101, 116, 104, 111, 100, 93, 115, 116, 111, 114, 101, 46, 103, 101, 116, 45, 107, 101, 121, 115, 1, 17, 3, 1, 28, 102, 101, 114, 109, 121, 111, 110, 58, 115, 112, 105, 110, 47, 107, 101, 121, 45, 118, 97, 108, 117, 101, 64, 50, 46, 48, 46, 48, 5, 20, 1, 66, 7, 2, 3, 2, 1, 13, 4, 0, 7, 112, 97, 121, 108, 111, 97, 100, 3, 0, 0, 2, 3, 2, 1, 16, 4, 0, 5, 101, 114, 114, 111, 114, 3, 0, 2, 1, 106, 0, 1, 3, 1, 64, 1, 7, 109, 101, 115, 115, 97, 103, 101, 1, 0, 4, 4, 0, 14, 104, 97, 110, 100, 108, 101, 45, 109, 101, 115, 115, 97, 103, 101, 1, 5, 4, 1, 26, 102, 101, 114, 109, 121, 111, 110, 58, 115, 112, 105, 110, 47, 105, 110, 98, 111, 117, 110, 100, 45, 114, 101, 100, 105, 115, 5, 21, 4, 1, 32, 102, 101, 114, 109, 121, 111, 110, 58, 115, 112, 105, 110, 47, 114, 101, 100, 105, 115, 45, 116, 114, 105, 103, 103, 101, 114, 64, 50, 46, 48, 46, 48, 4, 4, 1, 65, 35, 1, 66, 21, 1, 123, 4, 0, 11, 104, 116, 116, 112, 45, 115, 116, 97, 116, 117, 115, 3, 0, 0, 1, 112, 125, 4, 0, 4, 98, 111, 100, 121, 3, 0, 2, 1, 111, 2, 115, 115, 1, 112, 4, 4, 0, 7, 104, 101, 97, 100, 101, 114, 115, 3, 0, 5, 1, 112, 4, 4, 0, 6, 112, 97, 114, 97, 109, 115, 3, 0, 7, 1, 115, 4, 0, 3, 117, 114, 105, 3, 0, 9, 1, 109, 7, 3, 103, 101, 116, 4, 112, 111, 115, 116, 3, 112, 117, 116, 6, 100, 101, 108, 101, 116, 101, 5, 112, 97, 116, 99, 104, 4, 104, 101, 97, 100, 7, 111, 112, 116, 105, 111, 110, 115, 4, 0, 6, 109, 101, 116, 104, 111, 100, 3, 0, 11, 1, 107, 3, 1, 114, 5, 6, 109, 101, 116, 104, 111, 100, 12, 3, 117, 114, 105, 10, 7, 104, 101, 97, 100, 101, 114, 115, 6, 6, 112, 97, 114, 97, 109, 115, 8, 4, 98, 111, 100, 121, 13, 4, 0, 7, 114, 101, 113, 117, 101, 115, 116, 3, 0, 14, 1, 107, 6, 1, 114, 3, 6, 115, 116, 97, 116, 117, 115, 1, 7, 104, 101, 97, 100, 101, 114, 115, 16, 4, 98, 111, 100, 121, 13, 4, 0, 8, 114, 101, 115, 112, 111, 110, 115, 101, 3, 0, 17, 1, 109, 6, 7, 115, 117, 99, 99, 101, 115, 115, 23, 100, 101, 115, 116, 105, 110, 97, 116, 105, 111, 110, 45, 110, 111, 116, 45, 97, 108, 108, 111, 119, 101, 100, 11, 105, 110, 118, 97, 108, 105, 100, 45, 117, 114, 108, 13, 114, 101, 113, 117, 101, 115, 116, 45, 101, 114, 114, 111, 114, 13, 114, 117, 110, 116, 105, 109, 101, 45, 101, 114, 114, 111, 114, 17, 116, 111, 111, 45, 109, 97, 110, 121, 45, 114, 101, 113, 117, 101, 115, 116, 115, 4, 0, 10, 104, 116, 116, 112, 45, 101, 114, 114, 111, 114, 3, 0, 19, 3, 1, 23, 102, 101, 114, 109, 121, 111, 110, 58, 115, 112, 105, 110, 47, 104, 116, 116, 112, 45, 116, 121, 112, 101, 115, 5, 0, 1, 66, 4, 1, 109, 6, 5, 116, 114, 97, 99, 101, 5, 100, 101, 98, 117, 103, 4, 105, 110, 102, 111, 4, 119, 97, 114, 110, 5, 101, 114, 114, 111, 114, 8, 99, 114, 105, 116, 105, 99, 97, 108, 4, 0, 5, 108, 101, 118, 101, 108, 3, 0, 0, 1, 64, 3, 5, 108, 101, 118, 101, 108, 1, 7, 99, 111, 110, 116, 101, 120, 116, 115, 7, 109, 101, 115, 115, 97, 103, 101, 115, 1, 0, 4, 0, 3, 108, 111, 103, 1, 2, 3, 1, 20, 119, 97, 115, 105, 58, 108, 111, 103, 103, 105, 110, 103, 47, 108, 111, 103, 103, 105, 110, 103, 5, 1, 1, 66, 5, 1, 113, 4, 8, 112, 114, 111, 118, 105, 100, 101, 114, 1, 115, 0, 11, 105, 110, 118, 97, 108, 105, 100, 45, 107, 101, 121, 1, 115, 0, 14, 105, 110, 118, 97, 108, 105, 100, 45, 115, 99, 104, 101, 109, 97, 1, 115, 0, 5, 111, 116, 104, 101, 114, 1, 115, 0, 4, 0, 5, 101, 114, 114, 111, 114, 3, 0, 0, 1, 106, 1, 115, 1, 1, 1, 64, 1, 3, 107, 101, 121, 115, 0, 2, 4, 0, 10, 103, 101, 116, 45, 99, 111, 110, 102, 105, 103, 1, 3, 3, 1, 19, 102, 101, 114, 109, 121, 111, 110, 58, 115, 112, 105, 110, 47, 99, 111, 110, 102, 105, 103, 5, 2, 2, 3, 0, 0, 7, 114, 101, 113, 117, 101, 115, 116, 2, 3, 0, 0, 8, 114, 101, 115, 112, 111, 110, 115, 101, 2, 3, 0, 0, 10, 104, 116, 116, 112, 45, 101, 114, 114, 111, 114, 1, 66, 9, 2, 3, 2, 1, 3, 4, 0, 7, 114, 101, 113, 117, 101, 115, 116, 3, 0, 0, 2, 3, 2, 1, 4, 4, 0, 8, 114, 101, 115, 112, 111, 110, 115, 101, 3, 0, 2, 2, 3, 2, 1, 5, 4, 0, 10, 104, 116, 116, 112, 45, 101, 114, 114, 111, 114, 3, 0, 4, 1, 106, 1, 3, 1, 5, 1, 64, 1, 3, 114, 101, 113, 1, 0, 6, 4, 0, 12, 115, 101, 110, 100, 45, 114, 101, 113, 117, 101, 115, 116, 1, 7, 3, 1, 17, 102, 101, 114, 109, 121, 111, 110, 58, 115, 112, 105, 110, 47, 104, 116, 116, 112, 5, 6, 1, 66, 15, 1, 109, 14, 7, 98, 111, 111, 108, 101, 97, 110, 4, 105, 110, 116, 56, 5, 105, 110, 116, 49, 54, 5, 105, 110, 116, 51, 50, 5, 105, 110, 116, 54, 52, 5, 117, 105, 110, 116, 56, 6, 117, 105, 110, 116, 49, 54, 6, 117, 105, 110, 116, 51, 50, 6, 117, 105, 110, 116, 54, 52, 10, 102, 108, 111, 97, 116, 105, 110, 103, 51, 50, 10, 102, 108, 111, 97, 116, 105, 110, 103, 54, 52, 3, 115, 116, 114, 6, 98, 105, 110, 97, 114, 121, 5, 111, 116, 104, 101, 114, 4, 0, 12, 100, 98, 45, 100, 97, 116, 97, 45, 116, 121, 112, 101, 3, 0, 0, 1, 112, 125, 1, 113, 15, 7, 98, 111, 111, 108, 101, 97, 110, 1, 127, 0, 4, 105, 110, 116, 56, 1, 126, 0, 5, 105, 110, 116, 49, 54, 1, 124, 0, 5, 105, 110, 116, 51, 50, 1, 122, 0, 5, 105, 110, 116, 54, 52, 1, 120, 0, 5, 117, 105, 110, 116, 56, 1, 125, 0, 6, 117, 105, 110, 116, 49, 54, 1, 123, 0, 6, 117, 105, 110, 116, 51, 50, 1, 121, 0, 6, 117, 105, 110, 116, 54, 52, 1, 119, 0, 10, 102, 108, 111, 97, 116, 105, 110, 103, 51, 50, 1, 118, 0, 10, 102, 108, 111, 97, 116, 105, 110, 103, 54, 52, 1, 117, 0, 3, 115, 116, 114, 1, 115, 0, 6, 98, 105, 110, 97, 114, 121, 1, 2, 0, 7, 100, 98, 45, 110, 117, 108, 108, 0, 0, 11, 117, 110, 115, 117, 112, 112, 111, 114, 116, 101, 100, 0, 0, 4, 0, 8, 100, 98, 45, 118, 97, 108, 117, 101, 3, 0, 3, 1, 113, 14, 7, 98, 111, 111, 108, 101, 97, 110, 1, 127, 0, 4, 105, 110, 116, 56, 1, 126, 0, 5, 105, 110, 116, 49, 54, 1, 124, 0, 5, 105, 110, 116, 51, 50, 1, 122, 0, 5, 105, 110, 116, 54, 52, 1, 120, 0, 5, 117, 105, 110, 116, 56, 1, 125, 0, 6, 117, 105, 110, 116, 49, 54, 1, 123, 0, 6, 117, 105, 110, 116, 51, 50, 1, 121, 0, 6, 117, 105, 110, 116, 54, 52, 1, 119, 0, 10, 102, 108, 111, 97, 116, 105, 110, 103, 51, 50, 1, 118, 0, 10, 102, 108, 111, 97, 116, 105, 110, 103, 54, 52, 1, 117, 0, 3, 115, 116, 114, 1, 115, 0, 6, 98, 105, 110, 97, 114, 121, 1, 2, 0, 7, 100, 98, 45, 110, 117, 108, 108, 0, 0, 4, 0, 15, 112, 97, 114, 97, 109, 101, 116, 101, 114, 45, 118, 97, 108, 117, 101, 3, 0, 5, 1, 114, 2, 4, 110, 97, 109, 101, 115, 9, 100, 97, 116, 97, 45, 116, 121, 112, 101, 1, 4, 0, 6, 99, 111, 108, 117, 109, 110, 3, 0, 7, 1, 112, 4, 4, 0, 3, 114, 111, 119, 3, 0, 9, 1, 112, 8, 1, 112, 10, 1, 114, 2, 7, 99, 111, 108, 117, 109, 110, 115, 11, 4, 114, 111, 119, 115, 12, 4, 0, 7, 114, 111, 119, 45, 115, 101, 116, 3, 0, 13, 3, 1, 24, 102, 101, 114, 109, 121, 111, 110, 58, 115, 112, 105, 110, 47, 114, 100, 98, 109, 115, 45, 116, 121, 112, 101, 115, 5, 7, 2, 3, 0, 4, 15, 112, 97, 114, 97, 109, 101, 116, 101, 114, 45, 118, 97, 108, 117, 101, 2, 3, 0, 4, 7, 114, 111, 119, 45, 115, 101, 116, 1, 66, 13, 2, 3, 2, 1, 8, 4, 0, 15, 112, 97, 114, 97, 109, 101, 116, 101, 114, 45, 118, 97, 108, 117, 101, 3, 0, 0, 2, 3, 2, 1, 9, 4, 0, 7, 114, 111, 119, 45, 115, 101, 116, 3, 0, 2, 1, 113, 6, 7, 115, 117, 99, 99, 101, 115, 115, 0, 0, 17, 99, 111, 110, 110, 101, 99, 116, 105, 111, 110, 45, 102, 97, 105, 108, 101, 100, 1, 115, 0, 13, 98, 97, 100, 45, 112, 97, 114, 97, 109, 101, 116, 101, 114, 1, 115, 0, 12, 113, 117, 101, 114, 121, 45, 102, 97, 105, 108, 101, 100, 1, 115, 0, 23, 118, 97, 108, 117, 101, 45, 99, 111, 110, 118, 101, 114, 115, 105, 111, 110, 45, 102, 97, 105, 108, 101, 100, 1, 115, 0, 11, 111, 116, 104, 101, 114, 45, 101, 114, 114, 111, 114, 1, 115, 0, 4, 0, 8, 112, 103, 45, 101, 114, 114, 111, 114, 3, 0, 4, 1, 112, 1, 1, 106, 1, 3, 1, 5, 1, 64, 3, 7, 97, 100, 100, 114, 101, 115, 115, 115, 9, 115, 116, 97, 116, 101, 109, 101, 110, 116, 115, 6, 112, 97, 114, 97, 109, 115, 6, 0, 7, 4, 0, 5, 113, 117, 101, 114, 121, 1, 8, 1, 106, 1, 119, 1, 5, 1, 64, 3, 7, 97, 100, 100, 114, 101, 115, 115, 115, 9, 115, 116, 97, 116, 101, 109, 101, 110, 116, 115, 6, 112, 97, 114, 97, 109, 115, 6, 0, 9, 4, 0, 7, 101, 120, 101, 99, 117, 116, 101, 1, 10, 3, 1, 21, 102, 101, 114, 109, 121, 111, 110, 58, 115, 112, 105, 110, 47, 112, 111, 115, 116, 103, 114, 101, 115, 5, 10, 1, 66, 13, 2, 3, 2, 1, 8, 4, 0, 15, 112, 97, 114, 97, 109, 101, 116, 101, 114, 45, 118, 97, 108, 117, 101, 3, 0, 0, 2, 3, 2, 1, 9, 4, 0, 7, 114, 111, 119, 45, 115, 101, 116, 3, 0, 2, 1, 113, 6, 7, 115, 117, 99, 99, 101, 115, 115, 0, 0, 17, 99, 111, 110, 110, 101, 99, 116, 105, 111, 110, 45, 102, 97, 105, 108, 101, 100, 1, 115, 0, 13, 98, 97, 100, 45, 112, 97, 114, 97, 109, 101, 116, 101, 114, 1, 115, 0, 12, 113, 117, 101, 114, 121, 45, 102, 97, 105, 108, 101, 100, 1, 115, 0, 23, 118, 97, 108, 117, 101, 45, 99, 111, 110, 118, 101, 114, 115, 105, 111, 110, 45, 102, 97, 105, 108, 101, 100, 1, 115, 0, 11, 111, 116, 104, 101, 114, 45, 101, 114, 114, 111, 114, 1, 115, 0, 4, 0, 11, 109, 121, 115, 113, 108, 45, 101, 114, 114, 111, 114, 3, 0, 4, 1, 112, 1, 1, 106, 1, 3, 1, 5, 1, 64, 3, 7, 97, 100, 100, 114, 101, 115, 115, 115, 9, 115, 116, 97, 116, 101, 109, 101, 110, 116, 115, 6, 112, 97, 114, 97, 109, 115, 6, 0, 7, 4, 0, 5, 113, 117, 101, 114, 121, 1, 8, 1, 106, 0, 1, 5, 1, 64, 3, 7, 97, 100, 100, 114, 101, 115, 115, 115, 9, 115, 116, 97, 116, 101, 109, 101, 110, 116, 115, 6, 112, 97, 114, 97, 109, 115, 6, 0, 9, 4, 0, 7, 101, 120, 101, 99, 117, 116, 101, 1, 10, 3, 1, 18, 102, 101, 114, 109, 121, 111, 110, 58, 115, 112, 105, 110, 47, 109, 121, 115, 113, 108, 5, 11, 1, 66, 8, 1, 109, 2, 7, 115, 117, 99, 99, 101, 115, 115, 5, 101, 114, 114, 111, 114, 4, 0, 5, 101, 114, 114, 111, 114, 3, 0, 0, 1, 112, 125, 4, 0, 7, 112, 97, 121, 108, 111, 97, 100, 3, 0, 2, 1, 113, 2, 5, 105, 110, 116, 54, 52, 1, 120, 0, 6, 98, 105, 110, 97, 114, 121, 1, 3, 0, 4, 0, 15, 114, 101, 100, 105, 115, 45, 112, 97, 114, 97, 109, 101, 116, 101, 114, 3, 0, 4, 1, 113, 4, 3, 110, 105, 108, 0, 0, 6, 115, 116, 97, 116, 117, 115, 1, 115, 0, 5, 105, 110, 116, 54, 52, 1, 120, 0, 6, 98, 105, 110, 97, 114, 121, 1, 3, 0, 4, 0, 12, 114, 101, 100, 105, 115, 45, 114, 101, 115, 117, 108, 116, 3, 0, 6, 3, 1, 24, 102, 101, 114, 109, 121, 111, 110, 58, 115, 112, 105, 110, 47, 114, 101, 100, 105, 115, 45, 116, 121, 112, 101, 115, 5, 12, 2, 3, 0, 7, 7, 112, 97, 121, 108, 111, 97, 100, 2, 3, 0, 7, 15, 114, 101, 100, 105, 115, 45, 112, 97, 114, 97, 109, 101, 116, 101, 114, 2, 3, 0, 7, 12, 114, 101, 100, 105, 115, 45, 114, 101, 115, 117, 108, 116, 2, 3, 0, 7, 5, 101, 114, 114, 111, 114, 1, 66, 33, 2, 3, 2, 1, 13, 4, 0, 7, 112, 97, 121, 108, 111, 97, 100, 3, 0, 0, 2, 3, 2, 1, 14, 4, 0, 15, 114, 101, 100, 105, 115, 45, 112, 97, 114, 97, 109, 101, 116, 101, 114, 3, 0, 2, 2, 3, 2, 1, 15, 4, 0, 12, 114, 101, 100, 105, 115, 45, 114, 101, 115, 117, 108, 116, 3, 0, 4, 2, 3, 2, 1, 16, 4, 0, 5, 101, 114, 114, 111, 114, 3, 0, 6, 1, 106, 0, 1, 7, 1, 64, 3, 7, 97, 100, 100, 114, 101, 115, 115, 115, 7, 99, 104, 97, 110, 110, 101, 108, 115, 7, 112, 97, 121, 108, 111, 97, 100, 1, 0, 8, 4, 0, 7, 112, 117, 98, 108, 105, 115, 104, 1, 9, 1, 106, 1, 1, 1, 7, 1, 64, 2, 7, 97, 100, 100, 114, 101, 115, 115, 115, 3, 107, 101, 121, 115, 0, 10, 4, 0, 3, 103, 101, 116, 1, 11, 1, 64, 3, 7, 97, 100, 100, 114, 101, 115, 115, 115, 3, 107, 101, 121, 115, 5, 118, 97, 108, 117, 101, 1, 0, 8, 4, 0, 3, 115, 101, 116, 1, 12, 1, 106, 1, 120, 1, 7, 1, 64, 2, 7, 97, 100, 100, 114, 101, 115, 115, 115, 3, 107, 101, 121, 115, 0, 13, 4, 0, 4, 105, 110, 99, 114, 1, 14, 1, 112, 115, 1, 64, 2, 7, 97, 100, 100, 114, 101, 115, 115, 115, 4, 107, 101, 121, 115, 15, 0, 13, 4, 0, 3, 100, 101, 108, 1, 16, 1, 64, 3, 7, 97, 100, 100, 114, 101, 115, 115, 115, 3, 107, 101, 121, 115, 6, 118, 97, 108, 117, 101, 115, 15, 0, 13, 4, 0, 4, 115, 97, 100, 100, 1, 17, 1, 106, 1, 15, 1, 7, 1, 64, 2, 7, 97, 100, 100, 114, 101, 115, 115, 115, 3, 107, 101, 121, 115, 0, 18, 4, 0, 8, 115, 109, 101, 109, 98, 101, 114, 115, 1, 19, 4, 0, 4, 115, 114, 101, 109, 1, 17, 1, 112, 3, 1, 112, 5, 1, 106, 1, 21, 1, 7, 1, 64, 3, 7, 97, 100, 100, 114, 101, 115, 115, 115, 7, 99, 111, 109, 109, 97, 110, 100, 115, 9, 97, 114, 103, 117, 109, 101, 110, 116, 115, 20, 0, 22, 4, 0, 7, 101, 120, 101, 99, 117, 116, 101, 1, 23, 3, 1, 18, 102, 101, 114, 109, 121, 111, 110, 58, 115, 112, 105, 110, 47, 114, 101, 100, 105, 115, 5, 17, 1, 66, 26, 1, 115, 4, 0, 17, 105, 110, 102, 101, 114, 101, 110, 99, 105, 110, 103, 45, 109, 111, 100, 101, 108, 3, 0, 0, 1, 114, 6, 10, 109, 97, 120, 45, 116, 111, 107, 101, 110, 115, 121, 14, 114, 101, 112, 101, 97, 116, 45, 112, 101, 110, 97, 108, 116, 121, 118, 33, 114, 101, 112, 101, 97, 116, 45, 112, 101, 110, 97, 108, 116, 121, 45, 108, 97, 115, 116, 45, 110, 45, 116, 111, 107, 101, 110, 45, 99, 111, 117, 110, 116, 121, 11, 116, 101, 109, 112, 101, 114, 97, 116, 117, 114, 101, 118, 5, 116, 111, 112, 45, 107, 121, 5, 116, 111, 112, 45, 112, 118, 4, 0, 18, 105, 110, 102, 101, 114, 101, 110, 99, 105, 110, 103, 45, 112, 97, 114, 97, 109, 115, 3, 0, 2, 1, 113, 3, 19, 109, 111, 100, 101, 108, 45, 110, 111, 116, 45, 115, 117, 112, 112, 111, 114, 116, 101, 100, 0, 0, 13, 114, 117, 110, 116, 105, 109, 101, 45, 101, 114, 114, 111, 114, 1, 115, 0, 13, 105, 110, 118, 97, 108, 105, 100, 45, 105, 110, 112, 117, 116, 1, 115, 0, 4, 0, 5, 101, 114, 114, 111, 114, 3, 0, 4, 1, 114, 2, 18, 112, 114, 111, 109, 112, 116, 45, 116, 111, 107, 101, 110, 45, 99, 111, 117, 110, 116, 121, 21, 103, 101, 110, 101, 114, 97, 116, 101, 100, 45, 116, 111, 107, 101, 110, 45, 99, 111, 117, 110, 116, 121, 4, 0, 17, 105, 110, 102, 101, 114, 101, 110, 99, 105, 110, 103, 45, 117, 115, 97, 103, 101, 3, 0, 6, 1, 114, 2, 4, 116, 101, 120, 116, 115, 5, 117, 115, 97, 103, 101, 7, 4, 0, 18, 105, 110, 102, 101, 114, 101, 110, 99, 105, 110, 103, 45, 114, 101, 115, 117, 108, 116, 3, 0, 8, 1, 115, 4, 0, 15, 101, 109, 98, 101, 100, 100, 105, 110, 103, 45, 109, 111, 100, 101, 108, 3, 0, 10, 1, 114, 1, 18, 112, 114, 111, 109, 112, 116, 45, 116, 111, 107, 101, 110, 45, 99, 111, 117, 110, 116, 121, 4, 0, 16, 101, 109, 98, 101, 100, 100, 105, 110, 103, 115, 45, 117, 115, 97, 103, 101, 3, 0, 12, 1, 112, 118, 1, 112, 14, 1, 114, 2, 10, 101, 109, 98, 101, 100, 100, 105, 110, 103, 115, 15, 5, 117, 115, 97, 103, 101, 13, 4, 0, 17, 101, 109, 98, 101, 100, 100, 105, 110, 103, 115, 45, 114, 101, 115, 117, 108, 116, 3, 0, 16, 1, 107, 3, 1, 106, 1, 9, 1, 5, 1, 64, 3, 5, 109, 111, 100, 101, 108, 1, 6, 112, 114, 111, 109, 112, 116, 115, 6, 112, 97, 114, 97, 109, 115, 18, 0, 19, 4, 0, 5, 105, 110, 102, 101, 114, 1, 20, 1, 112, 115, 1, 106, 1, 17, 1, 5, 1, 64, 2, 5, 109, 111, 100, 101, 108, 11, 4, 116, 101, 120, 116, 21, 0, 22, 4, 0, 19, 103, 101, 110, 101, 114, 97, 116, 101, 45, 101, 109, 98, 101, 100, 100, 105, 110, 103, 115, 1, 23, 3, 1, 16, 102, 101, 114, 109, 121, 111, 110, 58, 115, 112, 105, 110, 47, 108, 108, 109, 5, 18, 1, 66, 21, 4, 0, 10, 99, 111, 110, 110, 101, 99, 116, 105, 111, 110, 3, 1, 1, 113, 5, 16, 110, 111, 45, 115, 117, 99, 104, 45, 100, 97, 116, 97, 98, 97, 115, 101, 0, 0, 13, 97, 99, 99, 101, 115, 115, 45, 100, 101, 110, 105, 101, 100, 0, 0, 18, 105, 110, 118, 97, 108, 105, 100, 45, 99, 111, 110, 110, 101, 99, 116, 105, 111, 110, 0, 0, 13, 100, 97, 116, 97, 98, 97, 115, 101, 45, 102, 117, 108, 108, 0, 0, 2, 105, 111, 1, 115, 0, 4, 0, 5, 101, 114, 114, 111, 114, 3, 0, 1, 1, 112, 125, 1, 113, 5, 7, 105, 110, 116, 101, 103, 101, 114, 1, 120, 0, 4, 114, 101, 97, 108, 1, 117, 0, 4, 116, 101, 120, 116, 1, 115, 0, 4, 98, 108, 111, 98, 1, 3, 0, 4, 110, 117, 108, 108, 0, 0, 4, 0, 5, 118, 97, 108, 117, 101, 3, 0, 4, 1, 112, 5, 1, 114, 1, 6, 118, 97, 108, 117, 101, 115, 6, 4, 0, 10, 114, 111, 119, 45, 114, 101, 115, 117, 108, 116, 3, 0, 7, 1, 112, 115, 1, 112, 8, 1, 114, 2, 7, 99, 111, 108, 117, 109, 110, 115, 9, 4, 114, 111, 119, 115, 10, 4, 0, 12, 113, 117, 101, 114, 121, 45, 114, 101, 115, 117, 108, 116, 3, 0, 11, 1, 105, 0, 1, 106, 1, 13, 1, 2, 1, 64, 1, 8, 100, 97, 116, 97, 98, 97, 115, 101, 115, 0, 14, 4, 0, 23, 91, 115, 116, 97, 116, 105, 99, 93, 99, 111, 110, 110, 101, 99, 116, 105, 111, 110, 46, 111, 112, 101, 110, 1, 15, 1, 104, 0, 1, 106, 1, 12, 1, 2, 1, 64, 3, 4, 115, 101, 108, 102, 16, 9, 115, 116, 97, 116, 101, 109, 101, 110, 116, 115, 10, 112, 97, 114, 97, 109, 101, 116, 101, 114, 115, 6, 0, 17, 4, 0, 26, 91, 109, 101, 116, 104, 111, 100, 93, 99, 111, 110, 110, 101, 99, 116, 105, 111, 110, 46, 101, 120, 101, 99, 117, 116, 101, 1, 18, 3, 1, 25, 102, 101, 114, 109, 121, 111, 110, 58, 115, 112, 105, 110, 47, 115, 113, 108, 105, 116, 101, 64, 50, 46, 48, 46, 48, 5, 19, 1, 66, 24, 4, 0, 5, 115, 116, 111, 114, 101, 3, 1, 1, 113, 6, 16, 115, 116, 111, 114, 101, 45, 116, 97, 98, 108, 101, 45, 102, 117, 108, 108, 0, 0, 13, 110, 111, 45, 115, 117, 99, 104, 45, 115, 116, 111, 114, 101, 0, 0, 13, 97, 99, 99, 101, 115, 115, 45, 100, 101, 110, 105, 101, 100, 0, 0, 13, 105, 110, 118, 97, 108, 105, 100, 45, 115, 116, 111, 114, 101, 0, 0, 11, 110, 111, 45, 115, 117, 99, 104, 45, 107, 101, 121, 0, 0, 2, 105, 111, 1, 115, 0, 4, 0, 5, 101, 114, 114, 111, 114, 3, 0, 1, 1, 105, 0, 1, 106, 1, 3, 1, 2, 1, 64, 1, 4, 110, 97, 109, 101, 115, 0, 4, 4, 0, 18, 91, 115, 116, 97, 116, 105, 99, 93, 115, 116, 111, 114, 101, 46, 111, 112, 101, 110, 1, 5, 1, 104, 0, 1, 112, 125, 1, 106, 1, 7, 1, 2, 1, 64, 2, 4, 115, 101, 108, 102, 6, 3, 107, 101, 121, 115, 0, 8, 4, 0, 17, 91, 109, 101, 116, 104, 111, 100, 93, 115, 116, 111, 114, 101, 46, 103, 101, 116, 1, 9, 1, 106, 0, 1, 2, 1, 64, 3, 4, 115, 101, 108, 102, 6, 3, 107, 101, 121, 115, 5, 118, 97, 108, 117, 101, 7, 0, 10, 4, 0, 17, 91, 109, 101, 116, 104, 111, 100, 93, 115, 116, 111, 114, 101, 46, 115, 101, 116, 1, 11, 1, 64, 2, 4, 115, 101, 108, 102, 6, 3, 107, 101, 121, 115, 0, 10, 4, 0, 20, 91, 109, 101, 116, 104, 111, 100, 93, 115, 116, 111, 114, 101, 46, 100, 101, 108, 101, 116, 101, 1, 12, 1, 106, 1, 127, 1, 2, 1, 64, 2, 4, 115, 101, 108, 102, 6, 3, 107, 101, 121, 115, 0, 13, 4, 0, 20, 91, 109, 101, 116, 104, 111, 100, 93, 115, 116, 111, 114, 101, 46, 101, 120, 105, 115, 116, 115, 1, 14, 1, 112, 115, 1, 106, 1, 15, 1, 2, 1, 64, 1, 4, 115, 101, 108, 102, 6, 0, 16, 4, 0, 22, 91, 109, 101, 116, 104, 111, 100, 93, 115, 116, 111, 114, 101, 46, 103, 101, 116, 45, 107, 101, 121, 115, 1, 17, 3, 1, 28, 102, 101, 114, 109, 121, 111, 110, 58, 115, 112, 105, 110, 47, 107, 101, 121, 45, 118, 97, 108, 117, 101, 64, 50, 46, 48, 46, 48, 5, 20, 1, 66, 6, 2, 3, 2, 1, 3, 4, 0, 7, 114, 101, 113, 117, 101, 115, 116, 3, 0, 0, 2, 3, 2, 1, 4, 4, 0, 8, 114, 101, 115, 112, 111, 110, 115, 101, 3, 0, 2, 1, 64, 1, 3, 114, 101, 113, 1, 0, 3, 4, 0, 14, 104, 97, 110, 100, 108, 101, 45, 114, 101, 113, 117, 101, 115, 116, 1, 4, 4, 1, 25, 102, 101, 114, 109, 121, 111, 110, 58, 115, 112, 105, 110, 47, 105, 110, 98, 111, 117, 110, 100, 45, 104, 116, 116, 112, 5, 21, 4, 1, 31, 102, 101, 114, 109, 121, 111, 110, 58, 115, 112, 105, 110, 47, 104, 116, 116, 112, 45, 116, 114, 105, 103, 103, 101, 114, 64, 50, 46, 48, 46, 48, 4, 5, 11, 28, 1, 1, 22, 102, 101, 114, 109, 121, 111, 110, 58, 115, 112, 105, 110, 47, 119, 105, 116, 64, 50, 46, 48, 46, 48, 3, 0, 0, 0, 130, 28, 12, 112, 97, 99, 107, 97, 103, 101, 45, 100, 111, 99, 115, 0, 123, 34, 105, 110, 116, 101, 114, 102, 97, 99, 101, 115, 34, 58, 123, 34, 107, 101, 121, 45, 118, 97, 108, 117, 101, 34, 58, 123, 34, 102, 117, 110, 99, 115, 34, 58, 123, 34, 91, 115, 116, 97, 116, 105, 99, 93, 115, 116, 111, 114, 101, 46, 111, 112, 101, 110, 34, 58, 34, 79, 112, 101, 110, 32, 116, 104, 101, 32, 115, 116, 111, 114, 101, 32, 119, 105, 116, 104, 32, 116, 104, 101, 32, 115, 112, 101, 99, 105, 102, 105, 101, 100, 32, 110, 97, 109, 101, 46, 92, 110, 92, 110, 73, 102, 32, 96, 110, 97, 109, 101, 96, 32, 105, 115, 32, 92, 34, 100, 101, 102, 97, 117, 108, 116, 92, 34, 44, 32, 116, 104, 101, 32, 100, 101, 102, 97, 117, 108, 116, 32, 115, 116, 111, 114, 101, 32, 105, 115, 32, 111, 112, 101, 110, 101, 100, 46, 32, 32, 79, 116, 104, 101, 114, 119, 105, 115, 101, 44, 92, 110, 96, 110, 97, 109, 101, 96, 32, 109, 117, 115, 116, 32, 114, 101, 102, 101, 114, 32, 116, 111, 32, 97, 32, 115, 116, 111, 114, 101, 32, 100, 101, 102, 105, 110, 101, 100, 32, 97, 110, 100, 32, 99, 111, 110, 102, 105, 103, 117, 114, 101, 100, 32, 105, 110, 32, 97, 32, 114, 117, 110, 116, 105, 109, 101, 92, 110, 99, 111, 110, 102, 105, 103, 117, 114, 97, 116, 105, 111, 110, 32, 102, 105, 108, 101, 32, 115, 117, 112, 112, 108, 105, 101, 100, 32, 119, 105, 116, 104, 32, 116, 104, 101, 32, 97, 112, 112, 108, 105, 99, 97, 116, 105, 111, 110, 46, 92, 110, 92, 110, 96, 101, 114, 114, 111, 114, 58, 58, 110, 111, 45, 115, 117, 99, 104, 45, 115, 116, 111, 114, 101, 96, 32, 119, 105, 108, 108, 32, 98, 101, 32, 114, 97, 105, 115, 101, 100, 32, 105, 102, 32, 116, 104, 101, 32, 96, 110, 97, 109, 101, 96, 32, 105, 115, 32, 110, 111, 116, 32, 114, 101, 99, 111, 103, 110, 105, 122, 101, 100, 46, 34, 44, 34, 91, 109, 101, 116, 104, 111, 100, 93, 115, 116, 111, 114, 101, 46, 103, 101, 116, 34, 58, 34, 71, 101, 116, 32, 116, 104, 101, 32, 118, 97, 108, 117, 101, 32, 97, 115, 115, 111, 99, 105, 97, 116, 101, 100, 32, 119, 105, 116, 104, 32, 116, 104, 101, 32, 115, 112, 101, 99, 105, 102, 105, 101, 100, 32, 96, 107, 101, 121, 96, 32, 102, 114, 111, 109, 32, 116, 104, 101, 32, 115, 112, 101, 99, 105, 102, 105, 101, 100, 92, 110, 96, 115, 116, 111, 114, 101, 96, 46, 92, 110, 92, 110, 96, 101, 114, 114, 111, 114, 58, 58, 105, 110, 118, 97, 108, 105, 100, 45, 115, 116, 111, 114, 101, 96, 32, 119, 105, 108, 108, 32, 98, 101, 32, 114, 97, 105, 115, 101, 100, 32, 105, 102, 32, 96, 115, 116, 111, 114, 101, 96, 32, 105, 115, 32, 110, 111, 116, 32, 97, 32, 118, 97, 108, 105, 100, 32, 104, 97, 110, 100, 108, 101, 92, 110, 116, 111, 32, 97, 110, 32, 111, 112, 101, 110, 32, 115, 116, 111, 114, 101, 44, 32, 97, 110, 100, 32, 96, 101, 114, 114, 111, 114, 58, 58, 110, 111, 45, 115, 117, 99, 104, 45, 107, 101, 121, 96, 32, 119, 105, 108, 108, 32, 98, 101, 32, 114, 97, 105, 115, 101, 100, 32, 105, 102, 32, 116, 104, 101, 114, 101, 32, 105, 115, 32, 110, 111, 92, 110, 116, 117, 112, 108, 101, 32, 102, 111, 114, 32, 96, 107, 101, 121, 96, 32, 105, 110, 32, 96, 115, 116, 111, 114, 101, 96, 46, 34, 44, 34, 91, 109, 101, 116, 104, 111, 100, 93, 115, 116, 111, 114, 101, 46, 115, 101, 116, 34, 58, 34, 83, 101, 116, 32, 116, 104, 101, 32, 96, 118, 97, 108, 117, 101, 96, 32, 97, 115, 115, 111, 99, 105, 97, 116, 101, 100, 32, 119, 105, 116, 104, 32, 116, 104, 101, 32, 115, 112, 101, 99, 105, 102, 105, 101, 100, 32, 96, 107, 101, 121, 96, 32, 105, 110, 32, 116, 104, 101, 32, 115, 112, 101, 99, 105, 102, 105, 101, 100, 92, 110, 96, 115, 116, 111, 114, 101, 96, 44, 32, 111, 118, 101, 114, 119, 114, 105, 116, 105, 110, 103, 32, 97, 110, 121, 32, 101, 120, 105, 115, 116, 105, 110, 103, 32, 118, 97, 108, 117, 101, 46, 92, 110, 92, 110, 96, 101, 114, 114, 111, 114, 58, 58, 105, 110, 118, 97, 108, 105, 100, 45, 115, 116, 111, 114, 101, 96, 32, 119, 105, 108, 108, 32, 98, 101, 32, 114, 97, 105, 115, 101, 100, 32, 105, 102, 32, 96, 115, 116, 111, 114, 101, 96, 32, 105, 115, 32, 110, 111, 116, 32, 97, 32, 118, 97, 108, 105, 100, 32, 104, 97, 110, 100, 108, 101, 92, 110, 116, 111, 32, 97, 110, 32, 111, 112, 101, 110, 32, 115, 116, 111, 114, 101, 46, 34, 44, 34, 91, 109, 101, 116, 104, 111, 100, 93, 115, 116, 111, 114, 101, 46, 100, 101, 108, 101, 116, 101, 34, 58, 34, 68, 101, 108, 101, 116, 101, 32, 116, 104, 101, 32, 116, 117, 112, 108, 101, 32, 119, 105, 116, 104, 32, 116, 104, 101, 32, 115, 112, 101, 99, 105, 102, 105, 101, 100, 32, 96, 107, 101, 121, 96, 32, 102, 114, 111, 109, 32, 116, 104, 101, 32, 115, 112, 101, 99, 105, 102, 105, 101, 100, 32, 96, 115, 116, 111, 114, 101, 96, 46, 92, 110, 92, 110, 96, 101, 114, 114, 111, 114, 58, 58, 105, 110, 118, 97, 108, 105, 100, 45, 115, 116, 111, 114, 101, 96, 32, 119, 105, 108, 108, 32, 98, 101, 32, 114, 97, 105, 115, 101, 100, 32, 105, 102, 32, 96, 115, 116, 111, 114, 101, 96, 32, 105, 115, 32, 110, 111, 116, 32, 97, 32, 118, 97, 108, 105, 100, 32, 104, 97, 110, 100, 108, 101, 92, 110, 116, 111, 32, 97, 110, 32, 111, 112, 101, 110, 32, 115, 116, 111, 114, 101, 46, 32, 32, 78, 111, 32, 101, 114, 114, 111, 114, 32, 105, 115, 32, 114, 97, 105, 115, 101, 100, 32, 105, 102, 32, 97, 32, 116, 117, 112, 108, 101, 32, 100, 105, 100, 32, 110, 111, 116, 32, 112, 114, 101, 118, 105, 111, 117, 115, 108, 121, 92, 110, 101, 120, 105, 115, 116, 32, 102, 111, 114, 32, 96, 107, 101, 121, 96, 46, 34, 44, 34, 91, 109, 101, 116, 104, 111, 100, 93, 115, 116, 111, 114, 101, 46, 101, 120, 105, 115, 116, 115, 34, 58, 34, 82, 101, 116, 117, 114, 110, 32, 119, 104, 101, 116, 104, 101, 114, 32, 97, 32, 116, 117, 112, 108, 101, 32, 101, 120, 105, 115, 116, 115, 32, 102, 111, 114, 32, 116, 104, 101, 32, 115, 112, 101, 99, 105, 102, 105, 101, 100, 32, 96, 107, 101, 121, 96, 32, 105, 110, 32, 116, 104, 101, 32, 115, 112, 101, 99, 105, 102, 105, 101, 100, 92, 110, 96, 115, 116, 111, 114, 101, 96, 46, 92, 110, 92, 110, 96, 101, 114, 114, 111, 114, 58, 58, 105, 110, 118, 97, 108, 105, 100, 45, 115, 116, 111, 114, 101, 96, 32, 119, 105, 108, 108, 32, 98, 101, 32, 114, 97, 105, 115, 101, 100, 32, 105, 102, 32, 96, 115, 116, 111, 114, 101, 96, 32, 105, 115, 32, 110, 111, 116, 32, 97, 32, 118, 97, 108, 105, 100, 32, 104, 97, 110, 100, 108, 101, 92, 110, 116, 111, 32, 97, 110, 32, 111, 112, 101, 110, 32, 115, 116, 111, 114, 101, 46, 34, 44, 34, 91, 109, 101, 116, 104, 111, 100, 93, 115, 116, 111, 114, 101, 46, 103, 101, 116, 45, 107, 101, 121, 115, 34, 58, 34, 82, 101, 116, 117, 114, 110, 32, 97, 32, 108, 105, 115, 116, 32, 111, 102, 32, 97, 108, 108, 32, 116, 104, 101, 32, 107, 101, 121, 115, 32, 105, 110, 32, 116, 104, 101, 32, 115, 112, 101, 99, 105, 102, 105, 101, 100, 32, 96, 115, 116, 111, 114, 101, 96, 46, 92, 110, 92, 110, 96, 101, 114, 114, 111, 114, 58, 58, 105, 110, 118, 97, 108, 105, 100, 45, 115, 116, 111, 114, 101, 96, 32, 119, 105, 108, 108, 32, 98, 101, 32, 114, 97, 105, 115, 101, 100, 32, 105, 102, 32, 96, 115, 116, 111, 114, 101, 96, 32, 105, 115, 32, 110, 111, 116, 32, 97, 32, 118, 97, 108, 105, 100, 32, 104, 97, 110, 100, 108, 101, 92, 110, 116, 111, 32, 97, 110, 32, 111, 112, 101, 110, 32, 115, 116, 111, 114, 101, 46, 34, 125, 44, 34, 116, 121, 112, 101, 115, 34, 58, 123, 34, 115, 116, 111, 114, 101, 34, 58, 123, 34, 100, 111, 99, 115, 34, 58, 34, 65, 110, 32, 111, 112, 101, 110, 32, 107, 101, 121, 45, 118, 97, 108, 117, 101, 32, 115, 116, 111, 114, 101, 34, 125, 44, 34, 101, 114, 114, 111, 114, 34, 58, 123, 34, 100, 111, 99, 115, 34, 58, 34, 84, 104, 101, 32, 115, 101, 116, 32, 111, 102, 32, 101, 114, 114, 111, 114, 115, 32, 119, 104, 105, 99, 104, 32, 109, 97, 121, 32, 98, 101, 32, 114, 97, 105, 115, 101, 100, 32, 98, 121, 32, 102, 117, 110, 99, 116, 105, 111, 110, 115, 32, 105, 110, 32, 116, 104, 105, 115, 32, 105, 110, 116, 101, 114, 102, 97, 99, 101, 34, 44, 34, 105, 116, 101, 109, 115, 34, 58, 123, 34, 115, 116, 111, 114, 101, 45, 116, 97, 98, 108, 101, 45, 102, 117, 108, 108, 34, 58, 34, 84, 111, 111, 32, 109, 97, 110, 121, 32, 115, 116, 111, 114, 101, 115, 32, 104, 97, 118, 101, 32, 98, 101, 101, 110, 32, 111, 112, 101, 110, 101, 100, 32, 115, 105, 109, 117, 108, 116, 97, 110, 101, 111, 117, 115, 108, 121, 46, 32, 67, 108, 111, 115, 105, 110, 103, 32, 111, 110, 101, 32, 111, 114, 32, 109, 111, 114, 101, 92, 110, 115, 116, 111, 114, 101, 115, 32, 112, 114, 105, 111, 114, 32, 116, 111, 32, 114, 101, 116, 114, 121, 105, 110, 103, 32, 109, 97, 121, 32, 97, 100, 100, 114, 101, 115, 115, 32, 116, 104, 105, 115, 46, 34, 44, 34, 110, 111, 45, 115, 117, 99, 104, 45, 115, 116, 111, 114, 101, 34, 58, 34, 84, 104, 101, 32, 104, 111, 115, 116, 32, 100, 111, 101, 115, 32, 110, 111, 116, 32, 114, 101, 99, 111, 103, 110, 105, 122, 101, 32, 116, 104, 101, 32, 115, 116, 111, 114, 101, 32, 110, 97, 109, 101, 32, 114, 101, 113, 117, 101, 115, 116, 101, 100, 46, 32, 32, 68, 101, 102, 105, 110, 105, 110, 103, 32, 97, 110, 100, 92, 110, 99, 111, 110, 102, 105, 103, 117, 114, 105, 110, 103, 32, 97, 32, 115, 116, 111, 114, 101, 32, 119, 105, 116, 104, 32, 116, 104, 97, 116, 32, 110, 97, 109, 101, 32, 105, 110, 32, 97, 32, 114, 117, 110, 116, 105, 109, 101, 32, 99, 111, 110, 102, 105, 103, 117, 114, 97, 116, 105, 111, 110, 32, 102, 105, 108, 101, 92, 110, 109, 97, 121, 32, 97, 100, 100, 114, 101, 115, 115, 32, 116, 104, 105, 115, 46, 34, 44, 34, 97, 99, 99, 101, 115, 115, 45, 100, 101, 110, 105, 101, 100, 34, 58, 34, 84, 104, 101, 32, 114, 101, 113, 117, 101, 115, 116, 105, 110, 103, 32, 99, 111, 109, 112, 111, 110, 101, 110, 116, 32, 100, 111, 101, 115, 32, 110, 111, 116, 32, 104, 97, 118, 101, 32, 97, 99, 99, 101, 115, 115, 32, 116, 111, 32, 116, 104, 101, 32, 115, 112, 101, 99, 105, 102, 105, 101, 100, 32, 115, 116, 111, 114, 101, 92, 110, 40, 119, 104, 105, 99, 104, 32, 109, 97, 121, 32, 111, 114, 32, 109, 97, 121, 32, 110, 111, 116, 32, 101, 120, 105, 115, 116, 41, 46, 34, 44, 34, 105, 110, 118, 97, 108, 105, 100, 45, 115, 116, 111, 114, 101, 34, 58, 34, 84, 104, 101, 32, 115, 116, 111, 114, 101, 32, 104, 97, 110, 100, 108, 101, 32, 112, 114, 111, 118, 105, 100, 101, 100, 32, 105, 115, 32, 110, 111, 116, 32, 114, 101, 99, 111, 103, 110, 105, 122, 101, 100, 44, 32, 105, 46, 101, 46, 32, 105, 116, 32, 119, 97, 115, 32, 101, 105, 116, 104, 101, 114, 32, 110, 101, 118, 101, 114, 92, 110, 111, 112, 101, 110, 101, 100, 32, 111, 114, 32, 104, 97, 115, 32, 98, 101, 101, 110, 32, 99, 108, 111, 115, 101, 100, 46, 34, 44, 34, 110, 111, 45, 115, 117, 99, 104, 45, 107, 101, 121, 34, 58, 34, 78, 111, 32, 107, 101, 121, 45, 118, 97, 108, 117, 101, 32, 116, 117, 112, 108, 101, 32, 101, 120, 105, 115, 116, 115, 32, 102, 111, 114, 32, 116, 104, 101, 32, 115, 112, 101, 99, 105, 102, 105, 101, 100, 32, 107, 101, 121, 32, 105, 110, 32, 116, 104, 101, 32, 115, 112, 101, 99, 105, 102, 105, 101, 100, 92, 110, 115, 116, 111, 114, 101, 46, 34, 44, 34, 105, 111, 34, 58, 34, 83, 111, 109, 101, 32, 105, 109, 112, 108, 101, 109, 101, 110, 116, 97, 116, 105, 111, 110, 45, 115, 112, 101, 99, 105, 102, 105, 99, 32, 101, 114, 114, 111, 114, 32, 104, 97, 115, 32, 111, 99, 99, 117, 114, 114, 101, 100, 32, 40, 101, 46, 103, 46, 32, 73, 47, 79, 41, 34, 125, 125, 125, 125, 44, 34, 115, 113, 108, 105, 116, 101, 34, 58, 123, 34, 102, 117, 110, 99, 115, 34, 58, 123, 34, 91, 115, 116, 97, 116, 105, 99, 93, 99, 111, 110, 110, 101, 99, 116, 105, 111, 110, 46, 111, 112, 101, 110, 34, 58, 34, 79, 112, 101, 110, 32, 97, 32, 99, 111, 110, 110, 101, 99, 116, 105, 111, 110, 32, 116, 111, 32, 97, 32, 110, 97, 109, 101, 100, 32, 100, 97, 116, 97, 98, 97, 115, 101, 32, 105, 110, 115, 116, 97, 110, 99, 101, 46, 92, 110, 92, 110, 73, 102, 32, 96, 100, 97, 116, 97, 98, 97, 115, 101, 96, 32, 105, 115, 32, 92, 34, 100, 101, 102, 97, 117, 108, 116, 92, 34, 44, 32, 116, 104, 101, 32, 100, 101, 102, 97, 117, 108, 116, 32, 105, 110, 115, 116, 97, 110, 99, 101, 32, 105, 115, 32, 111, 112, 101, 110, 101, 100, 46, 92, 110, 92, 110, 96, 101, 114, 114, 111, 114, 58, 58, 110, 111, 45, 115, 117, 99, 104, 45, 100, 97, 116, 97, 98, 97, 115, 101, 96, 32, 119, 105, 108, 108, 32, 98, 101, 32, 114, 97, 105, 115, 101, 100, 32, 105, 102, 32, 116, 104, 101, 32, 96, 110, 97, 109, 101, 96, 32, 105, 115, 32, 110, 111, 116, 32, 114, 101, 99, 111, 103, 110, 105, 122, 101, 100, 46, 34, 44, 34, 91, 109, 101, 116, 104, 111, 100, 93, 99, 111, 110, 110, 101, 99, 116, 105, 111, 110, 46, 101, 120, 101, 99, 117, 116, 101, 34, 58, 34, 69, 120, 101, 99, 117, 116, 101, 32, 97, 32, 115, 116, 97, 116, 101, 109, 101, 110, 116, 32, 114, 101, 116, 117, 114, 110, 105, 110, 103, 32, 98, 97, 99, 107, 32, 100, 97, 116, 97, 32, 105, 102, 32, 116, 104, 101, 114, 101, 32, 105, 115, 32, 97, 110, 121, 34, 125, 44, 34, 116, 121, 112, 101, 115, 34, 58, 123, 34, 99, 111, 110, 110, 101, 99, 116, 105, 111, 110, 34, 58, 123, 34, 100, 111, 99, 115, 34, 58, 34, 65, 32, 104, 97, 110, 100, 108, 101, 32, 116, 111, 32, 97, 110, 32, 111, 112, 101, 110, 32, 115, 113, 108, 105, 116, 101, 32, 105, 110, 115, 116, 97, 110, 99, 101, 34, 125, 44, 34, 101, 114, 114, 111, 114, 34, 58, 123, 34, 100, 111, 99, 115, 34, 58, 34, 84, 104, 101, 32, 115, 101, 116, 32, 111, 102, 32, 101, 114, 114, 111, 114, 115, 32, 119, 104, 105, 99, 104, 32, 109, 97, 121, 32, 98, 101, 32, 114, 97, 105, 115, 101, 100, 32, 98, 121, 32, 102, 117, 110, 99, 116, 105, 111, 110, 115, 32, 105, 110, 32, 116, 104, 105, 115, 32, 105, 110, 116, 101, 114, 102, 97, 99, 101, 34, 44, 34, 105, 116, 101, 109, 115, 34, 58, 123, 34, 110, 111, 45, 115, 117, 99, 104, 45, 100, 97, 116, 97, 98, 97, 115, 101, 34, 58, 34, 84, 104, 101, 32, 104, 111, 115, 116, 32, 100, 111, 101, 115, 32, 110, 111, 116, 32, 114, 101, 99, 111, 103, 110, 105, 122, 101, 32, 116, 104, 101, 32, 100, 97, 116, 97, 98, 97, 115, 101, 32, 110, 97, 109, 101, 32, 114, 101, 113, 117, 101, 115, 116, 101, 100, 46, 34, 44, 34, 97, 99, 99, 101, 115, 115, 45, 100, 101, 110, 105, 101, 100, 34, 58, 34, 84, 104, 101, 32, 114, 101, 113, 117, 101, 115, 116, 105, 110, 103, 32, 99, 111, 109, 112, 111, 110, 101, 110, 116, 32, 100, 111, 101, 115, 32, 110, 111, 116, 32, 104, 97, 118, 101, 32, 97, 99, 99, 101, 115, 115, 32, 116, 111, 32, 116, 104, 101, 32, 115, 112, 101, 99, 105, 102, 105, 101, 100, 32, 100, 97, 116, 97, 98, 97, 115, 101, 32, 40, 119, 104, 105, 99, 104, 32, 109, 97, 121, 32, 111, 114, 32, 109, 97, 121, 32, 110, 111, 116, 32, 101, 120, 105, 115, 116, 41, 46, 34, 44, 34, 105, 110, 118, 97, 108, 105, 100, 45, 99, 111, 110, 110, 101, 99, 116, 105, 111, 110, 34, 58, 34, 84, 104, 101, 32, 112, 114, 111, 118, 105, 100, 101, 100, 32, 99, 111, 110, 110, 101, 99, 116, 105, 111, 110, 32, 105, 115, 32, 110, 111, 116, 32, 118, 97, 108, 105, 100, 34, 44, 34, 100, 97, 116, 97, 98, 97, 115, 101, 45, 102, 117, 108, 108, 34, 58, 34, 84, 104, 101, 32, 100, 97, 116, 97, 98, 97, 115, 101, 32, 104, 97, 115, 32, 114, 101, 97, 99, 104, 101, 100, 32, 105, 116, 115, 32, 99, 97, 112, 97, 99, 105, 116, 121, 34, 44, 34, 105, 111, 34, 58, 34, 83, 111, 109, 101, 32, 105, 109, 112, 108, 101, 109, 101, 110, 116, 97, 116, 105, 111, 110, 45, 115, 112, 101, 99, 105, 102, 105, 99, 32, 101, 114, 114, 111, 114, 32, 104, 97, 115, 32, 111, 99, 99, 117, 114, 114, 101, 100, 32, 40, 101, 46, 103, 46, 32, 73, 47, 79, 41, 34, 125, 125, 44, 34, 118, 97, 108, 117, 101, 34, 58, 123, 34, 100, 111, 99, 115, 34, 58, 34, 65, 32, 115, 105, 110, 103, 108, 101, 32, 99, 111, 108, 117, 109, 110, 39, 115, 32, 114, 101, 115, 117, 108, 116, 32, 102, 114, 111, 109, 32, 97, 32, 100, 97, 116, 97, 98, 97, 115, 101, 32, 113, 117, 101, 114, 121, 34, 125, 44, 34, 114, 111, 119, 45, 114, 101, 115, 117, 108, 116, 34, 58, 123, 34, 100, 111, 99, 115, 34, 58, 34, 65, 32, 115, 101, 116, 32, 111, 102, 32, 118, 97, 108, 117, 101, 115, 32, 102, 111, 114, 32, 101, 97, 99, 104, 32, 111, 102, 32, 116, 104, 101, 32, 99, 111, 108, 117, 109, 110, 115, 32, 105, 110, 32, 97, 32, 113, 117, 101, 114, 121, 45, 114, 101, 115, 117, 108, 116, 34, 125, 44, 34, 113, 117, 101, 114, 121, 45, 114, 101, 115, 117, 108, 116, 34, 58, 123, 34, 100, 111, 99, 115, 34, 58, 34, 65, 32, 114, 101, 115, 117, 108, 116, 32, 111, 102, 32, 97, 32, 113, 117, 101, 114, 121, 34, 44, 34, 105, 116, 101, 109, 115, 34, 58, 123, 34, 99, 111, 108, 117, 109, 110, 115, 34, 58, 34, 84, 104, 101, 32, 110, 97, 109, 101, 115, 32, 111, 102, 32, 116, 104, 101, 32, 99, 111, 108, 117, 109, 110, 115, 32, 114, 101, 116, 114, 105, 101, 118, 101, 100, 32, 105, 110, 32, 116, 104, 101, 32, 113, 117, 101, 114, 121, 34, 44, 34, 114, 111, 119, 115, 34, 58, 34, 116, 104, 101, 32, 114, 111, 119, 32, 114, 101, 115, 117, 108, 116, 115, 32, 101, 97, 99, 104, 32, 99, 111, 110, 116, 97, 105, 110, 105, 110, 103, 32, 116, 104, 101, 32, 118, 97, 108, 117, 101, 115, 32, 102, 111, 114, 32, 97, 108, 108, 32, 116, 104, 101, 32, 99, 111, 108, 117, 109, 110, 115, 32, 102, 111, 114, 32, 97, 32, 103, 105, 118, 101, 110, 32, 114, 111, 119, 34, 125, 125, 125, 125, 125, 125, 0, 70, 9, 112, 114, 111, 100, 117, 99, 101, 114, 115, 1, 12, 112, 114, 111, 99, 101, 115, 115, 101, 100, 45, 98, 121, 2, 13, 119, 105, 116, 45, 99, 111, 109, 112, 111, 110, 101, 110, 116, 6, 48, 46, 49, 52, 46, 53, 16, 119, 105, 116, 45, 98, 105, 110, 100, 103, 101, 110, 45, 114, 117, 115, 116, 6, 48, 46, 49, 50, 46, 48];

#[inline(never)]
#[doc(hidden)]
#[cfg(target_arch = "wasm32")]
pub fn __link_section() {}

#[derive(Debug)]
pub struct Stub;
impl exports::fermyon::spin::inbound_http::Guest for Stub {
  fn handle_request(req: exports::fermyon::spin::inbound_http::Request,) -> exports::fermyon::spin::inbound_http::Response{ unreachable!() }
}
