#![feature(prelude_import)]
#![allow(missing_docs)]
#[prelude_import]
use std::prelude::rust_2021::*;
#[macro_use]
extern crate std;
pub struct Host_ {
    interface0: exports::fermyon::spin::inbound_http::InboundHttp,
    interface1: exports::fermyon::spin::inbound_redis::InboundRedis,
}
const _: () = {
    use wasmtime::component::__internal::anyhow;
    impl Host_ {
        pub fn add_to_linker<T, U>(
            linker: &mut wasmtime::component::Linker<T>,
            get: impl Fn(&mut T) -> &mut U + Send + Sync + Copy + 'static,
        ) -> wasmtime::Result<()>
        where
            U: wasi::logging::logging::Host + fermyon::spin2_0_0::sqlite::Host
                + fermyon::spin2_0_0::key_value::Host + fermyon::spin::http_types::Host
                + fermyon::spin::redis_types::Host + fermyon::spin::config::Host
                + fermyon::spin::http::Host + fermyon::spin::rdbms_types::Host
                + fermyon::spin::postgres::Host + fermyon::spin::mysql::Host
                + fermyon::spin::sqlite::Host + fermyon::spin::redis::Host
                + fermyon::spin::key_value::Host + fermyon::spin::llm::Host + Send,
            T: Send,
        {
            wasi::logging::logging::add_to_linker(linker, get)?;
            fermyon::spin2_0_0::sqlite::add_to_linker(linker, get)?;
            fermyon::spin2_0_0::key_value::add_to_linker(linker, get)?;
            fermyon::spin::http_types::add_to_linker(linker, get)?;
            fermyon::spin::redis_types::add_to_linker(linker, get)?;
            fermyon::spin::config::add_to_linker(linker, get)?;
            fermyon::spin::http::add_to_linker(linker, get)?;
            fermyon::spin::rdbms_types::add_to_linker(linker, get)?;
            fermyon::spin::postgres::add_to_linker(linker, get)?;
            fermyon::spin::mysql::add_to_linker(linker, get)?;
            fermyon::spin::sqlite::add_to_linker(linker, get)?;
            fermyon::spin::redis::add_to_linker(linker, get)?;
            fermyon::spin::key_value::add_to_linker(linker, get)?;
            fermyon::spin::llm::add_to_linker(linker, get)?;
            Ok(())
        }
        /// Instantiates the provided `module` using the specified
        /// parameters, wrapping up the result in a structure that
        /// translates between wasm and the host.
        pub async fn instantiate_async<T: Send>(
            mut store: impl wasmtime::AsContextMut<Data = T>,
            component: &wasmtime::component::Component,
            linker: &wasmtime::component::Linker<T>,
        ) -> wasmtime::Result<(Self, wasmtime::component::Instance)> {
            let instance = linker.instantiate_async(&mut store, component).await?;
            Ok((Self::new(store, &instance)?, instance))
        }
        /// Instantiates a pre-instantiated module using the specified
        /// parameters, wrapping up the result in a structure that
        /// translates between wasm and the host.
        pub async fn instantiate_pre<T: Send>(
            mut store: impl wasmtime::AsContextMut<Data = T>,
            instance_pre: &wasmtime::component::InstancePre<T>,
        ) -> wasmtime::Result<(Self, wasmtime::component::Instance)> {
            let instance = instance_pre.instantiate_async(&mut store).await?;
            Ok((Self::new(store, &instance)?, instance))
        }
        /// Low-level creation wrapper for wrapping up the exports
        /// of the `instance` provided in this structure of wasm
        /// exports.
        ///
        /// This function will extract exports from the `instance`
        /// defined within `store` and wrap them all up in the
        /// returned structure which can be used to interact with
        /// the wasm module.
        pub fn new(
            mut store: impl wasmtime::AsContextMut,
            instance: &wasmtime::component::Instance,
        ) -> wasmtime::Result<Self> {
            let mut store = store.as_context_mut();
            let mut exports = instance.exports(&mut store);
            let mut __exports = exports.root();
            let interface0 = exports::fermyon::spin::inbound_http::InboundHttp::new(
                &mut __exports
                    .instance("fermyon:spin/inbound-http")
                    .ok_or_else(|| ::anyhow::__private::must_use({
                        let error = ::anyhow::__private::format_err(
                            format_args!(
                                "exported instance `fermyon:spin/inbound-http` not present",
                            ),
                        );
                        error
                    }))?,
            )?;
            let interface1 = exports::fermyon::spin::inbound_redis::InboundRedis::new(
                &mut __exports
                    .instance("fermyon:spin/inbound-redis")
                    .ok_or_else(|| ::anyhow::__private::must_use({
                        let error = ::anyhow::__private::format_err(
                            format_args!(
                                "exported instance `fermyon:spin/inbound-redis` not present",
                            ),
                        );
                        error
                    }))?,
            )?;
            Ok(Host_ { interface0, interface1 })
        }
        pub fn fermyon_spin_inbound_http(
            &self,
        ) -> &exports::fermyon::spin::inbound_http::InboundHttp {
            &self.interface0
        }
        pub fn fermyon_spin_inbound_redis(
            &self,
        ) -> &exports::fermyon::spin::inbound_redis::InboundRedis {
            &self.interface1
        }
    }
};
pub mod fermyon {
    pub mod spin {
        #[allow(clippy::all)]
        pub mod http_types {
            #[allow(unused_imports)]
            use wasmtime::component::__internal::anyhow;
            pub type HttpStatus = u16;
            const _: () = {
                if !(2 == <HttpStatus as wasmtime::component::ComponentType>::SIZE32) {
                    ::core::panicking::panic(
                        "assertion failed: 2 == <HttpStatus as wasmtime::component::ComponentType>::SIZE32",
                    )
                }
                if !(2 == <HttpStatus as wasmtime::component::ComponentType>::ALIGN32) {
                    ::core::panicking::panic(
                        "assertion failed: 2 == <HttpStatus as wasmtime::component::ComponentType>::ALIGN32",
                    )
                }
            };
            pub type Body = Vec<u8>;
            const _: () = {
                if !(8 == <Body as wasmtime::component::ComponentType>::SIZE32) {
                    ::core::panicking::panic(
                        "assertion failed: 8 == <Body as wasmtime::component::ComponentType>::SIZE32",
                    )
                }
                if !(4 == <Body as wasmtime::component::ComponentType>::ALIGN32) {
                    ::core::panicking::panic(
                        "assertion failed: 4 == <Body as wasmtime::component::ComponentType>::ALIGN32",
                    )
                }
            };
            pub type Headers = Vec<(String, String)>;
            const _: () = {
                if !(8 == <Headers as wasmtime::component::ComponentType>::SIZE32) {
                    ::core::panicking::panic(
                        "assertion failed: 8 == <Headers as wasmtime::component::ComponentType>::SIZE32",
                    )
                }
                if !(4 == <Headers as wasmtime::component::ComponentType>::ALIGN32) {
                    ::core::panicking::panic(
                        "assertion failed: 4 == <Headers as wasmtime::component::ComponentType>::ALIGN32",
                    )
                }
            };
            pub type Params = Vec<(String, String)>;
            const _: () = {
                if !(8 == <Params as wasmtime::component::ComponentType>::SIZE32) {
                    ::core::panicking::panic(
                        "assertion failed: 8 == <Params as wasmtime::component::ComponentType>::SIZE32",
                    )
                }
                if !(4 == <Params as wasmtime::component::ComponentType>::ALIGN32) {
                    ::core::panicking::panic(
                        "assertion failed: 4 == <Params as wasmtime::component::ComponentType>::ALIGN32",
                    )
                }
            };
            pub type Uri = String;
            const _: () = {
                if !(8 == <Uri as wasmtime::component::ComponentType>::SIZE32) {
                    ::core::panicking::panic(
                        "assertion failed: 8 == <Uri as wasmtime::component::ComponentType>::SIZE32",
                    )
                }
                if !(4 == <Uri as wasmtime::component::ComponentType>::ALIGN32) {
                    ::core::panicking::panic(
                        "assertion failed: 4 == <Uri as wasmtime::component::ComponentType>::ALIGN32",
                    )
                }
            };
            #[component(enum)]
            pub enum Method {
                #[component(name = "get")]
                Get,
                #[component(name = "post")]
                Post,
                #[component(name = "put")]
                Put,
                #[component(name = "delete")]
                Delete,
                #[component(name = "patch")]
                Patch,
                #[component(name = "head")]
                Head,
                #[component(name = "options")]
                Options,
            }
            #[automatically_derived]
            impl ::core::clone::Clone for Method {
                #[inline]
                fn clone(&self) -> Method {
                    *self
                }
            }
            #[automatically_derived]
            impl ::core::marker::Copy for Method {}
            #[automatically_derived]
            impl ::core::marker::StructuralPartialEq for Method {}
            #[automatically_derived]
            impl ::core::cmp::PartialEq for Method {
                #[inline]
                fn eq(&self, other: &Method) -> bool {
                    let __self_tag = ::core::intrinsics::discriminant_value(self);
                    let __arg1_tag = ::core::intrinsics::discriminant_value(other);
                    __self_tag == __arg1_tag
                }
            }
            #[automatically_derived]
            impl ::core::marker::StructuralEq for Method {}
            #[automatically_derived]
            impl ::core::cmp::Eq for Method {
                #[inline]
                #[doc(hidden)]
                #[no_coverage]
                fn assert_receiver_is_total_eq(&self) -> () {}
            }
            unsafe impl wasmtime::component::Lower for Method {
                #[inline]
                fn lower<T>(
                    &self,
                    cx: &mut wasmtime::component::__internal::LowerContext<'_, T>,
                    ty: wasmtime::component::__internal::InterfaceType,
                    dst: &mut std::mem::MaybeUninit<Self::Lower>,
                ) -> wasmtime::component::__internal::anyhow::Result<()> {
                    let ty = match ty {
                        wasmtime::component::__internal::InterfaceType::Enum(i) => {
                            &cx.types[i]
                        }
                        _ => wasmtime::component::__internal::bad_type_info(),
                    };
                    match self {
                        Self::Get => {
                            {
                                #[allow(unused_unsafe)]
                                {
                                    unsafe {
                                        use ::wasmtime::component::__internal::MaybeUninitExt;
                                        let m: &mut std::mem::MaybeUninit<_> = dst;
                                        m.map(|p| &raw mut (*p).tag)
                                    }
                                }
                            }
                                .write(wasmtime::ValRaw::u32(0u32));
                            unsafe {
                                wasmtime::component::__internal::lower_payload(
                                    {
                                        #[allow(unused_unsafe)]
                                        {
                                            unsafe {
                                                use ::wasmtime::component::__internal::MaybeUninitExt;
                                                let m: &mut std::mem::MaybeUninit<_> = dst;
                                                m.map(|p| &raw mut (*p).payload)
                                            }
                                        }
                                    },
                                    |payload| {
                                        #[allow(unused_unsafe)]
                                        {
                                            unsafe {
                                                use ::wasmtime::component::__internal::MaybeUninitExt;
                                                let m: &mut std::mem::MaybeUninit<_> = payload;
                                                m.map(|p| &raw mut (*p).Get)
                                            }
                                        }
                                    },
                                    |dst| Ok(()),
                                )
                            }
                        }
                        Self::Post => {
                            {
                                #[allow(unused_unsafe)]
                                {
                                    unsafe {
                                        use ::wasmtime::component::__internal::MaybeUninitExt;
                                        let m: &mut std::mem::MaybeUninit<_> = dst;
                                        m.map(|p| &raw mut (*p).tag)
                                    }
                                }
                            }
                                .write(wasmtime::ValRaw::u32(1u32));
                            unsafe {
                                wasmtime::component::__internal::lower_payload(
                                    {
                                        #[allow(unused_unsafe)]
                                        {
                                            unsafe {
                                                use ::wasmtime::component::__internal::MaybeUninitExt;
                                                let m: &mut std::mem::MaybeUninit<_> = dst;
                                                m.map(|p| &raw mut (*p).payload)
                                            }
                                        }
                                    },
                                    |payload| {
                                        #[allow(unused_unsafe)]
                                        {
                                            unsafe {
                                                use ::wasmtime::component::__internal::MaybeUninitExt;
                                                let m: &mut std::mem::MaybeUninit<_> = payload;
                                                m.map(|p| &raw mut (*p).Post)
                                            }
                                        }
                                    },
                                    |dst| Ok(()),
                                )
                            }
                        }
                        Self::Put => {
                            {
                                #[allow(unused_unsafe)]
                                {
                                    unsafe {
                                        use ::wasmtime::component::__internal::MaybeUninitExt;
                                        let m: &mut std::mem::MaybeUninit<_> = dst;
                                        m.map(|p| &raw mut (*p).tag)
                                    }
                                }
                            }
                                .write(wasmtime::ValRaw::u32(2u32));
                            unsafe {
                                wasmtime::component::__internal::lower_payload(
                                    {
                                        #[allow(unused_unsafe)]
                                        {
                                            unsafe {
                                                use ::wasmtime::component::__internal::MaybeUninitExt;
                                                let m: &mut std::mem::MaybeUninit<_> = dst;
                                                m.map(|p| &raw mut (*p).payload)
                                            }
                                        }
                                    },
                                    |payload| {
                                        #[allow(unused_unsafe)]
                                        {
                                            unsafe {
                                                use ::wasmtime::component::__internal::MaybeUninitExt;
                                                let m: &mut std::mem::MaybeUninit<_> = payload;
                                                m.map(|p| &raw mut (*p).Put)
                                            }
                                        }
                                    },
                                    |dst| Ok(()),
                                )
                            }
                        }
                        Self::Delete => {
                            {
                                #[allow(unused_unsafe)]
                                {
                                    unsafe {
                                        use ::wasmtime::component::__internal::MaybeUninitExt;
                                        let m: &mut std::mem::MaybeUninit<_> = dst;
                                        m.map(|p| &raw mut (*p).tag)
                                    }
                                }
                            }
                                .write(wasmtime::ValRaw::u32(3u32));
                            unsafe {
                                wasmtime::component::__internal::lower_payload(
                                    {
                                        #[allow(unused_unsafe)]
                                        {
                                            unsafe {
                                                use ::wasmtime::component::__internal::MaybeUninitExt;
                                                let m: &mut std::mem::MaybeUninit<_> = dst;
                                                m.map(|p| &raw mut (*p).payload)
                                            }
                                        }
                                    },
                                    |payload| {
                                        #[allow(unused_unsafe)]
                                        {
                                            unsafe {
                                                use ::wasmtime::component::__internal::MaybeUninitExt;
                                                let m: &mut std::mem::MaybeUninit<_> = payload;
                                                m.map(|p| &raw mut (*p).Delete)
                                            }
                                        }
                                    },
                                    |dst| Ok(()),
                                )
                            }
                        }
                        Self::Patch => {
                            {
                                #[allow(unused_unsafe)]
                                {
                                    unsafe {
                                        use ::wasmtime::component::__internal::MaybeUninitExt;
                                        let m: &mut std::mem::MaybeUninit<_> = dst;
                                        m.map(|p| &raw mut (*p).tag)
                                    }
                                }
                            }
                                .write(wasmtime::ValRaw::u32(4u32));
                            unsafe {
                                wasmtime::component::__internal::lower_payload(
                                    {
                                        #[allow(unused_unsafe)]
                                        {
                                            unsafe {
                                                use ::wasmtime::component::__internal::MaybeUninitExt;
                                                let m: &mut std::mem::MaybeUninit<_> = dst;
                                                m.map(|p| &raw mut (*p).payload)
                                            }
                                        }
                                    },
                                    |payload| {
                                        #[allow(unused_unsafe)]
                                        {
                                            unsafe {
                                                use ::wasmtime::component::__internal::MaybeUninitExt;
                                                let m: &mut std::mem::MaybeUninit<_> = payload;
                                                m.map(|p| &raw mut (*p).Patch)
                                            }
                                        }
                                    },
                                    |dst| Ok(()),
                                )
                            }
                        }
                        Self::Head => {
                            {
                                #[allow(unused_unsafe)]
                                {
                                    unsafe {
                                        use ::wasmtime::component::__internal::MaybeUninitExt;
                                        let m: &mut std::mem::MaybeUninit<_> = dst;
                                        m.map(|p| &raw mut (*p).tag)
                                    }
                                }
                            }
                                .write(wasmtime::ValRaw::u32(5u32));
                            unsafe {
                                wasmtime::component::__internal::lower_payload(
                                    {
                                        #[allow(unused_unsafe)]
                                        {
                                            unsafe {
                                                use ::wasmtime::component::__internal::MaybeUninitExt;
                                                let m: &mut std::mem::MaybeUninit<_> = dst;
                                                m.map(|p| &raw mut (*p).payload)
                                            }
                                        }
                                    },
                                    |payload| {
                                        #[allow(unused_unsafe)]
                                        {
                                            unsafe {
                                                use ::wasmtime::component::__internal::MaybeUninitExt;
                                                let m: &mut std::mem::MaybeUninit<_> = payload;
                                                m.map(|p| &raw mut (*p).Head)
                                            }
                                        }
                                    },
                                    |dst| Ok(()),
                                )
                            }
                        }
                        Self::Options => {
                            {
                                #[allow(unused_unsafe)]
                                {
                                    unsafe {
                                        use ::wasmtime::component::__internal::MaybeUninitExt;
                                        let m: &mut std::mem::MaybeUninit<_> = dst;
                                        m.map(|p| &raw mut (*p).tag)
                                    }
                                }
                            }
                                .write(wasmtime::ValRaw::u32(6u32));
                            unsafe {
                                wasmtime::component::__internal::lower_payload(
                                    {
                                        #[allow(unused_unsafe)]
                                        {
                                            unsafe {
                                                use ::wasmtime::component::__internal::MaybeUninitExt;
                                                let m: &mut std::mem::MaybeUninit<_> = dst;
                                                m.map(|p| &raw mut (*p).payload)
                                            }
                                        }
                                    },
                                    |payload| {
                                        #[allow(unused_unsafe)]
                                        {
                                            unsafe {
                                                use ::wasmtime::component::__internal::MaybeUninitExt;
                                                let m: &mut std::mem::MaybeUninit<_> = payload;
                                                m.map(|p| &raw mut (*p).Options)
                                            }
                                        }
                                    },
                                    |dst| Ok(()),
                                )
                            }
                        }
                    }
                }
                #[inline]
                fn store<T>(
                    &self,
                    cx: &mut wasmtime::component::__internal::LowerContext<'_, T>,
                    ty: wasmtime::component::__internal::InterfaceType,
                    mut offset: usize,
                ) -> wasmtime::component::__internal::anyhow::Result<()> {
                    let ty = match ty {
                        wasmtime::component::__internal::InterfaceType::Enum(i) => {
                            &cx.types[i]
                        }
                        _ => wasmtime::component::__internal::bad_type_info(),
                    };
                    if true {
                        if !(offset
                            % (<Self as wasmtime::component::ComponentType>::ALIGN32
                                as usize) == 0)
                        {
                            ::core::panicking::panic(
                                "assertion failed: offset % (<Self as wasmtime::component::ComponentType>::ALIGN32 as usize) == 0",
                            )
                        }
                    }
                    match self {
                        Self::Get => {
                            *cx.get::<1usize>(offset) = 0u8.to_le_bytes();
                            Ok(())
                        }
                        Self::Post => {
                            *cx.get::<1usize>(offset) = 1u8.to_le_bytes();
                            Ok(())
                        }
                        Self::Put => {
                            *cx.get::<1usize>(offset) = 2u8.to_le_bytes();
                            Ok(())
                        }
                        Self::Delete => {
                            *cx.get::<1usize>(offset) = 3u8.to_le_bytes();
                            Ok(())
                        }
                        Self::Patch => {
                            *cx.get::<1usize>(offset) = 4u8.to_le_bytes();
                            Ok(())
                        }
                        Self::Head => {
                            *cx.get::<1usize>(offset) = 5u8.to_le_bytes();
                            Ok(())
                        }
                        Self::Options => {
                            *cx.get::<1usize>(offset) = 6u8.to_le_bytes();
                            Ok(())
                        }
                    }
                }
            }
            unsafe impl wasmtime::component::Lift for Method {
                #[inline]
                fn lift(
                    cx: &mut wasmtime::component::__internal::LiftContext<'_>,
                    ty: wasmtime::component::__internal::InterfaceType,
                    src: &Self::Lower,
                ) -> wasmtime::component::__internal::anyhow::Result<Self> {
                    let ty = match ty {
                        wasmtime::component::__internal::InterfaceType::Enum(i) => {
                            &cx.types[i]
                        }
                        _ => wasmtime::component::__internal::bad_type_info(),
                    };
                    Ok(
                        match src.tag.get_u32() {
                            0u32 => Self::Get,
                            1u32 => Self::Post,
                            2u32 => Self::Put,
                            3u32 => Self::Delete,
                            4u32 => Self::Patch,
                            5u32 => Self::Head,
                            6u32 => Self::Options,
                            discrim => {
                                return ::anyhow::__private::Err(
                                    ::anyhow::Error::msg({
                                        let res = ::alloc::fmt::format(
                                            format_args!("unexpected discriminant: {0}", discrim),
                                        );
                                        res
                                    }),
                                );
                            }
                        },
                    )
                }
                #[inline]
                fn load(
                    cx: &mut wasmtime::component::__internal::LiftContext<'_>,
                    ty: wasmtime::component::__internal::InterfaceType,
                    bytes: &[u8],
                ) -> wasmtime::component::__internal::anyhow::Result<Self> {
                    let align = <Self as wasmtime::component::ComponentType>::ALIGN32;
                    if true {
                        if !((bytes.as_ptr() as usize) % (align as usize) == 0) {
                            ::core::panicking::panic(
                                "assertion failed: (bytes.as_ptr() as usize) % (align as usize) == 0",
                            )
                        }
                    }
                    let discrim = bytes[0];
                    let payload_offset = <Self as wasmtime::component::__internal::ComponentVariant>::PAYLOAD_OFFSET32;
                    let payload = &bytes[payload_offset..];
                    let ty = match ty {
                        wasmtime::component::__internal::InterfaceType::Enum(i) => {
                            &cx.types[i]
                        }
                        _ => wasmtime::component::__internal::bad_type_info(),
                    };
                    Ok(
                        match discrim {
                            0u8 => Self::Get,
                            1u8 => Self::Post,
                            2u8 => Self::Put,
                            3u8 => Self::Delete,
                            4u8 => Self::Patch,
                            5u8 => Self::Head,
                            6u8 => Self::Options,
                            discrim => {
                                return ::anyhow::__private::Err(
                                    ::anyhow::Error::msg({
                                        let res = ::alloc::fmt::format(
                                            format_args!("unexpected discriminant: {0}", discrim),
                                        );
                                        res
                                    }),
                                );
                            }
                        },
                    )
                }
            }
            const _: () = {
                #[doc(hidden)]
                #[repr(C)]
                pub struct LowerMethod {
                    tag: wasmtime::ValRaw,
                    payload: LowerPayloadMethod,
                }
                #[automatically_derived]
                impl ::core::clone::Clone for LowerMethod {
                    #[inline]
                    fn clone(&self) -> LowerMethod {
                        let _: ::core::clone::AssertParamIsClone<wasmtime::ValRaw>;
                        let _: ::core::clone::AssertParamIsClone<LowerPayloadMethod>;
                        *self
                    }
                }
                #[automatically_derived]
                impl ::core::marker::Copy for LowerMethod {}
                #[doc(hidden)]
                #[allow(non_snake_case)]
                #[repr(C)]
                union LowerPayloadMethod {
                    Get: [wasmtime::ValRaw; 0],
                    Post: [wasmtime::ValRaw; 0],
                    Put: [wasmtime::ValRaw; 0],
                    Delete: [wasmtime::ValRaw; 0],
                    Patch: [wasmtime::ValRaw; 0],
                    Head: [wasmtime::ValRaw; 0],
                    Options: [wasmtime::ValRaw; 0],
                }
                #[automatically_derived]
                #[allow(non_snake_case)]
                impl ::core::clone::Clone for LowerPayloadMethod {
                    #[inline]
                    fn clone(&self) -> LowerPayloadMethod {
                        let _: ::core::clone::AssertParamIsCopy<Self>;
                        *self
                    }
                }
                #[automatically_derived]
                #[allow(non_snake_case)]
                impl ::core::marker::Copy for LowerPayloadMethod {}
                unsafe impl wasmtime::component::ComponentType for Method {
                    type Lower = LowerMethod;
                    #[inline]
                    fn typecheck(
                        ty: &wasmtime::component::__internal::InterfaceType,
                        types: &wasmtime::component::__internal::InstanceType<'_>,
                    ) -> wasmtime::component::__internal::anyhow::Result<()> {
                        wasmtime::component::__internal::typecheck_enum(
                            ty,
                            types,
                            &["get", "post", "put", "delete", "patch", "head", "options"],
                        )
                    }
                    const ABI: wasmtime::component::__internal::CanonicalAbiInfo = wasmtime::component::__internal::CanonicalAbiInfo::variant_static(
                        &[None, None, None, None, None, None, None],
                    );
                }
                unsafe impl wasmtime::component::__internal::ComponentVariant
                for Method {
                    const CASES: &'static [Option<
                        wasmtime::component::__internal::CanonicalAbiInfo,
                    >] = &[None, None, None, None, None, None, None];
                }
            };
            impl core::fmt::Debug for Method {
                fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
                    match self {
                        Method::Get => f.debug_tuple("Method::Get").finish(),
                        Method::Post => f.debug_tuple("Method::Post").finish(),
                        Method::Put => f.debug_tuple("Method::Put").finish(),
                        Method::Delete => f.debug_tuple("Method::Delete").finish(),
                        Method::Patch => f.debug_tuple("Method::Patch").finish(),
                        Method::Head => f.debug_tuple("Method::Head").finish(),
                        Method::Options => f.debug_tuple("Method::Options").finish(),
                    }
                }
            }
            const _: () = {
                if !(1 == <Method as wasmtime::component::ComponentType>::SIZE32) {
                    ::core::panicking::panic(
                        "assertion failed: 1 == <Method as wasmtime::component::ComponentType>::SIZE32",
                    )
                }
                if !(1 == <Method as wasmtime::component::ComponentType>::ALIGN32) {
                    ::core::panicking::panic(
                        "assertion failed: 1 == <Method as wasmtime::component::ComponentType>::ALIGN32",
                    )
                }
            };
            #[component(record)]
            pub struct Request {
                #[component(name = "method")]
                pub method: Method,
                #[component(name = "uri")]
                pub uri: Uri,
                #[component(name = "headers")]
                pub headers: Headers,
                #[component(name = "params")]
                pub params: Params,
                #[component(name = "body")]
                pub body: Option<Body>,
            }
            #[automatically_derived]
            impl ::core::clone::Clone for Request {
                #[inline]
                fn clone(&self) -> Request {
                    Request {
                        method: ::core::clone::Clone::clone(&self.method),
                        uri: ::core::clone::Clone::clone(&self.uri),
                        headers: ::core::clone::Clone::clone(&self.headers),
                        params: ::core::clone::Clone::clone(&self.params),
                        body: ::core::clone::Clone::clone(&self.body),
                    }
                }
            }
            unsafe impl wasmtime::component::Lower for Request {
                #[inline]
                fn lower<T>(
                    &self,
                    cx: &mut wasmtime::component::__internal::LowerContext<'_, T>,
                    ty: wasmtime::component::__internal::InterfaceType,
                    dst: &mut std::mem::MaybeUninit<Self::Lower>,
                ) -> wasmtime::component::__internal::anyhow::Result<()> {
                    let ty = match ty {
                        wasmtime::component::__internal::InterfaceType::Record(i) => {
                            &cx.types[i]
                        }
                        _ => wasmtime::component::__internal::bad_type_info(),
                    };
                    wasmtime::component::Lower::lower(
                        &self.method,
                        cx,
                        ty.fields[0usize].ty,
                        {
                            #[allow(unused_unsafe)]
                            {
                                unsafe {
                                    use ::wasmtime::component::__internal::MaybeUninitExt;
                                    let m: &mut std::mem::MaybeUninit<_> = dst;
                                    m.map(|p| &raw mut (*p).method)
                                }
                            }
                        },
                    )?;
                    wasmtime::component::Lower::lower(
                        &self.uri,
                        cx,
                        ty.fields[1usize].ty,
                        {
                            #[allow(unused_unsafe)]
                            {
                                unsafe {
                                    use ::wasmtime::component::__internal::MaybeUninitExt;
                                    let m: &mut std::mem::MaybeUninit<_> = dst;
                                    m.map(|p| &raw mut (*p).uri)
                                }
                            }
                        },
                    )?;
                    wasmtime::component::Lower::lower(
                        &self.headers,
                        cx,
                        ty.fields[2usize].ty,
                        {
                            #[allow(unused_unsafe)]
                            {
                                unsafe {
                                    use ::wasmtime::component::__internal::MaybeUninitExt;
                                    let m: &mut std::mem::MaybeUninit<_> = dst;
                                    m.map(|p| &raw mut (*p).headers)
                                }
                            }
                        },
                    )?;
                    wasmtime::component::Lower::lower(
                        &self.params,
                        cx,
                        ty.fields[3usize].ty,
                        {
                            #[allow(unused_unsafe)]
                            {
                                unsafe {
                                    use ::wasmtime::component::__internal::MaybeUninitExt;
                                    let m: &mut std::mem::MaybeUninit<_> = dst;
                                    m.map(|p| &raw mut (*p).params)
                                }
                            }
                        },
                    )?;
                    wasmtime::component::Lower::lower(
                        &self.body,
                        cx,
                        ty.fields[4usize].ty,
                        {
                            #[allow(unused_unsafe)]
                            {
                                unsafe {
                                    use ::wasmtime::component::__internal::MaybeUninitExt;
                                    let m: &mut std::mem::MaybeUninit<_> = dst;
                                    m.map(|p| &raw mut (*p).body)
                                }
                            }
                        },
                    )?;
                    Ok(())
                }
                #[inline]
                fn store<T>(
                    &self,
                    cx: &mut wasmtime::component::__internal::LowerContext<'_, T>,
                    ty: wasmtime::component::__internal::InterfaceType,
                    mut offset: usize,
                ) -> wasmtime::component::__internal::anyhow::Result<()> {
                    if true {
                        if !(offset
                            % (<Self as wasmtime::component::ComponentType>::ALIGN32
                                as usize) == 0)
                        {
                            ::core::panicking::panic(
                                "assertion failed: offset % (<Self as wasmtime::component::ComponentType>::ALIGN32 as usize) == 0",
                            )
                        }
                    }
                    let ty = match ty {
                        wasmtime::component::__internal::InterfaceType::Record(i) => {
                            &cx.types[i]
                        }
                        _ => wasmtime::component::__internal::bad_type_info(),
                    };
                    wasmtime::component::Lower::store(
                        &self.method,
                        cx,
                        ty.fields[0usize].ty,
                        <Method as wasmtime::component::ComponentType>::ABI
                            .next_field32_size(&mut offset),
                    )?;
                    wasmtime::component::Lower::store(
                        &self.uri,
                        cx,
                        ty.fields[1usize].ty,
                        <Uri as wasmtime::component::ComponentType>::ABI
                            .next_field32_size(&mut offset),
                    )?;
                    wasmtime::component::Lower::store(
                        &self.headers,
                        cx,
                        ty.fields[2usize].ty,
                        <Headers as wasmtime::component::ComponentType>::ABI
                            .next_field32_size(&mut offset),
                    )?;
                    wasmtime::component::Lower::store(
                        &self.params,
                        cx,
                        ty.fields[3usize].ty,
                        <Params as wasmtime::component::ComponentType>::ABI
                            .next_field32_size(&mut offset),
                    )?;
                    wasmtime::component::Lower::store(
                        &self.body,
                        cx,
                        ty.fields[4usize].ty,
                        <Option<Body> as wasmtime::component::ComponentType>::ABI
                            .next_field32_size(&mut offset),
                    )?;
                    Ok(())
                }
            }
            unsafe impl wasmtime::component::Lift for Request {
                #[inline]
                fn lift(
                    cx: &mut wasmtime::component::__internal::LiftContext<'_>,
                    ty: wasmtime::component::__internal::InterfaceType,
                    src: &Self::Lower,
                ) -> wasmtime::component::__internal::anyhow::Result<Self> {
                    let ty = match ty {
                        wasmtime::component::__internal::InterfaceType::Record(i) => {
                            &cx.types[i]
                        }
                        _ => wasmtime::component::__internal::bad_type_info(),
                    };
                    Ok(Self {
                        method: <Method as wasmtime::component::Lift>::lift(
                            cx,
                            ty.fields[0usize].ty,
                            &src.method,
                        )?,
                        uri: <Uri as wasmtime::component::Lift>::lift(
                            cx,
                            ty.fields[1usize].ty,
                            &src.uri,
                        )?,
                        headers: <Headers as wasmtime::component::Lift>::lift(
                            cx,
                            ty.fields[2usize].ty,
                            &src.headers,
                        )?,
                        params: <Params as wasmtime::component::Lift>::lift(
                            cx,
                            ty.fields[3usize].ty,
                            &src.params,
                        )?,
                        body: <Option<
                            Body,
                        > as wasmtime::component::Lift>::lift(
                            cx,
                            ty.fields[4usize].ty,
                            &src.body,
                        )?,
                    })
                }
                #[inline]
                fn load(
                    cx: &mut wasmtime::component::__internal::LiftContext<'_>,
                    ty: wasmtime::component::__internal::InterfaceType,
                    bytes: &[u8],
                ) -> wasmtime::component::__internal::anyhow::Result<Self> {
                    let ty = match ty {
                        wasmtime::component::__internal::InterfaceType::Record(i) => {
                            &cx.types[i]
                        }
                        _ => wasmtime::component::__internal::bad_type_info(),
                    };
                    if true {
                        if !((bytes.as_ptr() as usize)
                            % (<Self as wasmtime::component::ComponentType>::ALIGN32
                                as usize) == 0)
                        {
                            ::core::panicking::panic(
                                "assertion failed: (bytes.as_ptr() as usize) %\\n        (<Self as wasmtime::component::ComponentType>::ALIGN32 as usize) == 0",
                            )
                        }
                    }
                    let mut offset = 0;
                    Ok(Self {
                        method: <Method as wasmtime::component::Lift>::load(
                            cx,
                            ty.fields[0usize].ty,
                            &bytes[<Method as wasmtime::component::ComponentType>::ABI
                                .next_field32_size(
                                    &mut offset,
                                )..][..<Method as wasmtime::component::ComponentType>::SIZE32],
                        )?,
                        uri: <Uri as wasmtime::component::Lift>::load(
                            cx,
                            ty.fields[1usize].ty,
                            &bytes[<Uri as wasmtime::component::ComponentType>::ABI
                                .next_field32_size(
                                    &mut offset,
                                )..][..<Uri as wasmtime::component::ComponentType>::SIZE32],
                        )?,
                        headers: <Headers as wasmtime::component::Lift>::load(
                            cx,
                            ty.fields[2usize].ty,
                            &bytes[<Headers as wasmtime::component::ComponentType>::ABI
                                .next_field32_size(
                                    &mut offset,
                                )..][..<Headers as wasmtime::component::ComponentType>::SIZE32],
                        )?,
                        params: <Params as wasmtime::component::Lift>::load(
                            cx,
                            ty.fields[3usize].ty,
                            &bytes[<Params as wasmtime::component::ComponentType>::ABI
                                .next_field32_size(
                                    &mut offset,
                                )..][..<Params as wasmtime::component::ComponentType>::SIZE32],
                        )?,
                        body: <Option<
                            Body,
                        > as wasmtime::component::Lift>::load(
                            cx,
                            ty.fields[4usize].ty,
                            &bytes[<Option<
                                Body,
                            > as wasmtime::component::ComponentType>::ABI
                                .next_field32_size(
                                    &mut offset,
                                )..][..<Option<
                                Body,
                            > as wasmtime::component::ComponentType>::SIZE32],
                        )?,
                    })
                }
            }
            const _: () = {
                #[doc(hidden)]
                #[repr(C)]
                pub struct LowerRequest<
                    T0: Copy,
                    T1: Copy,
                    T2: Copy,
                    T3: Copy,
                    T4: Copy,
                > {
                    method: T0,
                    uri: T1,
                    headers: T2,
                    params: T3,
                    body: T4,
                    _align: [wasmtime::ValRaw; 0],
                }
                #[automatically_derived]
                impl<
                    T0: ::core::clone::Clone + Copy,
                    T1: ::core::clone::Clone + Copy,
                    T2: ::core::clone::Clone + Copy,
                    T3: ::core::clone::Clone + Copy,
                    T4: ::core::clone::Clone + Copy,
                > ::core::clone::Clone for LowerRequest<T0, T1, T2, T3, T4> {
                    #[inline]
                    fn clone(&self) -> LowerRequest<T0, T1, T2, T3, T4> {
                        LowerRequest {
                            method: ::core::clone::Clone::clone(&self.method),
                            uri: ::core::clone::Clone::clone(&self.uri),
                            headers: ::core::clone::Clone::clone(&self.headers),
                            params: ::core::clone::Clone::clone(&self.params),
                            body: ::core::clone::Clone::clone(&self.body),
                            _align: ::core::clone::Clone::clone(&self._align),
                        }
                    }
                }
                #[automatically_derived]
                impl<
                    T0: ::core::marker::Copy + Copy,
                    T1: ::core::marker::Copy + Copy,
                    T2: ::core::marker::Copy + Copy,
                    T3: ::core::marker::Copy + Copy,
                    T4: ::core::marker::Copy + Copy,
                > ::core::marker::Copy for LowerRequest<T0, T1, T2, T3, T4> {}
                unsafe impl wasmtime::component::ComponentType for Request {
                    type Lower = LowerRequest<
                        <Method as wasmtime::component::ComponentType>::Lower,
                        <Uri as wasmtime::component::ComponentType>::Lower,
                        <Headers as wasmtime::component::ComponentType>::Lower,
                        <Params as wasmtime::component::ComponentType>::Lower,
                        <Option<Body> as wasmtime::component::ComponentType>::Lower,
                    >;
                    const ABI: wasmtime::component::__internal::CanonicalAbiInfo = wasmtime::component::__internal::CanonicalAbiInfo::record_static(
                        &[
                            <Method as wasmtime::component::ComponentType>::ABI,
                            <Uri as wasmtime::component::ComponentType>::ABI,
                            <Headers as wasmtime::component::ComponentType>::ABI,
                            <Params as wasmtime::component::ComponentType>::ABI,
                            <Option<Body> as wasmtime::component::ComponentType>::ABI,
                        ],
                    );
                    #[inline]
                    fn typecheck(
                        ty: &wasmtime::component::__internal::InterfaceType,
                        types: &wasmtime::component::__internal::InstanceType<'_>,
                    ) -> wasmtime::component::__internal::anyhow::Result<()> {
                        wasmtime::component::__internal::typecheck_record(
                            ty,
                            types,
                            &[
                                (
                                    "method",
                                    <Method as wasmtime::component::ComponentType>::typecheck,
                                ),
                                (
                                    "uri",
                                    <Uri as wasmtime::component::ComponentType>::typecheck,
                                ),
                                (
                                    "headers",
                                    <Headers as wasmtime::component::ComponentType>::typecheck,
                                ),
                                (
                                    "params",
                                    <Params as wasmtime::component::ComponentType>::typecheck,
                                ),
                                (
                                    "body",
                                    <Option<
                                        Body,
                                    > as wasmtime::component::ComponentType>::typecheck,
                                ),
                            ],
                        )
                    }
                }
            };
            impl core::fmt::Debug for Request {
                fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
                    f.debug_struct("Request")
                        .field("method", &self.method)
                        .field("uri", &self.uri)
                        .field("headers", &self.headers)
                        .field("params", &self.params)
                        .field("body", &self.body)
                        .finish()
                }
            }
            const _: () = {
                if !(40 == <Request as wasmtime::component::ComponentType>::SIZE32) {
                    ::core::panicking::panic(
                        "assertion failed: 40 == <Request as wasmtime::component::ComponentType>::SIZE32",
                    )
                }
                if !(4 == <Request as wasmtime::component::ComponentType>::ALIGN32) {
                    ::core::panicking::panic(
                        "assertion failed: 4 == <Request as wasmtime::component::ComponentType>::ALIGN32",
                    )
                }
            };
            #[component(record)]
            pub struct Response {
                #[component(name = "status")]
                pub status: HttpStatus,
                #[component(name = "headers")]
                pub headers: Option<Headers>,
                #[component(name = "body")]
                pub body: Option<Body>,
            }
            #[automatically_derived]
            impl ::core::clone::Clone for Response {
                #[inline]
                fn clone(&self) -> Response {
                    Response {
                        status: ::core::clone::Clone::clone(&self.status),
                        headers: ::core::clone::Clone::clone(&self.headers),
                        body: ::core::clone::Clone::clone(&self.body),
                    }
                }
            }
            unsafe impl wasmtime::component::Lower for Response {
                #[inline]
                fn lower<T>(
                    &self,
                    cx: &mut wasmtime::component::__internal::LowerContext<'_, T>,
                    ty: wasmtime::component::__internal::InterfaceType,
                    dst: &mut std::mem::MaybeUninit<Self::Lower>,
                ) -> wasmtime::component::__internal::anyhow::Result<()> {
                    let ty = match ty {
                        wasmtime::component::__internal::InterfaceType::Record(i) => {
                            &cx.types[i]
                        }
                        _ => wasmtime::component::__internal::bad_type_info(),
                    };
                    wasmtime::component::Lower::lower(
                        &self.status,
                        cx,
                        ty.fields[0usize].ty,
                        {
                            #[allow(unused_unsafe)]
                            {
                                unsafe {
                                    use ::wasmtime::component::__internal::MaybeUninitExt;
                                    let m: &mut std::mem::MaybeUninit<_> = dst;
                                    m.map(|p| &raw mut (*p).status)
                                }
                            }
                        },
                    )?;
                    wasmtime::component::Lower::lower(
                        &self.headers,
                        cx,
                        ty.fields[1usize].ty,
                        {
                            #[allow(unused_unsafe)]
                            {
                                unsafe {
                                    use ::wasmtime::component::__internal::MaybeUninitExt;
                                    let m: &mut std::mem::MaybeUninit<_> = dst;
                                    m.map(|p| &raw mut (*p).headers)
                                }
                            }
                        },
                    )?;
                    wasmtime::component::Lower::lower(
                        &self.body,
                        cx,
                        ty.fields[2usize].ty,
                        {
                            #[allow(unused_unsafe)]
                            {
                                unsafe {
                                    use ::wasmtime::component::__internal::MaybeUninitExt;
                                    let m: &mut std::mem::MaybeUninit<_> = dst;
                                    m.map(|p| &raw mut (*p).body)
                                }
                            }
                        },
                    )?;
                    Ok(())
                }
                #[inline]
                fn store<T>(
                    &self,
                    cx: &mut wasmtime::component::__internal::LowerContext<'_, T>,
                    ty: wasmtime::component::__internal::InterfaceType,
                    mut offset: usize,
                ) -> wasmtime::component::__internal::anyhow::Result<()> {
                    if true {
                        if !(offset
                            % (<Self as wasmtime::component::ComponentType>::ALIGN32
                                as usize) == 0)
                        {
                            ::core::panicking::panic(
                                "assertion failed: offset % (<Self as wasmtime::component::ComponentType>::ALIGN32 as usize) == 0",
                            )
                        }
                    }
                    let ty = match ty {
                        wasmtime::component::__internal::InterfaceType::Record(i) => {
                            &cx.types[i]
                        }
                        _ => wasmtime::component::__internal::bad_type_info(),
                    };
                    wasmtime::component::Lower::store(
                        &self.status,
                        cx,
                        ty.fields[0usize].ty,
                        <HttpStatus as wasmtime::component::ComponentType>::ABI
                            .next_field32_size(&mut offset),
                    )?;
                    wasmtime::component::Lower::store(
                        &self.headers,
                        cx,
                        ty.fields[1usize].ty,
                        <Option<Headers> as wasmtime::component::ComponentType>::ABI
                            .next_field32_size(&mut offset),
                    )?;
                    wasmtime::component::Lower::store(
                        &self.body,
                        cx,
                        ty.fields[2usize].ty,
                        <Option<Body> as wasmtime::component::ComponentType>::ABI
                            .next_field32_size(&mut offset),
                    )?;
                    Ok(())
                }
            }
            unsafe impl wasmtime::component::Lift for Response {
                #[inline]
                fn lift(
                    cx: &mut wasmtime::component::__internal::LiftContext<'_>,
                    ty: wasmtime::component::__internal::InterfaceType,
                    src: &Self::Lower,
                ) -> wasmtime::component::__internal::anyhow::Result<Self> {
                    let ty = match ty {
                        wasmtime::component::__internal::InterfaceType::Record(i) => {
                            &cx.types[i]
                        }
                        _ => wasmtime::component::__internal::bad_type_info(),
                    };
                    Ok(Self {
                        status: <HttpStatus as wasmtime::component::Lift>::lift(
                            cx,
                            ty.fields[0usize].ty,
                            &src.status,
                        )?,
                        headers: <Option<
                            Headers,
                        > as wasmtime::component::Lift>::lift(
                            cx,
                            ty.fields[1usize].ty,
                            &src.headers,
                        )?,
                        body: <Option<
                            Body,
                        > as wasmtime::component::Lift>::lift(
                            cx,
                            ty.fields[2usize].ty,
                            &src.body,
                        )?,
                    })
                }
                #[inline]
                fn load(
                    cx: &mut wasmtime::component::__internal::LiftContext<'_>,
                    ty: wasmtime::component::__internal::InterfaceType,
                    bytes: &[u8],
                ) -> wasmtime::component::__internal::anyhow::Result<Self> {
                    let ty = match ty {
                        wasmtime::component::__internal::InterfaceType::Record(i) => {
                            &cx.types[i]
                        }
                        _ => wasmtime::component::__internal::bad_type_info(),
                    };
                    if true {
                        if !((bytes.as_ptr() as usize)
                            % (<Self as wasmtime::component::ComponentType>::ALIGN32
                                as usize) == 0)
                        {
                            ::core::panicking::panic(
                                "assertion failed: (bytes.as_ptr() as usize) %\\n        (<Self as wasmtime::component::ComponentType>::ALIGN32 as usize) == 0",
                            )
                        }
                    }
                    let mut offset = 0;
                    Ok(Self {
                        status: <HttpStatus as wasmtime::component::Lift>::load(
                            cx,
                            ty.fields[0usize].ty,
                            &bytes[<HttpStatus as wasmtime::component::ComponentType>::ABI
                                .next_field32_size(
                                    &mut offset,
                                )..][..<HttpStatus as wasmtime::component::ComponentType>::SIZE32],
                        )?,
                        headers: <Option<
                            Headers,
                        > as wasmtime::component::Lift>::load(
                            cx,
                            ty.fields[1usize].ty,
                            &bytes[<Option<
                                Headers,
                            > as wasmtime::component::ComponentType>::ABI
                                .next_field32_size(
                                    &mut offset,
                                )..][..<Option<
                                Headers,
                            > as wasmtime::component::ComponentType>::SIZE32],
                        )?,
                        body: <Option<
                            Body,
                        > as wasmtime::component::Lift>::load(
                            cx,
                            ty.fields[2usize].ty,
                            &bytes[<Option<
                                Body,
                            > as wasmtime::component::ComponentType>::ABI
                                .next_field32_size(
                                    &mut offset,
                                )..][..<Option<
                                Body,
                            > as wasmtime::component::ComponentType>::SIZE32],
                        )?,
                    })
                }
            }
            const _: () = {
                #[doc(hidden)]
                #[repr(C)]
                pub struct LowerResponse<T0: Copy, T1: Copy, T2: Copy> {
                    status: T0,
                    headers: T1,
                    body: T2,
                    _align: [wasmtime::ValRaw; 0],
                }
                #[automatically_derived]
                impl<
                    T0: ::core::clone::Clone + Copy,
                    T1: ::core::clone::Clone + Copy,
                    T2: ::core::clone::Clone + Copy,
                > ::core::clone::Clone for LowerResponse<T0, T1, T2> {
                    #[inline]
                    fn clone(&self) -> LowerResponse<T0, T1, T2> {
                        LowerResponse {
                            status: ::core::clone::Clone::clone(&self.status),
                            headers: ::core::clone::Clone::clone(&self.headers),
                            body: ::core::clone::Clone::clone(&self.body),
                            _align: ::core::clone::Clone::clone(&self._align),
                        }
                    }
                }
                #[automatically_derived]
                impl<
                    T0: ::core::marker::Copy + Copy,
                    T1: ::core::marker::Copy + Copy,
                    T2: ::core::marker::Copy + Copy,
                > ::core::marker::Copy for LowerResponse<T0, T1, T2> {}
                unsafe impl wasmtime::component::ComponentType for Response {
                    type Lower = LowerResponse<
                        <HttpStatus as wasmtime::component::ComponentType>::Lower,
                        <Option<Headers> as wasmtime::component::ComponentType>::Lower,
                        <Option<Body> as wasmtime::component::ComponentType>::Lower,
                    >;
                    const ABI: wasmtime::component::__internal::CanonicalAbiInfo = wasmtime::component::__internal::CanonicalAbiInfo::record_static(
                        &[
                            <HttpStatus as wasmtime::component::ComponentType>::ABI,
                            <Option<Headers> as wasmtime::component::ComponentType>::ABI,
                            <Option<Body> as wasmtime::component::ComponentType>::ABI,
                        ],
                    );
                    #[inline]
                    fn typecheck(
                        ty: &wasmtime::component::__internal::InterfaceType,
                        types: &wasmtime::component::__internal::InstanceType<'_>,
                    ) -> wasmtime::component::__internal::anyhow::Result<()> {
                        wasmtime::component::__internal::typecheck_record(
                            ty,
                            types,
                            &[
                                (
                                    "status",
                                    <HttpStatus as wasmtime::component::ComponentType>::typecheck,
                                ),
                                (
                                    "headers",
                                    <Option<
                                        Headers,
                                    > as wasmtime::component::ComponentType>::typecheck,
                                ),
                                (
                                    "body",
                                    <Option<
                                        Body,
                                    > as wasmtime::component::ComponentType>::typecheck,
                                ),
                            ],
                        )
                    }
                }
            };
            impl core::fmt::Debug for Response {
                fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
                    f.debug_struct("Response")
                        .field("status", &self.status)
                        .field("headers", &self.headers)
                        .field("body", &self.body)
                        .finish()
                }
            }
            const _: () = {
                if !(28 == <Response as wasmtime::component::ComponentType>::SIZE32) {
                    ::core::panicking::panic(
                        "assertion failed: 28 == <Response as wasmtime::component::ComponentType>::SIZE32",
                    )
                }
                if !(4 == <Response as wasmtime::component::ComponentType>::ALIGN32) {
                    ::core::panicking::panic(
                        "assertion failed: 4 == <Response as wasmtime::component::ComponentType>::ALIGN32",
                    )
                }
            };
            #[component(enum)]
            pub enum HttpError {
                #[component(name = "success")]
                Success,
                #[component(name = "destination-not-allowed")]
                DestinationNotAllowed,
                #[component(name = "invalid-url")]
                InvalidUrl,
                #[component(name = "request-error")]
                RequestError,
                #[component(name = "runtime-error")]
                RuntimeError,
                #[component(name = "too-many-requests")]
                TooManyRequests,
            }
            #[automatically_derived]
            impl ::core::clone::Clone for HttpError {
                #[inline]
                fn clone(&self) -> HttpError {
                    *self
                }
            }
            #[automatically_derived]
            impl ::core::marker::Copy for HttpError {}
            #[automatically_derived]
            impl ::core::marker::StructuralPartialEq for HttpError {}
            #[automatically_derived]
            impl ::core::cmp::PartialEq for HttpError {
                #[inline]
                fn eq(&self, other: &HttpError) -> bool {
                    let __self_tag = ::core::intrinsics::discriminant_value(self);
                    let __arg1_tag = ::core::intrinsics::discriminant_value(other);
                    __self_tag == __arg1_tag
                }
            }
            #[automatically_derived]
            impl ::core::marker::StructuralEq for HttpError {}
            #[automatically_derived]
            impl ::core::cmp::Eq for HttpError {
                #[inline]
                #[doc(hidden)]
                #[no_coverage]
                fn assert_receiver_is_total_eq(&self) -> () {}
            }
            unsafe impl wasmtime::component::Lower for HttpError {
                #[inline]
                fn lower<T>(
                    &self,
                    cx: &mut wasmtime::component::__internal::LowerContext<'_, T>,
                    ty: wasmtime::component::__internal::InterfaceType,
                    dst: &mut std::mem::MaybeUninit<Self::Lower>,
                ) -> wasmtime::component::__internal::anyhow::Result<()> {
                    let ty = match ty {
                        wasmtime::component::__internal::InterfaceType::Enum(i) => {
                            &cx.types[i]
                        }
                        _ => wasmtime::component::__internal::bad_type_info(),
                    };
                    match self {
                        Self::Success => {
                            {
                                #[allow(unused_unsafe)]
                                {
                                    unsafe {
                                        use ::wasmtime::component::__internal::MaybeUninitExt;
                                        let m: &mut std::mem::MaybeUninit<_> = dst;
                                        m.map(|p| &raw mut (*p).tag)
                                    }
                                }
                            }
                                .write(wasmtime::ValRaw::u32(0u32));
                            unsafe {
                                wasmtime::component::__internal::lower_payload(
                                    {
                                        #[allow(unused_unsafe)]
                                        {
                                            unsafe {
                                                use ::wasmtime::component::__internal::MaybeUninitExt;
                                                let m: &mut std::mem::MaybeUninit<_> = dst;
                                                m.map(|p| &raw mut (*p).payload)
                                            }
                                        }
                                    },
                                    |payload| {
                                        #[allow(unused_unsafe)]
                                        {
                                            unsafe {
                                                use ::wasmtime::component::__internal::MaybeUninitExt;
                                                let m: &mut std::mem::MaybeUninit<_> = payload;
                                                m.map(|p| &raw mut (*p).Success)
                                            }
                                        }
                                    },
                                    |dst| Ok(()),
                                )
                            }
                        }
                        Self::DestinationNotAllowed => {
                            {
                                #[allow(unused_unsafe)]
                                {
                                    unsafe {
                                        use ::wasmtime::component::__internal::MaybeUninitExt;
                                        let m: &mut std::mem::MaybeUninit<_> = dst;
                                        m.map(|p| &raw mut (*p).tag)
                                    }
                                }
                            }
                                .write(wasmtime::ValRaw::u32(1u32));
                            unsafe {
                                wasmtime::component::__internal::lower_payload(
                                    {
                                        #[allow(unused_unsafe)]
                                        {
                                            unsafe {
                                                use ::wasmtime::component::__internal::MaybeUninitExt;
                                                let m: &mut std::mem::MaybeUninit<_> = dst;
                                                m.map(|p| &raw mut (*p).payload)
                                            }
                                        }
                                    },
                                    |payload| {
                                        #[allow(unused_unsafe)]
                                        {
                                            unsafe {
                                                use ::wasmtime::component::__internal::MaybeUninitExt;
                                                let m: &mut std::mem::MaybeUninit<_> = payload;
                                                m.map(|p| &raw mut (*p).DestinationNotAllowed)
                                            }
                                        }
                                    },
                                    |dst| Ok(()),
                                )
                            }
                        }
                        Self::InvalidUrl => {
                            {
                                #[allow(unused_unsafe)]
                                {
                                    unsafe {
                                        use ::wasmtime::component::__internal::MaybeUninitExt;
                                        let m: &mut std::mem::MaybeUninit<_> = dst;
                                        m.map(|p| &raw mut (*p).tag)
                                    }
                                }
                            }
                                .write(wasmtime::ValRaw::u32(2u32));
                            unsafe {
                                wasmtime::component::__internal::lower_payload(
                                    {
                                        #[allow(unused_unsafe)]
                                        {
                                            unsafe {
                                                use ::wasmtime::component::__internal::MaybeUninitExt;
                                                let m: &mut std::mem::MaybeUninit<_> = dst;
                                                m.map(|p| &raw mut (*p).payload)
                                            }
                                        }
                                    },
                                    |payload| {
                                        #[allow(unused_unsafe)]
                                        {
                                            unsafe {
                                                use ::wasmtime::component::__internal::MaybeUninitExt;
                                                let m: &mut std::mem::MaybeUninit<_> = payload;
                                                m.map(|p| &raw mut (*p).InvalidUrl)
                                            }
                                        }
                                    },
                                    |dst| Ok(()),
                                )
                            }
                        }
                        Self::RequestError => {
                            {
                                #[allow(unused_unsafe)]
                                {
                                    unsafe {
                                        use ::wasmtime::component::__internal::MaybeUninitExt;
                                        let m: &mut std::mem::MaybeUninit<_> = dst;
                                        m.map(|p| &raw mut (*p).tag)
                                    }
                                }
                            }
                                .write(wasmtime::ValRaw::u32(3u32));
                            unsafe {
                                wasmtime::component::__internal::lower_payload(
                                    {
                                        #[allow(unused_unsafe)]
                                        {
                                            unsafe {
                                                use ::wasmtime::component::__internal::MaybeUninitExt;
                                                let m: &mut std::mem::MaybeUninit<_> = dst;
                                                m.map(|p| &raw mut (*p).payload)
                                            }
                                        }
                                    },
                                    |payload| {
                                        #[allow(unused_unsafe)]
                                        {
                                            unsafe {
                                                use ::wasmtime::component::__internal::MaybeUninitExt;
                                                let m: &mut std::mem::MaybeUninit<_> = payload;
                                                m.map(|p| &raw mut (*p).RequestError)
                                            }
                                        }
                                    },
                                    |dst| Ok(()),
                                )
                            }
                        }
                        Self::RuntimeError => {
                            {
                                #[allow(unused_unsafe)]
                                {
                                    unsafe {
                                        use ::wasmtime::component::__internal::MaybeUninitExt;
                                        let m: &mut std::mem::MaybeUninit<_> = dst;
                                        m.map(|p| &raw mut (*p).tag)
                                    }
                                }
                            }
                                .write(wasmtime::ValRaw::u32(4u32));
                            unsafe {
                                wasmtime::component::__internal::lower_payload(
                                    {
                                        #[allow(unused_unsafe)]
                                        {
                                            unsafe {
                                                use ::wasmtime::component::__internal::MaybeUninitExt;
                                                let m: &mut std::mem::MaybeUninit<_> = dst;
                                                m.map(|p| &raw mut (*p).payload)
                                            }
                                        }
                                    },
                                    |payload| {
                                        #[allow(unused_unsafe)]
                                        {
                                            unsafe {
                                                use ::wasmtime::component::__internal::MaybeUninitExt;
                                                let m: &mut std::mem::MaybeUninit<_> = payload;
                                                m.map(|p| &raw mut (*p).RuntimeError)
                                            }
                                        }
                                    },
                                    |dst| Ok(()),
                                )
                            }
                        }
                        Self::TooManyRequests => {
                            {
                                #[allow(unused_unsafe)]
                                {
                                    unsafe {
                                        use ::wasmtime::component::__internal::MaybeUninitExt;
                                        let m: &mut std::mem::MaybeUninit<_> = dst;
                                        m.map(|p| &raw mut (*p).tag)
                                    }
                                }
                            }
                                .write(wasmtime::ValRaw::u32(5u32));
                            unsafe {
                                wasmtime::component::__internal::lower_payload(
                                    {
                                        #[allow(unused_unsafe)]
                                        {
                                            unsafe {
                                                use ::wasmtime::component::__internal::MaybeUninitExt;
                                                let m: &mut std::mem::MaybeUninit<_> = dst;
                                                m.map(|p| &raw mut (*p).payload)
                                            }
                                        }
                                    },
                                    |payload| {
                                        #[allow(unused_unsafe)]
                                        {
                                            unsafe {
                                                use ::wasmtime::component::__internal::MaybeUninitExt;
                                                let m: &mut std::mem::MaybeUninit<_> = payload;
                                                m.map(|p| &raw mut (*p).TooManyRequests)
                                            }
                                        }
                                    },
                                    |dst| Ok(()),
                                )
                            }
                        }
                    }
                }
                #[inline]
                fn store<T>(
                    &self,
                    cx: &mut wasmtime::component::__internal::LowerContext<'_, T>,
                    ty: wasmtime::component::__internal::InterfaceType,
                    mut offset: usize,
                ) -> wasmtime::component::__internal::anyhow::Result<()> {
                    let ty = match ty {
                        wasmtime::component::__internal::InterfaceType::Enum(i) => {
                            &cx.types[i]
                        }
                        _ => wasmtime::component::__internal::bad_type_info(),
                    };
                    if true {
                        if !(offset
                            % (<Self as wasmtime::component::ComponentType>::ALIGN32
                                as usize) == 0)
                        {
                            ::core::panicking::panic(
                                "assertion failed: offset % (<Self as wasmtime::component::ComponentType>::ALIGN32 as usize) == 0",
                            )
                        }
                    }
                    match self {
                        Self::Success => {
                            *cx.get::<1usize>(offset) = 0u8.to_le_bytes();
                            Ok(())
                        }
                        Self::DestinationNotAllowed => {
                            *cx.get::<1usize>(offset) = 1u8.to_le_bytes();
                            Ok(())
                        }
                        Self::InvalidUrl => {
                            *cx.get::<1usize>(offset) = 2u8.to_le_bytes();
                            Ok(())
                        }
                        Self::RequestError => {
                            *cx.get::<1usize>(offset) = 3u8.to_le_bytes();
                            Ok(())
                        }
                        Self::RuntimeError => {
                            *cx.get::<1usize>(offset) = 4u8.to_le_bytes();
                            Ok(())
                        }
                        Self::TooManyRequests => {
                            *cx.get::<1usize>(offset) = 5u8.to_le_bytes();
                            Ok(())
                        }
                    }
                }
            }
            unsafe impl wasmtime::component::Lift for HttpError {
                #[inline]
                fn lift(
                    cx: &mut wasmtime::component::__internal::LiftContext<'_>,
                    ty: wasmtime::component::__internal::InterfaceType,
                    src: &Self::Lower,
                ) -> wasmtime::component::__internal::anyhow::Result<Self> {
                    let ty = match ty {
                        wasmtime::component::__internal::InterfaceType::Enum(i) => {
                            &cx.types[i]
                        }
                        _ => wasmtime::component::__internal::bad_type_info(),
                    };
                    Ok(
                        match src.tag.get_u32() {
                            0u32 => Self::Success,
                            1u32 => Self::DestinationNotAllowed,
                            2u32 => Self::InvalidUrl,
                            3u32 => Self::RequestError,
                            4u32 => Self::RuntimeError,
                            5u32 => Self::TooManyRequests,
                            discrim => {
                                return ::anyhow::__private::Err(
                                    ::anyhow::Error::msg({
                                        let res = ::alloc::fmt::format(
                                            format_args!("unexpected discriminant: {0}", discrim),
                                        );
                                        res
                                    }),
                                );
                            }
                        },
                    )
                }
                #[inline]
                fn load(
                    cx: &mut wasmtime::component::__internal::LiftContext<'_>,
                    ty: wasmtime::component::__internal::InterfaceType,
                    bytes: &[u8],
                ) -> wasmtime::component::__internal::anyhow::Result<Self> {
                    let align = <Self as wasmtime::component::ComponentType>::ALIGN32;
                    if true {
                        if !((bytes.as_ptr() as usize) % (align as usize) == 0) {
                            ::core::panicking::panic(
                                "assertion failed: (bytes.as_ptr() as usize) % (align as usize) == 0",
                            )
                        }
                    }
                    let discrim = bytes[0];
                    let payload_offset = <Self as wasmtime::component::__internal::ComponentVariant>::PAYLOAD_OFFSET32;
                    let payload = &bytes[payload_offset..];
                    let ty = match ty {
                        wasmtime::component::__internal::InterfaceType::Enum(i) => {
                            &cx.types[i]
                        }
                        _ => wasmtime::component::__internal::bad_type_info(),
                    };
                    Ok(
                        match discrim {
                            0u8 => Self::Success,
                            1u8 => Self::DestinationNotAllowed,
                            2u8 => Self::InvalidUrl,
                            3u8 => Self::RequestError,
                            4u8 => Self::RuntimeError,
                            5u8 => Self::TooManyRequests,
                            discrim => {
                                return ::anyhow::__private::Err(
                                    ::anyhow::Error::msg({
                                        let res = ::alloc::fmt::format(
                                            format_args!("unexpected discriminant: {0}", discrim),
                                        );
                                        res
                                    }),
                                );
                            }
                        },
                    )
                }
            }
            const _: () = {
                #[doc(hidden)]
                #[repr(C)]
                pub struct LowerHttpError {
                    tag: wasmtime::ValRaw,
                    payload: LowerPayloadHttpError,
                }
                #[automatically_derived]
                impl ::core::clone::Clone for LowerHttpError {
                    #[inline]
                    fn clone(&self) -> LowerHttpError {
                        let _: ::core::clone::AssertParamIsClone<wasmtime::ValRaw>;
                        let _: ::core::clone::AssertParamIsClone<LowerPayloadHttpError>;
                        *self
                    }
                }
                #[automatically_derived]
                impl ::core::marker::Copy for LowerHttpError {}
                #[doc(hidden)]
                #[allow(non_snake_case)]
                #[repr(C)]
                union LowerPayloadHttpError {
                    Success: [wasmtime::ValRaw; 0],
                    DestinationNotAllowed: [wasmtime::ValRaw; 0],
                    InvalidUrl: [wasmtime::ValRaw; 0],
                    RequestError: [wasmtime::ValRaw; 0],
                    RuntimeError: [wasmtime::ValRaw; 0],
                    TooManyRequests: [wasmtime::ValRaw; 0],
                }
                #[automatically_derived]
                #[allow(non_snake_case)]
                impl ::core::clone::Clone for LowerPayloadHttpError {
                    #[inline]
                    fn clone(&self) -> LowerPayloadHttpError {
                        let _: ::core::clone::AssertParamIsCopy<Self>;
                        *self
                    }
                }
                #[automatically_derived]
                #[allow(non_snake_case)]
                impl ::core::marker::Copy for LowerPayloadHttpError {}
                unsafe impl wasmtime::component::ComponentType for HttpError {
                    type Lower = LowerHttpError;
                    #[inline]
                    fn typecheck(
                        ty: &wasmtime::component::__internal::InterfaceType,
                        types: &wasmtime::component::__internal::InstanceType<'_>,
                    ) -> wasmtime::component::__internal::anyhow::Result<()> {
                        wasmtime::component::__internal::typecheck_enum(
                            ty,
                            types,
                            &[
                                "success",
                                "destination-not-allowed",
                                "invalid-url",
                                "request-error",
                                "runtime-error",
                                "too-many-requests",
                            ],
                        )
                    }
                    const ABI: wasmtime::component::__internal::CanonicalAbiInfo = wasmtime::component::__internal::CanonicalAbiInfo::variant_static(
                        &[None, None, None, None, None, None],
                    );
                }
                unsafe impl wasmtime::component::__internal::ComponentVariant
                for HttpError {
                    const CASES: &'static [Option<
                        wasmtime::component::__internal::CanonicalAbiInfo,
                    >] = &[None, None, None, None, None, None];
                }
            };
            impl HttpError {
                pub fn name(&self) -> &'static str {
                    match self {
                        HttpError::Success => "success",
                        HttpError::DestinationNotAllowed => "destination-not-allowed",
                        HttpError::InvalidUrl => "invalid-url",
                        HttpError::RequestError => "request-error",
                        HttpError::RuntimeError => "runtime-error",
                        HttpError::TooManyRequests => "too-many-requests",
                    }
                }
                pub fn message(&self) -> &'static str {
                    match self {
                        HttpError::Success => "",
                        HttpError::DestinationNotAllowed => "",
                        HttpError::InvalidUrl => "",
                        HttpError::RequestError => "",
                        HttpError::RuntimeError => "",
                        HttpError::TooManyRequests => "",
                    }
                }
            }
            impl core::fmt::Debug for HttpError {
                fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
                    f.debug_struct("HttpError")
                        .field("code", &(*self as i32))
                        .field("name", &self.name())
                        .field("message", &self.message())
                        .finish()
                }
            }
            impl core::fmt::Display for HttpError {
                fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
                    f.write_fmt(
                        format_args!("{0} (error {1})", self.name(), *self as i32),
                    )
                }
            }
            impl std::error::Error for HttpError {}
            const _: () = {
                if !(1 == <HttpError as wasmtime::component::ComponentType>::SIZE32) {
                    ::core::panicking::panic(
                        "assertion failed: 1 == <HttpError as wasmtime::component::ComponentType>::SIZE32",
                    )
                }
                if !(1 == <HttpError as wasmtime::component::ComponentType>::ALIGN32) {
                    ::core::panicking::panic(
                        "assertion failed: 1 == <HttpError as wasmtime::component::ComponentType>::ALIGN32",
                    )
                }
            };
            pub trait Host {}
            pub fn add_to_linker<T, U>(
                linker: &mut wasmtime::component::Linker<T>,
                get: impl Fn(&mut T) -> &mut U + Send + Sync + Copy + 'static,
            ) -> wasmtime::Result<()>
            where
                T: Send,
                U: Host + Send,
            {
                let mut inst = linker.instance("fermyon:spin/http-types")?;
                Ok(())
            }
        }
        #[allow(clippy::all)]
        pub mod redis_types {
            #[allow(unused_imports)]
            use wasmtime::component::__internal::anyhow;
            #[component(enum)]
            pub enum Error {
                #[component(name = "success")]
                Success,
                #[component(name = "error")]
                Error,
            }
            #[automatically_derived]
            impl ::core::clone::Clone for Error {
                #[inline]
                fn clone(&self) -> Error {
                    *self
                }
            }
            #[automatically_derived]
            impl ::core::marker::Copy for Error {}
            #[automatically_derived]
            impl ::core::marker::StructuralPartialEq for Error {}
            #[automatically_derived]
            impl ::core::cmp::PartialEq for Error {
                #[inline]
                fn eq(&self, other: &Error) -> bool {
                    let __self_tag = ::core::intrinsics::discriminant_value(self);
                    let __arg1_tag = ::core::intrinsics::discriminant_value(other);
                    __self_tag == __arg1_tag
                }
            }
            #[automatically_derived]
            impl ::core::marker::StructuralEq for Error {}
            #[automatically_derived]
            impl ::core::cmp::Eq for Error {
                #[inline]
                #[doc(hidden)]
                #[no_coverage]
                fn assert_receiver_is_total_eq(&self) -> () {}
            }
            unsafe impl wasmtime::component::Lower for Error {
                #[inline]
                fn lower<T>(
                    &self,
                    cx: &mut wasmtime::component::__internal::LowerContext<'_, T>,
                    ty: wasmtime::component::__internal::InterfaceType,
                    dst: &mut std::mem::MaybeUninit<Self::Lower>,
                ) -> wasmtime::component::__internal::anyhow::Result<()> {
                    let ty = match ty {
                        wasmtime::component::__internal::InterfaceType::Enum(i) => {
                            &cx.types[i]
                        }
                        _ => wasmtime::component::__internal::bad_type_info(),
                    };
                    match self {
                        Self::Success => {
                            {
                                #[allow(unused_unsafe)]
                                {
                                    unsafe {
                                        use ::wasmtime::component::__internal::MaybeUninitExt;
                                        let m: &mut std::mem::MaybeUninit<_> = dst;
                                        m.map(|p| &raw mut (*p).tag)
                                    }
                                }
                            }
                                .write(wasmtime::ValRaw::u32(0u32));
                            unsafe {
                                wasmtime::component::__internal::lower_payload(
                                    {
                                        #[allow(unused_unsafe)]
                                        {
                                            unsafe {
                                                use ::wasmtime::component::__internal::MaybeUninitExt;
                                                let m: &mut std::mem::MaybeUninit<_> = dst;
                                                m.map(|p| &raw mut (*p).payload)
                                            }
                                        }
                                    },
                                    |payload| {
                                        #[allow(unused_unsafe)]
                                        {
                                            unsafe {
                                                use ::wasmtime::component::__internal::MaybeUninitExt;
                                                let m: &mut std::mem::MaybeUninit<_> = payload;
                                                m.map(|p| &raw mut (*p).Success)
                                            }
                                        }
                                    },
                                    |dst| Ok(()),
                                )
                            }
                        }
                        Self::Error => {
                            {
                                #[allow(unused_unsafe)]
                                {
                                    unsafe {
                                        use ::wasmtime::component::__internal::MaybeUninitExt;
                                        let m: &mut std::mem::MaybeUninit<_> = dst;
                                        m.map(|p| &raw mut (*p).tag)
                                    }
                                }
                            }
                                .write(wasmtime::ValRaw::u32(1u32));
                            unsafe {
                                wasmtime::component::__internal::lower_payload(
                                    {
                                        #[allow(unused_unsafe)]
                                        {
                                            unsafe {
                                                use ::wasmtime::component::__internal::MaybeUninitExt;
                                                let m: &mut std::mem::MaybeUninit<_> = dst;
                                                m.map(|p| &raw mut (*p).payload)
                                            }
                                        }
                                    },
                                    |payload| {
                                        #[allow(unused_unsafe)]
                                        {
                                            unsafe {
                                                use ::wasmtime::component::__internal::MaybeUninitExt;
                                                let m: &mut std::mem::MaybeUninit<_> = payload;
                                                m.map(|p| &raw mut (*p).Error)
                                            }
                                        }
                                    },
                                    |dst| Ok(()),
                                )
                            }
                        }
                    }
                }
                #[inline]
                fn store<T>(
                    &self,
                    cx: &mut wasmtime::component::__internal::LowerContext<'_, T>,
                    ty: wasmtime::component::__internal::InterfaceType,
                    mut offset: usize,
                ) -> wasmtime::component::__internal::anyhow::Result<()> {
                    let ty = match ty {
                        wasmtime::component::__internal::InterfaceType::Enum(i) => {
                            &cx.types[i]
                        }
                        _ => wasmtime::component::__internal::bad_type_info(),
                    };
                    if true {
                        if !(offset
                            % (<Self as wasmtime::component::ComponentType>::ALIGN32
                                as usize) == 0)
                        {
                            ::core::panicking::panic(
                                "assertion failed: offset % (<Self as wasmtime::component::ComponentType>::ALIGN32 as usize) == 0",
                            )
                        }
                    }
                    match self {
                        Self::Success => {
                            *cx.get::<1usize>(offset) = 0u8.to_le_bytes();
                            Ok(())
                        }
                        Self::Error => {
                            *cx.get::<1usize>(offset) = 1u8.to_le_bytes();
                            Ok(())
                        }
                    }
                }
            }
            unsafe impl wasmtime::component::Lift for Error {
                #[inline]
                fn lift(
                    cx: &mut wasmtime::component::__internal::LiftContext<'_>,
                    ty: wasmtime::component::__internal::InterfaceType,
                    src: &Self::Lower,
                ) -> wasmtime::component::__internal::anyhow::Result<Self> {
                    let ty = match ty {
                        wasmtime::component::__internal::InterfaceType::Enum(i) => {
                            &cx.types[i]
                        }
                        _ => wasmtime::component::__internal::bad_type_info(),
                    };
                    Ok(
                        match src.tag.get_u32() {
                            0u32 => Self::Success,
                            1u32 => Self::Error,
                            discrim => {
                                return ::anyhow::__private::Err(
                                    ::anyhow::Error::msg({
                                        let res = ::alloc::fmt::format(
                                            format_args!("unexpected discriminant: {0}", discrim),
                                        );
                                        res
                                    }),
                                );
                            }
                        },
                    )
                }
                #[inline]
                fn load(
                    cx: &mut wasmtime::component::__internal::LiftContext<'_>,
                    ty: wasmtime::component::__internal::InterfaceType,
                    bytes: &[u8],
                ) -> wasmtime::component::__internal::anyhow::Result<Self> {
                    let align = <Self as wasmtime::component::ComponentType>::ALIGN32;
                    if true {
                        if !((bytes.as_ptr() as usize) % (align as usize) == 0) {
                            ::core::panicking::panic(
                                "assertion failed: (bytes.as_ptr() as usize) % (align as usize) == 0",
                            )
                        }
                    }
                    let discrim = bytes[0];
                    let payload_offset = <Self as wasmtime::component::__internal::ComponentVariant>::PAYLOAD_OFFSET32;
                    let payload = &bytes[payload_offset..];
                    let ty = match ty {
                        wasmtime::component::__internal::InterfaceType::Enum(i) => {
                            &cx.types[i]
                        }
                        _ => wasmtime::component::__internal::bad_type_info(),
                    };
                    Ok(
                        match discrim {
                            0u8 => Self::Success,
                            1u8 => Self::Error,
                            discrim => {
                                return ::anyhow::__private::Err(
                                    ::anyhow::Error::msg({
                                        let res = ::alloc::fmt::format(
                                            format_args!("unexpected discriminant: {0}", discrim),
                                        );
                                        res
                                    }),
                                );
                            }
                        },
                    )
                }
            }
            const _: () = {
                #[doc(hidden)]
                #[repr(C)]
                pub struct LowerError {
                    tag: wasmtime::ValRaw,
                    payload: LowerPayloadError,
                }
                #[automatically_derived]
                impl ::core::clone::Clone for LowerError {
                    #[inline]
                    fn clone(&self) -> LowerError {
                        let _: ::core::clone::AssertParamIsClone<wasmtime::ValRaw>;
                        let _: ::core::clone::AssertParamIsClone<LowerPayloadError>;
                        *self
                    }
                }
                #[automatically_derived]
                impl ::core::marker::Copy for LowerError {}
                #[doc(hidden)]
                #[allow(non_snake_case)]
                #[repr(C)]
                union LowerPayloadError {
                    Success: [wasmtime::ValRaw; 0],
                    Error: [wasmtime::ValRaw; 0],
                }
                #[automatically_derived]
                #[allow(non_snake_case)]
                impl ::core::clone::Clone for LowerPayloadError {
                    #[inline]
                    fn clone(&self) -> LowerPayloadError {
                        let _: ::core::clone::AssertParamIsCopy<Self>;
                        *self
                    }
                }
                #[automatically_derived]
                #[allow(non_snake_case)]
                impl ::core::marker::Copy for LowerPayloadError {}
                unsafe impl wasmtime::component::ComponentType for Error {
                    type Lower = LowerError;
                    #[inline]
                    fn typecheck(
                        ty: &wasmtime::component::__internal::InterfaceType,
                        types: &wasmtime::component::__internal::InstanceType<'_>,
                    ) -> wasmtime::component::__internal::anyhow::Result<()> {
                        wasmtime::component::__internal::typecheck_enum(
                            ty,
                            types,
                            &["success", "error"],
                        )
                    }
                    const ABI: wasmtime::component::__internal::CanonicalAbiInfo = wasmtime::component::__internal::CanonicalAbiInfo::variant_static(
                        &[None, None],
                    );
                }
                unsafe impl wasmtime::component::__internal::ComponentVariant for Error {
                    const CASES: &'static [Option<
                        wasmtime::component::__internal::CanonicalAbiInfo,
                    >] = &[None, None];
                }
            };
            impl Error {
                pub fn name(&self) -> &'static str {
                    match self {
                        Error::Success => "success",
                        Error::Error => "error",
                    }
                }
                pub fn message(&self) -> &'static str {
                    match self {
                        Error::Success => "",
                        Error::Error => "",
                    }
                }
            }
            impl core::fmt::Debug for Error {
                fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
                    f.debug_struct("Error")
                        .field("code", &(*self as i32))
                        .field("name", &self.name())
                        .field("message", &self.message())
                        .finish()
                }
            }
            impl core::fmt::Display for Error {
                fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
                    f.write_fmt(
                        format_args!("{0} (error {1})", self.name(), *self as i32),
                    )
                }
            }
            impl std::error::Error for Error {}
            const _: () = {
                if !(1 == <Error as wasmtime::component::ComponentType>::SIZE32) {
                    ::core::panicking::panic(
                        "assertion failed: 1 == <Error as wasmtime::component::ComponentType>::SIZE32",
                    )
                }
                if !(1 == <Error as wasmtime::component::ComponentType>::ALIGN32) {
                    ::core::panicking::panic(
                        "assertion failed: 1 == <Error as wasmtime::component::ComponentType>::ALIGN32",
                    )
                }
            };
            pub type Payload = Vec<u8>;
            const _: () = {
                if !(8 == <Payload as wasmtime::component::ComponentType>::SIZE32) {
                    ::core::panicking::panic(
                        "assertion failed: 8 == <Payload as wasmtime::component::ComponentType>::SIZE32",
                    )
                }
                if !(4 == <Payload as wasmtime::component::ComponentType>::ALIGN32) {
                    ::core::panicking::panic(
                        "assertion failed: 4 == <Payload as wasmtime::component::ComponentType>::ALIGN32",
                    )
                }
            };
            #[component(variant)]
            pub enum RedisParameter {
                #[component(name = "int64")]
                Int64(i64),
                #[component(name = "binary")]
                Binary(Payload),
            }
            #[automatically_derived]
            impl ::core::clone::Clone for RedisParameter {
                #[inline]
                fn clone(&self) -> RedisParameter {
                    match self {
                        RedisParameter::Int64(__self_0) => {
                            RedisParameter::Int64(::core::clone::Clone::clone(__self_0))
                        }
                        RedisParameter::Binary(__self_0) => {
                            RedisParameter::Binary(::core::clone::Clone::clone(__self_0))
                        }
                    }
                }
            }
            unsafe impl wasmtime::component::Lower for RedisParameter {
                #[inline]
                fn lower<T>(
                    &self,
                    cx: &mut wasmtime::component::__internal::LowerContext<'_, T>,
                    ty: wasmtime::component::__internal::InterfaceType,
                    dst: &mut std::mem::MaybeUninit<Self::Lower>,
                ) -> wasmtime::component::__internal::anyhow::Result<()> {
                    let ty = match ty {
                        wasmtime::component::__internal::InterfaceType::Variant(i) => {
                            &cx.types[i]
                        }
                        _ => wasmtime::component::__internal::bad_type_info(),
                    };
                    match self {
                        Self::Int64(value) => {
                            {
                                #[allow(unused_unsafe)]
                                {
                                    unsafe {
                                        use ::wasmtime::component::__internal::MaybeUninitExt;
                                        let m: &mut std::mem::MaybeUninit<_> = dst;
                                        m.map(|p| &raw mut (*p).tag)
                                    }
                                }
                            }
                                .write(wasmtime::ValRaw::u32(0u32));
                            unsafe {
                                wasmtime::component::__internal::lower_payload(
                                    {
                                        #[allow(unused_unsafe)]
                                        {
                                            unsafe {
                                                use ::wasmtime::component::__internal::MaybeUninitExt;
                                                let m: &mut std::mem::MaybeUninit<_> = dst;
                                                m.map(|p| &raw mut (*p).payload)
                                            }
                                        }
                                    },
                                    |payload| {
                                        #[allow(unused_unsafe)]
                                        {
                                            unsafe {
                                                use ::wasmtime::component::__internal::MaybeUninitExt;
                                                let m: &mut std::mem::MaybeUninit<_> = payload;
                                                m.map(|p| &raw mut (*p).Int64)
                                            }
                                        }
                                    },
                                    |dst| {
                                        value
                                            .lower(
                                                cx,
                                                ty
                                                    .cases[0usize]
                                                    .ty
                                                    .unwrap_or_else(
                                                        wasmtime::component::__internal::bad_type_info,
                                                    ),
                                                dst,
                                            )
                                    },
                                )
                            }
                        }
                        Self::Binary(value) => {
                            {
                                #[allow(unused_unsafe)]
                                {
                                    unsafe {
                                        use ::wasmtime::component::__internal::MaybeUninitExt;
                                        let m: &mut std::mem::MaybeUninit<_> = dst;
                                        m.map(|p| &raw mut (*p).tag)
                                    }
                                }
                            }
                                .write(wasmtime::ValRaw::u32(1u32));
                            unsafe {
                                wasmtime::component::__internal::lower_payload(
                                    {
                                        #[allow(unused_unsafe)]
                                        {
                                            unsafe {
                                                use ::wasmtime::component::__internal::MaybeUninitExt;
                                                let m: &mut std::mem::MaybeUninit<_> = dst;
                                                m.map(|p| &raw mut (*p).payload)
                                            }
                                        }
                                    },
                                    |payload| {
                                        #[allow(unused_unsafe)]
                                        {
                                            unsafe {
                                                use ::wasmtime::component::__internal::MaybeUninitExt;
                                                let m: &mut std::mem::MaybeUninit<_> = payload;
                                                m.map(|p| &raw mut (*p).Binary)
                                            }
                                        }
                                    },
                                    |dst| {
                                        value
                                            .lower(
                                                cx,
                                                ty
                                                    .cases[1usize]
                                                    .ty
                                                    .unwrap_or_else(
                                                        wasmtime::component::__internal::bad_type_info,
                                                    ),
                                                dst,
                                            )
                                    },
                                )
                            }
                        }
                    }
                }
                #[inline]
                fn store<T>(
                    &self,
                    cx: &mut wasmtime::component::__internal::LowerContext<'_, T>,
                    ty: wasmtime::component::__internal::InterfaceType,
                    mut offset: usize,
                ) -> wasmtime::component::__internal::anyhow::Result<()> {
                    let ty = match ty {
                        wasmtime::component::__internal::InterfaceType::Variant(i) => {
                            &cx.types[i]
                        }
                        _ => wasmtime::component::__internal::bad_type_info(),
                    };
                    if true {
                        if !(offset
                            % (<Self as wasmtime::component::ComponentType>::ALIGN32
                                as usize) == 0)
                        {
                            ::core::panicking::panic(
                                "assertion failed: offset % (<Self as wasmtime::component::ComponentType>::ALIGN32 as usize) == 0",
                            )
                        }
                    }
                    match self {
                        Self::Int64(value) => {
                            *cx.get::<1usize>(offset) = 0u8.to_le_bytes();
                            value
                                .store(
                                    cx,
                                    ty
                                        .cases[0usize]
                                        .ty
                                        .unwrap_or_else(
                                            wasmtime::component::__internal::bad_type_info,
                                        ),
                                    offset
                                        + <Self as wasmtime::component::__internal::ComponentVariant>::PAYLOAD_OFFSET32,
                                )
                        }
                        Self::Binary(value) => {
                            *cx.get::<1usize>(offset) = 1u8.to_le_bytes();
                            value
                                .store(
                                    cx,
                                    ty
                                        .cases[1usize]
                                        .ty
                                        .unwrap_or_else(
                                            wasmtime::component::__internal::bad_type_info,
                                        ),
                                    offset
                                        + <Self as wasmtime::component::__internal::ComponentVariant>::PAYLOAD_OFFSET32,
                                )
                        }
                    }
                }
            }
            unsafe impl wasmtime::component::Lift for RedisParameter {
                #[inline]
                fn lift(
                    cx: &mut wasmtime::component::__internal::LiftContext<'_>,
                    ty: wasmtime::component::__internal::InterfaceType,
                    src: &Self::Lower,
                ) -> wasmtime::component::__internal::anyhow::Result<Self> {
                    let ty = match ty {
                        wasmtime::component::__internal::InterfaceType::Variant(i) => {
                            &cx.types[i]
                        }
                        _ => wasmtime::component::__internal::bad_type_info(),
                    };
                    Ok(
                        match src.tag.get_u32() {
                            0u32 => {
                                Self::Int64(
                                    <i64 as wasmtime::component::Lift>::lift(
                                        cx,
                                        ty
                                            .cases[0usize]
                                            .ty
                                            .unwrap_or_else(
                                                wasmtime::component::__internal::bad_type_info,
                                            ),
                                        unsafe { &src.payload.Int64 },
                                    )?,
                                )
                            }
                            1u32 => {
                                Self::Binary(
                                    <Payload as wasmtime::component::Lift>::lift(
                                        cx,
                                        ty
                                            .cases[1usize]
                                            .ty
                                            .unwrap_or_else(
                                                wasmtime::component::__internal::bad_type_info,
                                            ),
                                        unsafe { &src.payload.Binary },
                                    )?,
                                )
                            }
                            discrim => {
                                return ::anyhow::__private::Err(
                                    ::anyhow::Error::msg({
                                        let res = ::alloc::fmt::format(
                                            format_args!("unexpected discriminant: {0}", discrim),
                                        );
                                        res
                                    }),
                                );
                            }
                        },
                    )
                }
                #[inline]
                fn load(
                    cx: &mut wasmtime::component::__internal::LiftContext<'_>,
                    ty: wasmtime::component::__internal::InterfaceType,
                    bytes: &[u8],
                ) -> wasmtime::component::__internal::anyhow::Result<Self> {
                    let align = <Self as wasmtime::component::ComponentType>::ALIGN32;
                    if true {
                        if !((bytes.as_ptr() as usize) % (align as usize) == 0) {
                            ::core::panicking::panic(
                                "assertion failed: (bytes.as_ptr() as usize) % (align as usize) == 0",
                            )
                        }
                    }
                    let discrim = bytes[0];
                    let payload_offset = <Self as wasmtime::component::__internal::ComponentVariant>::PAYLOAD_OFFSET32;
                    let payload = &bytes[payload_offset..];
                    let ty = match ty {
                        wasmtime::component::__internal::InterfaceType::Variant(i) => {
                            &cx.types[i]
                        }
                        _ => wasmtime::component::__internal::bad_type_info(),
                    };
                    Ok(
                        match discrim {
                            0u8 => {
                                Self::Int64(
                                    <i64 as wasmtime::component::Lift>::load(
                                        cx,
                                        ty
                                            .cases[0usize]
                                            .ty
                                            .unwrap_or_else(
                                                wasmtime::component::__internal::bad_type_info,
                                            ),
                                        &payload[..<i64 as wasmtime::component::ComponentType>::SIZE32],
                                    )?,
                                )
                            }
                            1u8 => {
                                Self::Binary(
                                    <Payload as wasmtime::component::Lift>::load(
                                        cx,
                                        ty
                                            .cases[1usize]
                                            .ty
                                            .unwrap_or_else(
                                                wasmtime::component::__internal::bad_type_info,
                                            ),
                                        &payload[..<Payload as wasmtime::component::ComponentType>::SIZE32],
                                    )?,
                                )
                            }
                            discrim => {
                                return ::anyhow::__private::Err(
                                    ::anyhow::Error::msg({
                                        let res = ::alloc::fmt::format(
                                            format_args!("unexpected discriminant: {0}", discrim),
                                        );
                                        res
                                    }),
                                );
                            }
                        },
                    )
                }
            }
            const _: () = {
                #[doc(hidden)]
                #[repr(C)]
                pub struct LowerRedisParameter<T0: Copy, T1: Copy> {
                    tag: wasmtime::ValRaw,
                    payload: LowerPayloadRedisParameter<T0, T1>,
                }
                #[automatically_derived]
                impl<
                    T0: ::core::clone::Clone + Copy,
                    T1: ::core::clone::Clone + Copy,
                > ::core::clone::Clone for LowerRedisParameter<T0, T1> {
                    #[inline]
                    fn clone(&self) -> LowerRedisParameter<T0, T1> {
                        LowerRedisParameter {
                            tag: ::core::clone::Clone::clone(&self.tag),
                            payload: ::core::clone::Clone::clone(&self.payload),
                        }
                    }
                }
                #[automatically_derived]
                impl<
                    T0: ::core::marker::Copy + Copy,
                    T1: ::core::marker::Copy + Copy,
                > ::core::marker::Copy for LowerRedisParameter<T0, T1> {}
                #[doc(hidden)]
                #[allow(non_snake_case)]
                #[repr(C)]
                union LowerPayloadRedisParameter<T0: Copy, T1: Copy> {
                    Int64: T0,
                    Binary: T1,
                }
                #[automatically_derived]
                #[allow(non_snake_case)]
                impl<
                    T0: ::core::marker::Copy + ::core::clone::Clone + Copy,
                    T1: ::core::marker::Copy + ::core::clone::Clone + Copy,
                > ::core::clone::Clone for LowerPayloadRedisParameter<T0, T1> {
                    #[inline]
                    fn clone(&self) -> LowerPayloadRedisParameter<T0, T1> {
                        let _: ::core::clone::AssertParamIsCopy<Self>;
                        *self
                    }
                }
                #[automatically_derived]
                #[allow(non_snake_case)]
                impl<
                    T0: ::core::marker::Copy + Copy,
                    T1: ::core::marker::Copy + Copy,
                > ::core::marker::Copy for LowerPayloadRedisParameter<T0, T1> {}
                unsafe impl wasmtime::component::ComponentType for RedisParameter {
                    type Lower = LowerRedisParameter<
                        <i64 as wasmtime::component::ComponentType>::Lower,
                        <Payload as wasmtime::component::ComponentType>::Lower,
                    >;
                    #[inline]
                    fn typecheck(
                        ty: &wasmtime::component::__internal::InterfaceType,
                        types: &wasmtime::component::__internal::InstanceType<'_>,
                    ) -> wasmtime::component::__internal::anyhow::Result<()> {
                        wasmtime::component::__internal::typecheck_variant(
                            ty,
                            types,
                            &[
                                (
                                    "int64",
                                    Some(<i64 as wasmtime::component::ComponentType>::typecheck),
                                ),
                                (
                                    "binary",
                                    Some(
                                        <Payload as wasmtime::component::ComponentType>::typecheck,
                                    ),
                                ),
                            ],
                        )
                    }
                    const ABI: wasmtime::component::__internal::CanonicalAbiInfo = wasmtime::component::__internal::CanonicalAbiInfo::variant_static(
                        &[
                            Some(<i64 as wasmtime::component::ComponentType>::ABI),
                            Some(<Payload as wasmtime::component::ComponentType>::ABI),
                        ],
                    );
                }
                unsafe impl wasmtime::component::__internal::ComponentVariant
                for RedisParameter {
                    const CASES: &'static [Option<
                        wasmtime::component::__internal::CanonicalAbiInfo,
                    >] = &[
                        Some(<i64 as wasmtime::component::ComponentType>::ABI),
                        Some(<Payload as wasmtime::component::ComponentType>::ABI),
                    ];
                }
            };
            impl core::fmt::Debug for RedisParameter {
                fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
                    match self {
                        RedisParameter::Int64(e) => {
                            f.debug_tuple("RedisParameter::Int64").field(e).finish()
                        }
                        RedisParameter::Binary(e) => {
                            f.debug_tuple("RedisParameter::Binary").field(e).finish()
                        }
                    }
                }
            }
            const _: () = {
                if !(16
                    == <RedisParameter as wasmtime::component::ComponentType>::SIZE32)
                {
                    ::core::panicking::panic(
                        "assertion failed: 16 == <RedisParameter as wasmtime::component::ComponentType>::SIZE32",
                    )
                }
                if !(8
                    == <RedisParameter as wasmtime::component::ComponentType>::ALIGN32)
                {
                    ::core::panicking::panic(
                        "assertion failed: 8 == <RedisParameter as wasmtime::component::ComponentType>::ALIGN32",
                    )
                }
            };
            #[component(variant)]
            pub enum RedisResult {
                #[component(name = "nil")]
                Nil,
                #[component(name = "status")]
                Status(String),
                #[component(name = "int64")]
                Int64(i64),
                #[component(name = "binary")]
                Binary(Payload),
            }
            #[automatically_derived]
            impl ::core::clone::Clone for RedisResult {
                #[inline]
                fn clone(&self) -> RedisResult {
                    match self {
                        RedisResult::Nil => RedisResult::Nil,
                        RedisResult::Status(__self_0) => {
                            RedisResult::Status(::core::clone::Clone::clone(__self_0))
                        }
                        RedisResult::Int64(__self_0) => {
                            RedisResult::Int64(::core::clone::Clone::clone(__self_0))
                        }
                        RedisResult::Binary(__self_0) => {
                            RedisResult::Binary(::core::clone::Clone::clone(__self_0))
                        }
                    }
                }
            }
            unsafe impl wasmtime::component::Lower for RedisResult {
                #[inline]
                fn lower<T>(
                    &self,
                    cx: &mut wasmtime::component::__internal::LowerContext<'_, T>,
                    ty: wasmtime::component::__internal::InterfaceType,
                    dst: &mut std::mem::MaybeUninit<Self::Lower>,
                ) -> wasmtime::component::__internal::anyhow::Result<()> {
                    let ty = match ty {
                        wasmtime::component::__internal::InterfaceType::Variant(i) => {
                            &cx.types[i]
                        }
                        _ => wasmtime::component::__internal::bad_type_info(),
                    };
                    match self {
                        Self::Nil => {
                            {
                                #[allow(unused_unsafe)]
                                {
                                    unsafe {
                                        use ::wasmtime::component::__internal::MaybeUninitExt;
                                        let m: &mut std::mem::MaybeUninit<_> = dst;
                                        m.map(|p| &raw mut (*p).tag)
                                    }
                                }
                            }
                                .write(wasmtime::ValRaw::u32(0u32));
                            unsafe {
                                wasmtime::component::__internal::lower_payload(
                                    {
                                        #[allow(unused_unsafe)]
                                        {
                                            unsafe {
                                                use ::wasmtime::component::__internal::MaybeUninitExt;
                                                let m: &mut std::mem::MaybeUninit<_> = dst;
                                                m.map(|p| &raw mut (*p).payload)
                                            }
                                        }
                                    },
                                    |payload| {
                                        #[allow(unused_unsafe)]
                                        {
                                            unsafe {
                                                use ::wasmtime::component::__internal::MaybeUninitExt;
                                                let m: &mut std::mem::MaybeUninit<_> = payload;
                                                m.map(|p| &raw mut (*p).Nil)
                                            }
                                        }
                                    },
                                    |dst| Ok(()),
                                )
                            }
                        }
                        Self::Status(value) => {
                            {
                                #[allow(unused_unsafe)]
                                {
                                    unsafe {
                                        use ::wasmtime::component::__internal::MaybeUninitExt;
                                        let m: &mut std::mem::MaybeUninit<_> = dst;
                                        m.map(|p| &raw mut (*p).tag)
                                    }
                                }
                            }
                                .write(wasmtime::ValRaw::u32(1u32));
                            unsafe {
                                wasmtime::component::__internal::lower_payload(
                                    {
                                        #[allow(unused_unsafe)]
                                        {
                                            unsafe {
                                                use ::wasmtime::component::__internal::MaybeUninitExt;
                                                let m: &mut std::mem::MaybeUninit<_> = dst;
                                                m.map(|p| &raw mut (*p).payload)
                                            }
                                        }
                                    },
                                    |payload| {
                                        #[allow(unused_unsafe)]
                                        {
                                            unsafe {
                                                use ::wasmtime::component::__internal::MaybeUninitExt;
                                                let m: &mut std::mem::MaybeUninit<_> = payload;
                                                m.map(|p| &raw mut (*p).Status)
                                            }
                                        }
                                    },
                                    |dst| {
                                        value
                                            .lower(
                                                cx,
                                                ty
                                                    .cases[1usize]
                                                    .ty
                                                    .unwrap_or_else(
                                                        wasmtime::component::__internal::bad_type_info,
                                                    ),
                                                dst,
                                            )
                                    },
                                )
                            }
                        }
                        Self::Int64(value) => {
                            {
                                #[allow(unused_unsafe)]
                                {
                                    unsafe {
                                        use ::wasmtime::component::__internal::MaybeUninitExt;
                                        let m: &mut std::mem::MaybeUninit<_> = dst;
                                        m.map(|p| &raw mut (*p).tag)
                                    }
                                }
                            }
                                .write(wasmtime::ValRaw::u32(2u32));
                            unsafe {
                                wasmtime::component::__internal::lower_payload(
                                    {
                                        #[allow(unused_unsafe)]
                                        {
                                            unsafe {
                                                use ::wasmtime::component::__internal::MaybeUninitExt;
                                                let m: &mut std::mem::MaybeUninit<_> = dst;
                                                m.map(|p| &raw mut (*p).payload)
                                            }
                                        }
                                    },
                                    |payload| {
                                        #[allow(unused_unsafe)]
                                        {
                                            unsafe {
                                                use ::wasmtime::component::__internal::MaybeUninitExt;
                                                let m: &mut std::mem::MaybeUninit<_> = payload;
                                                m.map(|p| &raw mut (*p).Int64)
                                            }
                                        }
                                    },
                                    |dst| {
                                        value
                                            .lower(
                                                cx,
                                                ty
                                                    .cases[2usize]
                                                    .ty
                                                    .unwrap_or_else(
                                                        wasmtime::component::__internal::bad_type_info,
                                                    ),
                                                dst,
                                            )
                                    },
                                )
                            }
                        }
                        Self::Binary(value) => {
                            {
                                #[allow(unused_unsafe)]
                                {
                                    unsafe {
                                        use ::wasmtime::component::__internal::MaybeUninitExt;
                                        let m: &mut std::mem::MaybeUninit<_> = dst;
                                        m.map(|p| &raw mut (*p).tag)
                                    }
                                }
                            }
                                .write(wasmtime::ValRaw::u32(3u32));
                            unsafe {
                                wasmtime::component::__internal::lower_payload(
                                    {
                                        #[allow(unused_unsafe)]
                                        {
                                            unsafe {
                                                use ::wasmtime::component::__internal::MaybeUninitExt;
                                                let m: &mut std::mem::MaybeUninit<_> = dst;
                                                m.map(|p| &raw mut (*p).payload)
                                            }
                                        }
                                    },
                                    |payload| {
                                        #[allow(unused_unsafe)]
                                        {
                                            unsafe {
                                                use ::wasmtime::component::__internal::MaybeUninitExt;
                                                let m: &mut std::mem::MaybeUninit<_> = payload;
                                                m.map(|p| &raw mut (*p).Binary)
                                            }
                                        }
                                    },
                                    |dst| {
                                        value
                                            .lower(
                                                cx,
                                                ty
                                                    .cases[3usize]
                                                    .ty
                                                    .unwrap_or_else(
                                                        wasmtime::component::__internal::bad_type_info,
                                                    ),
                                                dst,
                                            )
                                    },
                                )
                            }
                        }
                    }
                }
                #[inline]
                fn store<T>(
                    &self,
                    cx: &mut wasmtime::component::__internal::LowerContext<'_, T>,
                    ty: wasmtime::component::__internal::InterfaceType,
                    mut offset: usize,
                ) -> wasmtime::component::__internal::anyhow::Result<()> {
                    let ty = match ty {
                        wasmtime::component::__internal::InterfaceType::Variant(i) => {
                            &cx.types[i]
                        }
                        _ => wasmtime::component::__internal::bad_type_info(),
                    };
                    if true {
                        if !(offset
                            % (<Self as wasmtime::component::ComponentType>::ALIGN32
                                as usize) == 0)
                        {
                            ::core::panicking::panic(
                                "assertion failed: offset % (<Self as wasmtime::component::ComponentType>::ALIGN32 as usize) == 0",
                            )
                        }
                    }
                    match self {
                        Self::Nil => {
                            *cx.get::<1usize>(offset) = 0u8.to_le_bytes();
                            Ok(())
                        }
                        Self::Status(value) => {
                            *cx.get::<1usize>(offset) = 1u8.to_le_bytes();
                            value
                                .store(
                                    cx,
                                    ty
                                        .cases[1usize]
                                        .ty
                                        .unwrap_or_else(
                                            wasmtime::component::__internal::bad_type_info,
                                        ),
                                    offset
                                        + <Self as wasmtime::component::__internal::ComponentVariant>::PAYLOAD_OFFSET32,
                                )
                        }
                        Self::Int64(value) => {
                            *cx.get::<1usize>(offset) = 2u8.to_le_bytes();
                            value
                                .store(
                                    cx,
                                    ty
                                        .cases[2usize]
                                        .ty
                                        .unwrap_or_else(
                                            wasmtime::component::__internal::bad_type_info,
                                        ),
                                    offset
                                        + <Self as wasmtime::component::__internal::ComponentVariant>::PAYLOAD_OFFSET32,
                                )
                        }
                        Self::Binary(value) => {
                            *cx.get::<1usize>(offset) = 3u8.to_le_bytes();
                            value
                                .store(
                                    cx,
                                    ty
                                        .cases[3usize]
                                        .ty
                                        .unwrap_or_else(
                                            wasmtime::component::__internal::bad_type_info,
                                        ),
                                    offset
                                        + <Self as wasmtime::component::__internal::ComponentVariant>::PAYLOAD_OFFSET32,
                                )
                        }
                    }
                }
            }
            unsafe impl wasmtime::component::Lift for RedisResult {
                #[inline]
                fn lift(
                    cx: &mut wasmtime::component::__internal::LiftContext<'_>,
                    ty: wasmtime::component::__internal::InterfaceType,
                    src: &Self::Lower,
                ) -> wasmtime::component::__internal::anyhow::Result<Self> {
                    let ty = match ty {
                        wasmtime::component::__internal::InterfaceType::Variant(i) => {
                            &cx.types[i]
                        }
                        _ => wasmtime::component::__internal::bad_type_info(),
                    };
                    Ok(
                        match src.tag.get_u32() {
                            0u32 => Self::Nil,
                            1u32 => {
                                Self::Status(
                                    <String as wasmtime::component::Lift>::lift(
                                        cx,
                                        ty
                                            .cases[1usize]
                                            .ty
                                            .unwrap_or_else(
                                                wasmtime::component::__internal::bad_type_info,
                                            ),
                                        unsafe { &src.payload.Status },
                                    )?,
                                )
                            }
                            2u32 => {
                                Self::Int64(
                                    <i64 as wasmtime::component::Lift>::lift(
                                        cx,
                                        ty
                                            .cases[2usize]
                                            .ty
                                            .unwrap_or_else(
                                                wasmtime::component::__internal::bad_type_info,
                                            ),
                                        unsafe { &src.payload.Int64 },
                                    )?,
                                )
                            }
                            3u32 => {
                                Self::Binary(
                                    <Payload as wasmtime::component::Lift>::lift(
                                        cx,
                                        ty
                                            .cases[3usize]
                                            .ty
                                            .unwrap_or_else(
                                                wasmtime::component::__internal::bad_type_info,
                                            ),
                                        unsafe { &src.payload.Binary },
                                    )?,
                                )
                            }
                            discrim => {
                                return ::anyhow::__private::Err(
                                    ::anyhow::Error::msg({
                                        let res = ::alloc::fmt::format(
                                            format_args!("unexpected discriminant: {0}", discrim),
                                        );
                                        res
                                    }),
                                );
                            }
                        },
                    )
                }
                #[inline]
                fn load(
                    cx: &mut wasmtime::component::__internal::LiftContext<'_>,
                    ty: wasmtime::component::__internal::InterfaceType,
                    bytes: &[u8],
                ) -> wasmtime::component::__internal::anyhow::Result<Self> {
                    let align = <Self as wasmtime::component::ComponentType>::ALIGN32;
                    if true {
                        if !((bytes.as_ptr() as usize) % (align as usize) == 0) {
                            ::core::panicking::panic(
                                "assertion failed: (bytes.as_ptr() as usize) % (align as usize) == 0",
                            )
                        }
                    }
                    let discrim = bytes[0];
                    let payload_offset = <Self as wasmtime::component::__internal::ComponentVariant>::PAYLOAD_OFFSET32;
                    let payload = &bytes[payload_offset..];
                    let ty = match ty {
                        wasmtime::component::__internal::InterfaceType::Variant(i) => {
                            &cx.types[i]
                        }
                        _ => wasmtime::component::__internal::bad_type_info(),
                    };
                    Ok(
                        match discrim {
                            0u8 => Self::Nil,
                            1u8 => {
                                Self::Status(
                                    <String as wasmtime::component::Lift>::load(
                                        cx,
                                        ty
                                            .cases[1usize]
                                            .ty
                                            .unwrap_or_else(
                                                wasmtime::component::__internal::bad_type_info,
                                            ),
                                        &payload[..<String as wasmtime::component::ComponentType>::SIZE32],
                                    )?,
                                )
                            }
                            2u8 => {
                                Self::Int64(
                                    <i64 as wasmtime::component::Lift>::load(
                                        cx,
                                        ty
                                            .cases[2usize]
                                            .ty
                                            .unwrap_or_else(
                                                wasmtime::component::__internal::bad_type_info,
                                            ),
                                        &payload[..<i64 as wasmtime::component::ComponentType>::SIZE32],
                                    )?,
                                )
                            }
                            3u8 => {
                                Self::Binary(
                                    <Payload as wasmtime::component::Lift>::load(
                                        cx,
                                        ty
                                            .cases[3usize]
                                            .ty
                                            .unwrap_or_else(
                                                wasmtime::component::__internal::bad_type_info,
                                            ),
                                        &payload[..<Payload as wasmtime::component::ComponentType>::SIZE32],
                                    )?,
                                )
                            }
                            discrim => {
                                return ::anyhow::__private::Err(
                                    ::anyhow::Error::msg({
                                        let res = ::alloc::fmt::format(
                                            format_args!("unexpected discriminant: {0}", discrim),
                                        );
                                        res
                                    }),
                                );
                            }
                        },
                    )
                }
            }
            const _: () = {
                #[doc(hidden)]
                #[repr(C)]
                pub struct LowerRedisResult<T1: Copy, T2: Copy, T3: Copy> {
                    tag: wasmtime::ValRaw,
                    payload: LowerPayloadRedisResult<T1, T2, T3>,
                }
                #[automatically_derived]
                impl<
                    T1: ::core::clone::Clone + Copy,
                    T2: ::core::clone::Clone + Copy,
                    T3: ::core::clone::Clone + Copy,
                > ::core::clone::Clone for LowerRedisResult<T1, T2, T3> {
                    #[inline]
                    fn clone(&self) -> LowerRedisResult<T1, T2, T3> {
                        LowerRedisResult {
                            tag: ::core::clone::Clone::clone(&self.tag),
                            payload: ::core::clone::Clone::clone(&self.payload),
                        }
                    }
                }
                #[automatically_derived]
                impl<
                    T1: ::core::marker::Copy + Copy,
                    T2: ::core::marker::Copy + Copy,
                    T3: ::core::marker::Copy + Copy,
                > ::core::marker::Copy for LowerRedisResult<T1, T2, T3> {}
                #[doc(hidden)]
                #[allow(non_snake_case)]
                #[repr(C)]
                union LowerPayloadRedisResult<T1: Copy, T2: Copy, T3: Copy> {
                    Nil: [wasmtime::ValRaw; 0],
                    Status: T1,
                    Int64: T2,
                    Binary: T3,
                }
                #[automatically_derived]
                #[allow(non_snake_case)]
                impl<
                    T1: ::core::marker::Copy + ::core::clone::Clone + Copy,
                    T2: ::core::marker::Copy + ::core::clone::Clone + Copy,
                    T3: ::core::marker::Copy + ::core::clone::Clone + Copy,
                > ::core::clone::Clone for LowerPayloadRedisResult<T1, T2, T3> {
                    #[inline]
                    fn clone(&self) -> LowerPayloadRedisResult<T1, T2, T3> {
                        let _: ::core::clone::AssertParamIsCopy<Self>;
                        *self
                    }
                }
                #[automatically_derived]
                #[allow(non_snake_case)]
                impl<
                    T1: ::core::marker::Copy + Copy,
                    T2: ::core::marker::Copy + Copy,
                    T3: ::core::marker::Copy + Copy,
                > ::core::marker::Copy for LowerPayloadRedisResult<T1, T2, T3> {}
                unsafe impl wasmtime::component::ComponentType for RedisResult {
                    type Lower = LowerRedisResult<
                        <String as wasmtime::component::ComponentType>::Lower,
                        <i64 as wasmtime::component::ComponentType>::Lower,
                        <Payload as wasmtime::component::ComponentType>::Lower,
                    >;
                    #[inline]
                    fn typecheck(
                        ty: &wasmtime::component::__internal::InterfaceType,
                        types: &wasmtime::component::__internal::InstanceType<'_>,
                    ) -> wasmtime::component::__internal::anyhow::Result<()> {
                        wasmtime::component::__internal::typecheck_variant(
                            ty,
                            types,
                            &[
                                ("nil", None),
                                (
                                    "status",
                                    Some(
                                        <String as wasmtime::component::ComponentType>::typecheck,
                                    ),
                                ),
                                (
                                    "int64",
                                    Some(<i64 as wasmtime::component::ComponentType>::typecheck),
                                ),
                                (
                                    "binary",
                                    Some(
                                        <Payload as wasmtime::component::ComponentType>::typecheck,
                                    ),
                                ),
                            ],
                        )
                    }
                    const ABI: wasmtime::component::__internal::CanonicalAbiInfo = wasmtime::component::__internal::CanonicalAbiInfo::variant_static(
                        &[
                            None,
                            Some(<String as wasmtime::component::ComponentType>::ABI),
                            Some(<i64 as wasmtime::component::ComponentType>::ABI),
                            Some(<Payload as wasmtime::component::ComponentType>::ABI),
                        ],
                    );
                }
                unsafe impl wasmtime::component::__internal::ComponentVariant
                for RedisResult {
                    const CASES: &'static [Option<
                        wasmtime::component::__internal::CanonicalAbiInfo,
                    >] = &[
                        None,
                        Some(<String as wasmtime::component::ComponentType>::ABI),
                        Some(<i64 as wasmtime::component::ComponentType>::ABI),
                        Some(<Payload as wasmtime::component::ComponentType>::ABI),
                    ];
                }
            };
            impl core::fmt::Debug for RedisResult {
                fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
                    match self {
                        RedisResult::Nil => f.debug_tuple("RedisResult::Nil").finish(),
                        RedisResult::Status(e) => {
                            f.debug_tuple("RedisResult::Status").field(e).finish()
                        }
                        RedisResult::Int64(e) => {
                            f.debug_tuple("RedisResult::Int64").field(e).finish()
                        }
                        RedisResult::Binary(e) => {
                            f.debug_tuple("RedisResult::Binary").field(e).finish()
                        }
                    }
                }
            }
            const _: () = {
                if !(16 == <RedisResult as wasmtime::component::ComponentType>::SIZE32) {
                    ::core::panicking::panic(
                        "assertion failed: 16 == <RedisResult as wasmtime::component::ComponentType>::SIZE32",
                    )
                }
                if !(8 == <RedisResult as wasmtime::component::ComponentType>::ALIGN32) {
                    ::core::panicking::panic(
                        "assertion failed: 8 == <RedisResult as wasmtime::component::ComponentType>::ALIGN32",
                    )
                }
            };
            pub trait Host {}
            pub fn add_to_linker<T, U>(
                linker: &mut wasmtime::component::Linker<T>,
                get: impl Fn(&mut T) -> &mut U + Send + Sync + Copy + 'static,
            ) -> wasmtime::Result<()>
            where
                T: Send,
                U: Host + Send,
            {
                let mut inst = linker.instance("fermyon:spin/redis-types")?;
                Ok(())
            }
        }
        #[allow(clippy::all)]
        pub mod config {
            #[allow(unused_imports)]
            use wasmtime::component::__internal::anyhow;
            #[component(variant)]
            pub enum Error {
                #[component(name = "provider")]
                Provider(String),
                #[component(name = "invalid-key")]
                InvalidKey(String),
                #[component(name = "invalid-schema")]
                InvalidSchema(String),
                #[component(name = "other")]
                Other(String),
            }
            #[automatically_derived]
            impl ::core::clone::Clone for Error {
                #[inline]
                fn clone(&self) -> Error {
                    match self {
                        Error::Provider(__self_0) => {
                            Error::Provider(::core::clone::Clone::clone(__self_0))
                        }
                        Error::InvalidKey(__self_0) => {
                            Error::InvalidKey(::core::clone::Clone::clone(__self_0))
                        }
                        Error::InvalidSchema(__self_0) => {
                            Error::InvalidSchema(::core::clone::Clone::clone(__self_0))
                        }
                        Error::Other(__self_0) => {
                            Error::Other(::core::clone::Clone::clone(__self_0))
                        }
                    }
                }
            }
            unsafe impl wasmtime::component::Lower for Error {
                #[inline]
                fn lower<T>(
                    &self,
                    cx: &mut wasmtime::component::__internal::LowerContext<'_, T>,
                    ty: wasmtime::component::__internal::InterfaceType,
                    dst: &mut std::mem::MaybeUninit<Self::Lower>,
                ) -> wasmtime::component::__internal::anyhow::Result<()> {
                    let ty = match ty {
                        wasmtime::component::__internal::InterfaceType::Variant(i) => {
                            &cx.types[i]
                        }
                        _ => wasmtime::component::__internal::bad_type_info(),
                    };
                    match self {
                        Self::Provider(value) => {
                            {
                                #[allow(unused_unsafe)]
                                {
                                    unsafe {
                                        use ::wasmtime::component::__internal::MaybeUninitExt;
                                        let m: &mut std::mem::MaybeUninit<_> = dst;
                                        m.map(|p| &raw mut (*p).tag)
                                    }
                                }
                            }
                                .write(wasmtime::ValRaw::u32(0u32));
                            unsafe {
                                wasmtime::component::__internal::lower_payload(
                                    {
                                        #[allow(unused_unsafe)]
                                        {
                                            unsafe {
                                                use ::wasmtime::component::__internal::MaybeUninitExt;
                                                let m: &mut std::mem::MaybeUninit<_> = dst;
                                                m.map(|p| &raw mut (*p).payload)
                                            }
                                        }
                                    },
                                    |payload| {
                                        #[allow(unused_unsafe)]
                                        {
                                            unsafe {
                                                use ::wasmtime::component::__internal::MaybeUninitExt;
                                                let m: &mut std::mem::MaybeUninit<_> = payload;
                                                m.map(|p| &raw mut (*p).Provider)
                                            }
                                        }
                                    },
                                    |dst| {
                                        value
                                            .lower(
                                                cx,
                                                ty
                                                    .cases[0usize]
                                                    .ty
                                                    .unwrap_or_else(
                                                        wasmtime::component::__internal::bad_type_info,
                                                    ),
                                                dst,
                                            )
                                    },
                                )
                            }
                        }
                        Self::InvalidKey(value) => {
                            {
                                #[allow(unused_unsafe)]
                                {
                                    unsafe {
                                        use ::wasmtime::component::__internal::MaybeUninitExt;
                                        let m: &mut std::mem::MaybeUninit<_> = dst;
                                        m.map(|p| &raw mut (*p).tag)
                                    }
                                }
                            }
                                .write(wasmtime::ValRaw::u32(1u32));
                            unsafe {
                                wasmtime::component::__internal::lower_payload(
                                    {
                                        #[allow(unused_unsafe)]
                                        {
                                            unsafe {
                                                use ::wasmtime::component::__internal::MaybeUninitExt;
                                                let m: &mut std::mem::MaybeUninit<_> = dst;
                                                m.map(|p| &raw mut (*p).payload)
                                            }
                                        }
                                    },
                                    |payload| {
                                        #[allow(unused_unsafe)]
                                        {
                                            unsafe {
                                                use ::wasmtime::component::__internal::MaybeUninitExt;
                                                let m: &mut std::mem::MaybeUninit<_> = payload;
                                                m.map(|p| &raw mut (*p).InvalidKey)
                                            }
                                        }
                                    },
                                    |dst| {
                                        value
                                            .lower(
                                                cx,
                                                ty
                                                    .cases[1usize]
                                                    .ty
                                                    .unwrap_or_else(
                                                        wasmtime::component::__internal::bad_type_info,
                                                    ),
                                                dst,
                                            )
                                    },
                                )
                            }
                        }
                        Self::InvalidSchema(value) => {
                            {
                                #[allow(unused_unsafe)]
                                {
                                    unsafe {
                                        use ::wasmtime::component::__internal::MaybeUninitExt;
                                        let m: &mut std::mem::MaybeUninit<_> = dst;
                                        m.map(|p| &raw mut (*p).tag)
                                    }
                                }
                            }
                                .write(wasmtime::ValRaw::u32(2u32));
                            unsafe {
                                wasmtime::component::__internal::lower_payload(
                                    {
                                        #[allow(unused_unsafe)]
                                        {
                                            unsafe {
                                                use ::wasmtime::component::__internal::MaybeUninitExt;
                                                let m: &mut std::mem::MaybeUninit<_> = dst;
                                                m.map(|p| &raw mut (*p).payload)
                                            }
                                        }
                                    },
                                    |payload| {
                                        #[allow(unused_unsafe)]
                                        {
                                            unsafe {
                                                use ::wasmtime::component::__internal::MaybeUninitExt;
                                                let m: &mut std::mem::MaybeUninit<_> = payload;
                                                m.map(|p| &raw mut (*p).InvalidSchema)
                                            }
                                        }
                                    },
                                    |dst| {
                                        value
                                            .lower(
                                                cx,
                                                ty
                                                    .cases[2usize]
                                                    .ty
                                                    .unwrap_or_else(
                                                        wasmtime::component::__internal::bad_type_info,
                                                    ),
                                                dst,
                                            )
                                    },
                                )
                            }
                        }
                        Self::Other(value) => {
                            {
                                #[allow(unused_unsafe)]
                                {
                                    unsafe {
                                        use ::wasmtime::component::__internal::MaybeUninitExt;
                                        let m: &mut std::mem::MaybeUninit<_> = dst;
                                        m.map(|p| &raw mut (*p).tag)
                                    }
                                }
                            }
                                .write(wasmtime::ValRaw::u32(3u32));
                            unsafe {
                                wasmtime::component::__internal::lower_payload(
                                    {
                                        #[allow(unused_unsafe)]
                                        {
                                            unsafe {
                                                use ::wasmtime::component::__internal::MaybeUninitExt;
                                                let m: &mut std::mem::MaybeUninit<_> = dst;
                                                m.map(|p| &raw mut (*p).payload)
                                            }
                                        }
                                    },
                                    |payload| {
                                        #[allow(unused_unsafe)]
                                        {
                                            unsafe {
                                                use ::wasmtime::component::__internal::MaybeUninitExt;
                                                let m: &mut std::mem::MaybeUninit<_> = payload;
                                                m.map(|p| &raw mut (*p).Other)
                                            }
                                        }
                                    },
                                    |dst| {
                                        value
                                            .lower(
                                                cx,
                                                ty
                                                    .cases[3usize]
                                                    .ty
                                                    .unwrap_or_else(
                                                        wasmtime::component::__internal::bad_type_info,
                                                    ),
                                                dst,
                                            )
                                    },
                                )
                            }
                        }
                    }
                }
                #[inline]
                fn store<T>(
                    &self,
                    cx: &mut wasmtime::component::__internal::LowerContext<'_, T>,
                    ty: wasmtime::component::__internal::InterfaceType,
                    mut offset: usize,
                ) -> wasmtime::component::__internal::anyhow::Result<()> {
                    let ty = match ty {
                        wasmtime::component::__internal::InterfaceType::Variant(i) => {
                            &cx.types[i]
                        }
                        _ => wasmtime::component::__internal::bad_type_info(),
                    };
                    if true {
                        if !(offset
                            % (<Self as wasmtime::component::ComponentType>::ALIGN32
                                as usize) == 0)
                        {
                            ::core::panicking::panic(
                                "assertion failed: offset % (<Self as wasmtime::component::ComponentType>::ALIGN32 as usize) == 0",
                            )
                        }
                    }
                    match self {
                        Self::Provider(value) => {
                            *cx.get::<1usize>(offset) = 0u8.to_le_bytes();
                            value
                                .store(
                                    cx,
                                    ty
                                        .cases[0usize]
                                        .ty
                                        .unwrap_or_else(
                                            wasmtime::component::__internal::bad_type_info,
                                        ),
                                    offset
                                        + <Self as wasmtime::component::__internal::ComponentVariant>::PAYLOAD_OFFSET32,
                                )
                        }
                        Self::InvalidKey(value) => {
                            *cx.get::<1usize>(offset) = 1u8.to_le_bytes();
                            value
                                .store(
                                    cx,
                                    ty
                                        .cases[1usize]
                                        .ty
                                        .unwrap_or_else(
                                            wasmtime::component::__internal::bad_type_info,
                                        ),
                                    offset
                                        + <Self as wasmtime::component::__internal::ComponentVariant>::PAYLOAD_OFFSET32,
                                )
                        }
                        Self::InvalidSchema(value) => {
                            *cx.get::<1usize>(offset) = 2u8.to_le_bytes();
                            value
                                .store(
                                    cx,
                                    ty
                                        .cases[2usize]
                                        .ty
                                        .unwrap_or_else(
                                            wasmtime::component::__internal::bad_type_info,
                                        ),
                                    offset
                                        + <Self as wasmtime::component::__internal::ComponentVariant>::PAYLOAD_OFFSET32,
                                )
                        }
                        Self::Other(value) => {
                            *cx.get::<1usize>(offset) = 3u8.to_le_bytes();
                            value
                                .store(
                                    cx,
                                    ty
                                        .cases[3usize]
                                        .ty
                                        .unwrap_or_else(
                                            wasmtime::component::__internal::bad_type_info,
                                        ),
                                    offset
                                        + <Self as wasmtime::component::__internal::ComponentVariant>::PAYLOAD_OFFSET32,
                                )
                        }
                    }
                }
            }
            unsafe impl wasmtime::component::Lift for Error {
                #[inline]
                fn lift(
                    cx: &mut wasmtime::component::__internal::LiftContext<'_>,
                    ty: wasmtime::component::__internal::InterfaceType,
                    src: &Self::Lower,
                ) -> wasmtime::component::__internal::anyhow::Result<Self> {
                    let ty = match ty {
                        wasmtime::component::__internal::InterfaceType::Variant(i) => {
                            &cx.types[i]
                        }
                        _ => wasmtime::component::__internal::bad_type_info(),
                    };
                    Ok(
                        match src.tag.get_u32() {
                            0u32 => {
                                Self::Provider(
                                    <String as wasmtime::component::Lift>::lift(
                                        cx,
                                        ty
                                            .cases[0usize]
                                            .ty
                                            .unwrap_or_else(
                                                wasmtime::component::__internal::bad_type_info,
                                            ),
                                        unsafe { &src.payload.Provider },
                                    )?,
                                )
                            }
                            1u32 => {
                                Self::InvalidKey(
                                    <String as wasmtime::component::Lift>::lift(
                                        cx,
                                        ty
                                            .cases[1usize]
                                            .ty
                                            .unwrap_or_else(
                                                wasmtime::component::__internal::bad_type_info,
                                            ),
                                        unsafe { &src.payload.InvalidKey },
                                    )?,
                                )
                            }
                            2u32 => {
                                Self::InvalidSchema(
                                    <String as wasmtime::component::Lift>::lift(
                                        cx,
                                        ty
                                            .cases[2usize]
                                            .ty
                                            .unwrap_or_else(
                                                wasmtime::component::__internal::bad_type_info,
                                            ),
                                        unsafe { &src.payload.InvalidSchema },
                                    )?,
                                )
                            }
                            3u32 => {
                                Self::Other(
                                    <String as wasmtime::component::Lift>::lift(
                                        cx,
                                        ty
                                            .cases[3usize]
                                            .ty
                                            .unwrap_or_else(
                                                wasmtime::component::__internal::bad_type_info,
                                            ),
                                        unsafe { &src.payload.Other },
                                    )?,
                                )
                            }
                            discrim => {
                                return ::anyhow::__private::Err(
                                    ::anyhow::Error::msg({
                                        let res = ::alloc::fmt::format(
                                            format_args!("unexpected discriminant: {0}", discrim),
                                        );
                                        res
                                    }),
                                );
                            }
                        },
                    )
                }
                #[inline]
                fn load(
                    cx: &mut wasmtime::component::__internal::LiftContext<'_>,
                    ty: wasmtime::component::__internal::InterfaceType,
                    bytes: &[u8],
                ) -> wasmtime::component::__internal::anyhow::Result<Self> {
                    let align = <Self as wasmtime::component::ComponentType>::ALIGN32;
                    if true {
                        if !((bytes.as_ptr() as usize) % (align as usize) == 0) {
                            ::core::panicking::panic(
                                "assertion failed: (bytes.as_ptr() as usize) % (align as usize) == 0",
                            )
                        }
                    }
                    let discrim = bytes[0];
                    let payload_offset = <Self as wasmtime::component::__internal::ComponentVariant>::PAYLOAD_OFFSET32;
                    let payload = &bytes[payload_offset..];
                    let ty = match ty {
                        wasmtime::component::__internal::InterfaceType::Variant(i) => {
                            &cx.types[i]
                        }
                        _ => wasmtime::component::__internal::bad_type_info(),
                    };
                    Ok(
                        match discrim {
                            0u8 => {
                                Self::Provider(
                                    <String as wasmtime::component::Lift>::load(
                                        cx,
                                        ty
                                            .cases[0usize]
                                            .ty
                                            .unwrap_or_else(
                                                wasmtime::component::__internal::bad_type_info,
                                            ),
                                        &payload[..<String as wasmtime::component::ComponentType>::SIZE32],
                                    )?,
                                )
                            }
                            1u8 => {
                                Self::InvalidKey(
                                    <String as wasmtime::component::Lift>::load(
                                        cx,
                                        ty
                                            .cases[1usize]
                                            .ty
                                            .unwrap_or_else(
                                                wasmtime::component::__internal::bad_type_info,
                                            ),
                                        &payload[..<String as wasmtime::component::ComponentType>::SIZE32],
                                    )?,
                                )
                            }
                            2u8 => {
                                Self::InvalidSchema(
                                    <String as wasmtime::component::Lift>::load(
                                        cx,
                                        ty
                                            .cases[2usize]
                                            .ty
                                            .unwrap_or_else(
                                                wasmtime::component::__internal::bad_type_info,
                                            ),
                                        &payload[..<String as wasmtime::component::ComponentType>::SIZE32],
                                    )?,
                                )
                            }
                            3u8 => {
                                Self::Other(
                                    <String as wasmtime::component::Lift>::load(
                                        cx,
                                        ty
                                            .cases[3usize]
                                            .ty
                                            .unwrap_or_else(
                                                wasmtime::component::__internal::bad_type_info,
                                            ),
                                        &payload[..<String as wasmtime::component::ComponentType>::SIZE32],
                                    )?,
                                )
                            }
                            discrim => {
                                return ::anyhow::__private::Err(
                                    ::anyhow::Error::msg({
                                        let res = ::alloc::fmt::format(
                                            format_args!("unexpected discriminant: {0}", discrim),
                                        );
                                        res
                                    }),
                                );
                            }
                        },
                    )
                }
            }
            const _: () = {
                #[doc(hidden)]
                #[repr(C)]
                pub struct LowerError<T0: Copy, T1: Copy, T2: Copy, T3: Copy> {
                    tag: wasmtime::ValRaw,
                    payload: LowerPayloadError<T0, T1, T2, T3>,
                }
                #[automatically_derived]
                impl<
                    T0: ::core::clone::Clone + Copy,
                    T1: ::core::clone::Clone + Copy,
                    T2: ::core::clone::Clone + Copy,
                    T3: ::core::clone::Clone + Copy,
                > ::core::clone::Clone for LowerError<T0, T1, T2, T3> {
                    #[inline]
                    fn clone(&self) -> LowerError<T0, T1, T2, T3> {
                        LowerError {
                            tag: ::core::clone::Clone::clone(&self.tag),
                            payload: ::core::clone::Clone::clone(&self.payload),
                        }
                    }
                }
                #[automatically_derived]
                impl<
                    T0: ::core::marker::Copy + Copy,
                    T1: ::core::marker::Copy + Copy,
                    T2: ::core::marker::Copy + Copy,
                    T3: ::core::marker::Copy + Copy,
                > ::core::marker::Copy for LowerError<T0, T1, T2, T3> {}
                #[doc(hidden)]
                #[allow(non_snake_case)]
                #[repr(C)]
                union LowerPayloadError<T0: Copy, T1: Copy, T2: Copy, T3: Copy> {
                    Provider: T0,
                    InvalidKey: T1,
                    InvalidSchema: T2,
                    Other: T3,
                }
                #[automatically_derived]
                #[allow(non_snake_case)]
                impl<
                    T0: ::core::marker::Copy + ::core::clone::Clone + Copy,
                    T1: ::core::marker::Copy + ::core::clone::Clone + Copy,
                    T2: ::core::marker::Copy + ::core::clone::Clone + Copy,
                    T3: ::core::marker::Copy + ::core::clone::Clone + Copy,
                > ::core::clone::Clone for LowerPayloadError<T0, T1, T2, T3> {
                    #[inline]
                    fn clone(&self) -> LowerPayloadError<T0, T1, T2, T3> {
                        let _: ::core::clone::AssertParamIsCopy<Self>;
                        *self
                    }
                }
                #[automatically_derived]
                #[allow(non_snake_case)]
                impl<
                    T0: ::core::marker::Copy + Copy,
                    T1: ::core::marker::Copy + Copy,
                    T2: ::core::marker::Copy + Copy,
                    T3: ::core::marker::Copy + Copy,
                > ::core::marker::Copy for LowerPayloadError<T0, T1, T2, T3> {}
                unsafe impl wasmtime::component::ComponentType for Error {
                    type Lower = LowerError<
                        <String as wasmtime::component::ComponentType>::Lower,
                        <String as wasmtime::component::ComponentType>::Lower,
                        <String as wasmtime::component::ComponentType>::Lower,
                        <String as wasmtime::component::ComponentType>::Lower,
                    >;
                    #[inline]
                    fn typecheck(
                        ty: &wasmtime::component::__internal::InterfaceType,
                        types: &wasmtime::component::__internal::InstanceType<'_>,
                    ) -> wasmtime::component::__internal::anyhow::Result<()> {
                        wasmtime::component::__internal::typecheck_variant(
                            ty,
                            types,
                            &[
                                (
                                    "provider",
                                    Some(
                                        <String as wasmtime::component::ComponentType>::typecheck,
                                    ),
                                ),
                                (
                                    "invalid-key",
                                    Some(
                                        <String as wasmtime::component::ComponentType>::typecheck,
                                    ),
                                ),
                                (
                                    "invalid-schema",
                                    Some(
                                        <String as wasmtime::component::ComponentType>::typecheck,
                                    ),
                                ),
                                (
                                    "other",
                                    Some(
                                        <String as wasmtime::component::ComponentType>::typecheck,
                                    ),
                                ),
                            ],
                        )
                    }
                    const ABI: wasmtime::component::__internal::CanonicalAbiInfo = wasmtime::component::__internal::CanonicalAbiInfo::variant_static(
                        &[
                            Some(<String as wasmtime::component::ComponentType>::ABI),
                            Some(<String as wasmtime::component::ComponentType>::ABI),
                            Some(<String as wasmtime::component::ComponentType>::ABI),
                            Some(<String as wasmtime::component::ComponentType>::ABI),
                        ],
                    );
                }
                unsafe impl wasmtime::component::__internal::ComponentVariant for Error {
                    const CASES: &'static [Option<
                        wasmtime::component::__internal::CanonicalAbiInfo,
                    >] = &[
                        Some(<String as wasmtime::component::ComponentType>::ABI),
                        Some(<String as wasmtime::component::ComponentType>::ABI),
                        Some(<String as wasmtime::component::ComponentType>::ABI),
                        Some(<String as wasmtime::component::ComponentType>::ABI),
                    ];
                }
            };
            impl core::fmt::Debug for Error {
                fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
                    match self {
                        Error::Provider(e) => {
                            f.debug_tuple("Error::Provider").field(e).finish()
                        }
                        Error::InvalidKey(e) => {
                            f.debug_tuple("Error::InvalidKey").field(e).finish()
                        }
                        Error::InvalidSchema(e) => {
                            f.debug_tuple("Error::InvalidSchema").field(e).finish()
                        }
                        Error::Other(e) => {
                            f.debug_tuple("Error::Other").field(e).finish()
                        }
                    }
                }
            }
            impl core::fmt::Display for Error {
                fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
                    f.write_fmt(format_args!("{0:?}", self))
                }
            }
            impl std::error::Error for Error {}
            const _: () = {
                if !(12 == <Error as wasmtime::component::ComponentType>::SIZE32) {
                    ::core::panicking::panic(
                        "assertion failed: 12 == <Error as wasmtime::component::ComponentType>::SIZE32",
                    )
                }
                if !(4 == <Error as wasmtime::component::ComponentType>::ALIGN32) {
                    ::core::panicking::panic(
                        "assertion failed: 4 == <Error as wasmtime::component::ComponentType>::ALIGN32",
                    )
                }
            };
            pub trait Host {
                #[must_use]
                #[allow(clippy::type_complexity, clippy::type_repetition_in_bounds)]
                fn get_config<'life0, 'async_trait>(
                    &'life0 mut self,
                    key: String,
                ) -> ::core::pin::Pin<
                    Box<
                        dyn ::core::future::Future<
                            Output = wasmtime::Result<Result<String, Error>>,
                        > + ::core::marker::Send + 'async_trait,
                    >,
                >
                where
                    'life0: 'async_trait,
                    Self: 'async_trait;
            }
            pub fn add_to_linker<T, U>(
                linker: &mut wasmtime::component::Linker<T>,
                get: impl Fn(&mut T) -> &mut U + Send + Sync + Copy + 'static,
            ) -> wasmtime::Result<()>
            where
                T: Send,
                U: Host + Send,
            {
                let mut inst = linker.instance("fermyon:spin/config")?;
                inst.func_wrap_async(
                    "get-config",
                    move |
                        mut caller: wasmtime::StoreContextMut<'_, T>,
                        (arg0,): (String,)|
                    Box::new(async move {
                        let host = get(caller.data_mut());
                        let r = Host::get_config(host, arg0).await;
                        Ok((r?,))
                    }),
                )?;
                Ok(())
            }
        }
        #[allow(clippy::all)]
        pub mod http {
            #[allow(unused_imports)]
            use wasmtime::component::__internal::anyhow;
            pub type Request = super::super::super::fermyon::spin::http_types::Request;
            const _: () = {
                if !(40 == <Request as wasmtime::component::ComponentType>::SIZE32) {
                    ::core::panicking::panic(
                        "assertion failed: 40 == <Request as wasmtime::component::ComponentType>::SIZE32",
                    )
                }
                if !(4 == <Request as wasmtime::component::ComponentType>::ALIGN32) {
                    ::core::panicking::panic(
                        "assertion failed: 4 == <Request as wasmtime::component::ComponentType>::ALIGN32",
                    )
                }
            };
            pub type Response = super::super::super::fermyon::spin::http_types::Response;
            const _: () = {
                if !(28 == <Response as wasmtime::component::ComponentType>::SIZE32) {
                    ::core::panicking::panic(
                        "assertion failed: 28 == <Response as wasmtime::component::ComponentType>::SIZE32",
                    )
                }
                if !(4 == <Response as wasmtime::component::ComponentType>::ALIGN32) {
                    ::core::panicking::panic(
                        "assertion failed: 4 == <Response as wasmtime::component::ComponentType>::ALIGN32",
                    )
                }
            };
            pub type HttpError = super::super::super::fermyon::spin::http_types::HttpError;
            const _: () = {
                if !(1 == <HttpError as wasmtime::component::ComponentType>::SIZE32) {
                    ::core::panicking::panic(
                        "assertion failed: 1 == <HttpError as wasmtime::component::ComponentType>::SIZE32",
                    )
                }
                if !(1 == <HttpError as wasmtime::component::ComponentType>::ALIGN32) {
                    ::core::panicking::panic(
                        "assertion failed: 1 == <HttpError as wasmtime::component::ComponentType>::ALIGN32",
                    )
                }
            };
            pub trait Host {
                #[must_use]
                #[allow(clippy::type_complexity, clippy::type_repetition_in_bounds)]
                fn send_request<'life0, 'async_trait>(
                    &'life0 mut self,
                    req: Request,
                ) -> ::core::pin::Pin<
                    Box<
                        dyn ::core::future::Future<
                            Output = wasmtime::Result<Result<Response, HttpError>>,
                        > + ::core::marker::Send + 'async_trait,
                    >,
                >
                where
                    'life0: 'async_trait,
                    Self: 'async_trait;
            }
            pub fn add_to_linker<T, U>(
                linker: &mut wasmtime::component::Linker<T>,
                get: impl Fn(&mut T) -> &mut U + Send + Sync + Copy + 'static,
            ) -> wasmtime::Result<()>
            where
                T: Send,
                U: Host + Send,
            {
                let mut inst = linker.instance("fermyon:spin/http")?;
                inst.func_wrap_async(
                    "send-request",
                    move |
                        mut caller: wasmtime::StoreContextMut<'_, T>,
                        (arg0,): (Request,)|
                    Box::new(async move {
                        let host = get(caller.data_mut());
                        let r = Host::send_request(host, arg0).await;
                        Ok((r?,))
                    }),
                )?;
                Ok(())
            }
        }
        #[allow(clippy::all)]
        pub mod rdbms_types {
            #[allow(unused_imports)]
            use wasmtime::component::__internal::anyhow;
            #[component(enum)]
            pub enum DbDataType {
                #[component(name = "boolean")]
                Boolean,
                #[component(name = "int8")]
                Int8,
                #[component(name = "int16")]
                Int16,
                #[component(name = "int32")]
                Int32,
                #[component(name = "int64")]
                Int64,
                #[component(name = "uint8")]
                Uint8,
                #[component(name = "uint16")]
                Uint16,
                #[component(name = "uint32")]
                Uint32,
                #[component(name = "uint64")]
                Uint64,
                #[component(name = "floating32")]
                Floating32,
                #[component(name = "floating64")]
                Floating64,
                #[component(name = "str")]
                Str,
                #[component(name = "binary")]
                Binary,
                #[component(name = "other")]
                Other,
            }
            #[automatically_derived]
            impl ::core::clone::Clone for DbDataType {
                #[inline]
                fn clone(&self) -> DbDataType {
                    *self
                }
            }
            #[automatically_derived]
            impl ::core::marker::Copy for DbDataType {}
            #[automatically_derived]
            impl ::core::marker::StructuralPartialEq for DbDataType {}
            #[automatically_derived]
            impl ::core::cmp::PartialEq for DbDataType {
                #[inline]
                fn eq(&self, other: &DbDataType) -> bool {
                    let __self_tag = ::core::intrinsics::discriminant_value(self);
                    let __arg1_tag = ::core::intrinsics::discriminant_value(other);
                    __self_tag == __arg1_tag
                }
            }
            #[automatically_derived]
            impl ::core::marker::StructuralEq for DbDataType {}
            #[automatically_derived]
            impl ::core::cmp::Eq for DbDataType {
                #[inline]
                #[doc(hidden)]
                #[no_coverage]
                fn assert_receiver_is_total_eq(&self) -> () {}
            }
            unsafe impl wasmtime::component::Lower for DbDataType {
                #[inline]
                fn lower<T>(
                    &self,
                    cx: &mut wasmtime::component::__internal::LowerContext<'_, T>,
                    ty: wasmtime::component::__internal::InterfaceType,
                    dst: &mut std::mem::MaybeUninit<Self::Lower>,
                ) -> wasmtime::component::__internal::anyhow::Result<()> {
                    let ty = match ty {
                        wasmtime::component::__internal::InterfaceType::Enum(i) => {
                            &cx.types[i]
                        }
                        _ => wasmtime::component::__internal::bad_type_info(),
                    };
                    match self {
                        Self::Boolean => {
                            {
                                #[allow(unused_unsafe)]
                                {
                                    unsafe {
                                        use ::wasmtime::component::__internal::MaybeUninitExt;
                                        let m: &mut std::mem::MaybeUninit<_> = dst;
                                        m.map(|p| &raw mut (*p).tag)
                                    }
                                }
                            }
                                .write(wasmtime::ValRaw::u32(0u32));
                            unsafe {
                                wasmtime::component::__internal::lower_payload(
                                    {
                                        #[allow(unused_unsafe)]
                                        {
                                            unsafe {
                                                use ::wasmtime::component::__internal::MaybeUninitExt;
                                                let m: &mut std::mem::MaybeUninit<_> = dst;
                                                m.map(|p| &raw mut (*p).payload)
                                            }
                                        }
                                    },
                                    |payload| {
                                        #[allow(unused_unsafe)]
                                        {
                                            unsafe {
                                                use ::wasmtime::component::__internal::MaybeUninitExt;
                                                let m: &mut std::mem::MaybeUninit<_> = payload;
                                                m.map(|p| &raw mut (*p).Boolean)
                                            }
                                        }
                                    },
                                    |dst| Ok(()),
                                )
                            }
                        }
                        Self::Int8 => {
                            {
                                #[allow(unused_unsafe)]
                                {
                                    unsafe {
                                        use ::wasmtime::component::__internal::MaybeUninitExt;
                                        let m: &mut std::mem::MaybeUninit<_> = dst;
                                        m.map(|p| &raw mut (*p).tag)
                                    }
                                }
                            }
                                .write(wasmtime::ValRaw::u32(1u32));
                            unsafe {
                                wasmtime::component::__internal::lower_payload(
                                    {
                                        #[allow(unused_unsafe)]
                                        {
                                            unsafe {
                                                use ::wasmtime::component::__internal::MaybeUninitExt;
                                                let m: &mut std::mem::MaybeUninit<_> = dst;
                                                m.map(|p| &raw mut (*p).payload)
                                            }
                                        }
                                    },
                                    |payload| {
                                        #[allow(unused_unsafe)]
                                        {
                                            unsafe {
                                                use ::wasmtime::component::__internal::MaybeUninitExt;
                                                let m: &mut std::mem::MaybeUninit<_> = payload;
                                                m.map(|p| &raw mut (*p).Int8)
                                            }
                                        }
                                    },
                                    |dst| Ok(()),
                                )
                            }
                        }
                        Self::Int16 => {
                            {
                                #[allow(unused_unsafe)]
                                {
                                    unsafe {
                                        use ::wasmtime::component::__internal::MaybeUninitExt;
                                        let m: &mut std::mem::MaybeUninit<_> = dst;
                                        m.map(|p| &raw mut (*p).tag)
                                    }
                                }
                            }
                                .write(wasmtime::ValRaw::u32(2u32));
                            unsafe {
                                wasmtime::component::__internal::lower_payload(
                                    {
                                        #[allow(unused_unsafe)]
                                        {
                                            unsafe {
                                                use ::wasmtime::component::__internal::MaybeUninitExt;
                                                let m: &mut std::mem::MaybeUninit<_> = dst;
                                                m.map(|p| &raw mut (*p).payload)
                                            }
                                        }
                                    },
                                    |payload| {
                                        #[allow(unused_unsafe)]
                                        {
                                            unsafe {
                                                use ::wasmtime::component::__internal::MaybeUninitExt;
                                                let m: &mut std::mem::MaybeUninit<_> = payload;
                                                m.map(|p| &raw mut (*p).Int16)
                                            }
                                        }
                                    },
                                    |dst| Ok(()),
                                )
                            }
                        }
                        Self::Int32 => {
                            {
                                #[allow(unused_unsafe)]
                                {
                                    unsafe {
                                        use ::wasmtime::component::__internal::MaybeUninitExt;
                                        let m: &mut std::mem::MaybeUninit<_> = dst;
                                        m.map(|p| &raw mut (*p).tag)
                                    }
                                }
                            }
                                .write(wasmtime::ValRaw::u32(3u32));
                            unsafe {
                                wasmtime::component::__internal::lower_payload(
                                    {
                                        #[allow(unused_unsafe)]
                                        {
                                            unsafe {
                                                use ::wasmtime::component::__internal::MaybeUninitExt;
                                                let m: &mut std::mem::MaybeUninit<_> = dst;
                                                m.map(|p| &raw mut (*p).payload)
                                            }
                                        }
                                    },
                                    |payload| {
                                        #[allow(unused_unsafe)]
                                        {
                                            unsafe {
                                                use ::wasmtime::component::__internal::MaybeUninitExt;
                                                let m: &mut std::mem::MaybeUninit<_> = payload;
                                                m.map(|p| &raw mut (*p).Int32)
                                            }
                                        }
                                    },
                                    |dst| Ok(()),
                                )
                            }
                        }
                        Self::Int64 => {
                            {
                                #[allow(unused_unsafe)]
                                {
                                    unsafe {
                                        use ::wasmtime::component::__internal::MaybeUninitExt;
                                        let m: &mut std::mem::MaybeUninit<_> = dst;
                                        m.map(|p| &raw mut (*p).tag)
                                    }
                                }
                            }
                                .write(wasmtime::ValRaw::u32(4u32));
                            unsafe {
                                wasmtime::component::__internal::lower_payload(
                                    {
                                        #[allow(unused_unsafe)]
                                        {
                                            unsafe {
                                                use ::wasmtime::component::__internal::MaybeUninitExt;
                                                let m: &mut std::mem::MaybeUninit<_> = dst;
                                                m.map(|p| &raw mut (*p).payload)
                                            }
                                        }
                                    },
                                    |payload| {
                                        #[allow(unused_unsafe)]
                                        {
                                            unsafe {
                                                use ::wasmtime::component::__internal::MaybeUninitExt;
                                                let m: &mut std::mem::MaybeUninit<_> = payload;
                                                m.map(|p| &raw mut (*p).Int64)
                                            }
                                        }
                                    },
                                    |dst| Ok(()),
                                )
                            }
                        }
                        Self::Uint8 => {
                            {
                                #[allow(unused_unsafe)]
                                {
                                    unsafe {
                                        use ::wasmtime::component::__internal::MaybeUninitExt;
                                        let m: &mut std::mem::MaybeUninit<_> = dst;
                                        m.map(|p| &raw mut (*p).tag)
                                    }
                                }
                            }
                                .write(wasmtime::ValRaw::u32(5u32));
                            unsafe {
                                wasmtime::component::__internal::lower_payload(
                                    {
                                        #[allow(unused_unsafe)]
                                        {
                                            unsafe {
                                                use ::wasmtime::component::__internal::MaybeUninitExt;
                                                let m: &mut std::mem::MaybeUninit<_> = dst;
                                                m.map(|p| &raw mut (*p).payload)
                                            }
                                        }
                                    },
                                    |payload| {
                                        #[allow(unused_unsafe)]
                                        {
                                            unsafe {
                                                use ::wasmtime::component::__internal::MaybeUninitExt;
                                                let m: &mut std::mem::MaybeUninit<_> = payload;
                                                m.map(|p| &raw mut (*p).Uint8)
                                            }
                                        }
                                    },
                                    |dst| Ok(()),
                                )
                            }
                        }
                        Self::Uint16 => {
                            {
                                #[allow(unused_unsafe)]
                                {
                                    unsafe {
                                        use ::wasmtime::component::__internal::MaybeUninitExt;
                                        let m: &mut std::mem::MaybeUninit<_> = dst;
                                        m.map(|p| &raw mut (*p).tag)
                                    }
                                }
                            }
                                .write(wasmtime::ValRaw::u32(6u32));
                            unsafe {
                                wasmtime::component::__internal::lower_payload(
                                    {
                                        #[allow(unused_unsafe)]
                                        {
                                            unsafe {
                                                use ::wasmtime::component::__internal::MaybeUninitExt;
                                                let m: &mut std::mem::MaybeUninit<_> = dst;
                                                m.map(|p| &raw mut (*p).payload)
                                            }
                                        }
                                    },
                                    |payload| {
                                        #[allow(unused_unsafe)]
                                        {
                                            unsafe {
                                                use ::wasmtime::component::__internal::MaybeUninitExt;
                                                let m: &mut std::mem::MaybeUninit<_> = payload;
                                                m.map(|p| &raw mut (*p).Uint16)
                                            }
                                        }
                                    },
                                    |dst| Ok(()),
                                )
                            }
                        }
                        Self::Uint32 => {
                            {
                                #[allow(unused_unsafe)]
                                {
                                    unsafe {
                                        use ::wasmtime::component::__internal::MaybeUninitExt;
                                        let m: &mut std::mem::MaybeUninit<_> = dst;
                                        m.map(|p| &raw mut (*p).tag)
                                    }
                                }
                            }
                                .write(wasmtime::ValRaw::u32(7u32));
                            unsafe {
                                wasmtime::component::__internal::lower_payload(
                                    {
                                        #[allow(unused_unsafe)]
                                        {
                                            unsafe {
                                                use ::wasmtime::component::__internal::MaybeUninitExt;
                                                let m: &mut std::mem::MaybeUninit<_> = dst;
                                                m.map(|p| &raw mut (*p).payload)
                                            }
                                        }
                                    },
                                    |payload| {
                                        #[allow(unused_unsafe)]
                                        {
                                            unsafe {
                                                use ::wasmtime::component::__internal::MaybeUninitExt;
                                                let m: &mut std::mem::MaybeUninit<_> = payload;
                                                m.map(|p| &raw mut (*p).Uint32)
                                            }
                                        }
                                    },
                                    |dst| Ok(()),
                                )
                            }
                        }
                        Self::Uint64 => {
                            {
                                #[allow(unused_unsafe)]
                                {
                                    unsafe {
                                        use ::wasmtime::component::__internal::MaybeUninitExt;
                                        let m: &mut std::mem::MaybeUninit<_> = dst;
                                        m.map(|p| &raw mut (*p).tag)
                                    }
                                }
                            }
                                .write(wasmtime::ValRaw::u32(8u32));
                            unsafe {
                                wasmtime::component::__internal::lower_payload(
                                    {
                                        #[allow(unused_unsafe)]
                                        {
                                            unsafe {
                                                use ::wasmtime::component::__internal::MaybeUninitExt;
                                                let m: &mut std::mem::MaybeUninit<_> = dst;
                                                m.map(|p| &raw mut (*p).payload)
                                            }
                                        }
                                    },
                                    |payload| {
                                        #[allow(unused_unsafe)]
                                        {
                                            unsafe {
                                                use ::wasmtime::component::__internal::MaybeUninitExt;
                                                let m: &mut std::mem::MaybeUninit<_> = payload;
                                                m.map(|p| &raw mut (*p).Uint64)
                                            }
                                        }
                                    },
                                    |dst| Ok(()),
                                )
                            }
                        }
                        Self::Floating32 => {
                            {
                                #[allow(unused_unsafe)]
                                {
                                    unsafe {
                                        use ::wasmtime::component::__internal::MaybeUninitExt;
                                        let m: &mut std::mem::MaybeUninit<_> = dst;
                                        m.map(|p| &raw mut (*p).tag)
                                    }
                                }
                            }
                                .write(wasmtime::ValRaw::u32(9u32));
                            unsafe {
                                wasmtime::component::__internal::lower_payload(
                                    {
                                        #[allow(unused_unsafe)]
                                        {
                                            unsafe {
                                                use ::wasmtime::component::__internal::MaybeUninitExt;
                                                let m: &mut std::mem::MaybeUninit<_> = dst;
                                                m.map(|p| &raw mut (*p).payload)
                                            }
                                        }
                                    },
                                    |payload| {
                                        #[allow(unused_unsafe)]
                                        {
                                            unsafe {
                                                use ::wasmtime::component::__internal::MaybeUninitExt;
                                                let m: &mut std::mem::MaybeUninit<_> = payload;
                                                m.map(|p| &raw mut (*p).Floating32)
                                            }
                                        }
                                    },
                                    |dst| Ok(()),
                                )
                            }
                        }
                        Self::Floating64 => {
                            {
                                #[allow(unused_unsafe)]
                                {
                                    unsafe {
                                        use ::wasmtime::component::__internal::MaybeUninitExt;
                                        let m: &mut std::mem::MaybeUninit<_> = dst;
                                        m.map(|p| &raw mut (*p).tag)
                                    }
                                }
                            }
                                .write(wasmtime::ValRaw::u32(10u32));
                            unsafe {
                                wasmtime::component::__internal::lower_payload(
                                    {
                                        #[allow(unused_unsafe)]
                                        {
                                            unsafe {
                                                use ::wasmtime::component::__internal::MaybeUninitExt;
                                                let m: &mut std::mem::MaybeUninit<_> = dst;
                                                m.map(|p| &raw mut (*p).payload)
                                            }
                                        }
                                    },
                                    |payload| {
                                        #[allow(unused_unsafe)]
                                        {
                                            unsafe {
                                                use ::wasmtime::component::__internal::MaybeUninitExt;
                                                let m: &mut std::mem::MaybeUninit<_> = payload;
                                                m.map(|p| &raw mut (*p).Floating64)
                                            }
                                        }
                                    },
                                    |dst| Ok(()),
                                )
                            }
                        }
                        Self::Str => {
                            {
                                #[allow(unused_unsafe)]
                                {
                                    unsafe {
                                        use ::wasmtime::component::__internal::MaybeUninitExt;
                                        let m: &mut std::mem::MaybeUninit<_> = dst;
                                        m.map(|p| &raw mut (*p).tag)
                                    }
                                }
                            }
                                .write(wasmtime::ValRaw::u32(11u32));
                            unsafe {
                                wasmtime::component::__internal::lower_payload(
                                    {
                                        #[allow(unused_unsafe)]
                                        {
                                            unsafe {
                                                use ::wasmtime::component::__internal::MaybeUninitExt;
                                                let m: &mut std::mem::MaybeUninit<_> = dst;
                                                m.map(|p| &raw mut (*p).payload)
                                            }
                                        }
                                    },
                                    |payload| {
                                        #[allow(unused_unsafe)]
                                        {
                                            unsafe {
                                                use ::wasmtime::component::__internal::MaybeUninitExt;
                                                let m: &mut std::mem::MaybeUninit<_> = payload;
                                                m.map(|p| &raw mut (*p).Str)
                                            }
                                        }
                                    },
                                    |dst| Ok(()),
                                )
                            }
                        }
                        Self::Binary => {
                            {
                                #[allow(unused_unsafe)]
                                {
                                    unsafe {
                                        use ::wasmtime::component::__internal::MaybeUninitExt;
                                        let m: &mut std::mem::MaybeUninit<_> = dst;
                                        m.map(|p| &raw mut (*p).tag)
                                    }
                                }
                            }
                                .write(wasmtime::ValRaw::u32(12u32));
                            unsafe {
                                wasmtime::component::__internal::lower_payload(
                                    {
                                        #[allow(unused_unsafe)]
                                        {
                                            unsafe {
                                                use ::wasmtime::component::__internal::MaybeUninitExt;
                                                let m: &mut std::mem::MaybeUninit<_> = dst;
                                                m.map(|p| &raw mut (*p).payload)
                                            }
                                        }
                                    },
                                    |payload| {
                                        #[allow(unused_unsafe)]
                                        {
                                            unsafe {
                                                use ::wasmtime::component::__internal::MaybeUninitExt;
                                                let m: &mut std::mem::MaybeUninit<_> = payload;
                                                m.map(|p| &raw mut (*p).Binary)
                                            }
                                        }
                                    },
                                    |dst| Ok(()),
                                )
                            }
                        }
                        Self::Other => {
                            {
                                #[allow(unused_unsafe)]
                                {
                                    unsafe {
                                        use ::wasmtime::component::__internal::MaybeUninitExt;
                                        let m: &mut std::mem::MaybeUninit<_> = dst;
                                        m.map(|p| &raw mut (*p).tag)
                                    }
                                }
                            }
                                .write(wasmtime::ValRaw::u32(13u32));
                            unsafe {
                                wasmtime::component::__internal::lower_payload(
                                    {
                                        #[allow(unused_unsafe)]
                                        {
                                            unsafe {
                                                use ::wasmtime::component::__internal::MaybeUninitExt;
                                                let m: &mut std::mem::MaybeUninit<_> = dst;
                                                m.map(|p| &raw mut (*p).payload)
                                            }
                                        }
                                    },
                                    |payload| {
                                        #[allow(unused_unsafe)]
                                        {
                                            unsafe {
                                                use ::wasmtime::component::__internal::MaybeUninitExt;
                                                let m: &mut std::mem::MaybeUninit<_> = payload;
                                                m.map(|p| &raw mut (*p).Other)
                                            }
                                        }
                                    },
                                    |dst| Ok(()),
                                )
                            }
                        }
                    }
                }
                #[inline]
                fn store<T>(
                    &self,
                    cx: &mut wasmtime::component::__internal::LowerContext<'_, T>,
                    ty: wasmtime::component::__internal::InterfaceType,
                    mut offset: usize,
                ) -> wasmtime::component::__internal::anyhow::Result<()> {
                    let ty = match ty {
                        wasmtime::component::__internal::InterfaceType::Enum(i) => {
                            &cx.types[i]
                        }
                        _ => wasmtime::component::__internal::bad_type_info(),
                    };
                    if true {
                        if !(offset
                            % (<Self as wasmtime::component::ComponentType>::ALIGN32
                                as usize) == 0)
                        {
                            ::core::panicking::panic(
                                "assertion failed: offset % (<Self as wasmtime::component::ComponentType>::ALIGN32 as usize) == 0",
                            )
                        }
                    }
                    match self {
                        Self::Boolean => {
                            *cx.get::<1usize>(offset) = 0u8.to_le_bytes();
                            Ok(())
                        }
                        Self::Int8 => {
                            *cx.get::<1usize>(offset) = 1u8.to_le_bytes();
                            Ok(())
                        }
                        Self::Int16 => {
                            *cx.get::<1usize>(offset) = 2u8.to_le_bytes();
                            Ok(())
                        }
                        Self::Int32 => {
                            *cx.get::<1usize>(offset) = 3u8.to_le_bytes();
                            Ok(())
                        }
                        Self::Int64 => {
                            *cx.get::<1usize>(offset) = 4u8.to_le_bytes();
                            Ok(())
                        }
                        Self::Uint8 => {
                            *cx.get::<1usize>(offset) = 5u8.to_le_bytes();
                            Ok(())
                        }
                        Self::Uint16 => {
                            *cx.get::<1usize>(offset) = 6u8.to_le_bytes();
                            Ok(())
                        }
                        Self::Uint32 => {
                            *cx.get::<1usize>(offset) = 7u8.to_le_bytes();
                            Ok(())
                        }
                        Self::Uint64 => {
                            *cx.get::<1usize>(offset) = 8u8.to_le_bytes();
                            Ok(())
                        }
                        Self::Floating32 => {
                            *cx.get::<1usize>(offset) = 9u8.to_le_bytes();
                            Ok(())
                        }
                        Self::Floating64 => {
                            *cx.get::<1usize>(offset) = 10u8.to_le_bytes();
                            Ok(())
                        }
                        Self::Str => {
                            *cx.get::<1usize>(offset) = 11u8.to_le_bytes();
                            Ok(())
                        }
                        Self::Binary => {
                            *cx.get::<1usize>(offset) = 12u8.to_le_bytes();
                            Ok(())
                        }
                        Self::Other => {
                            *cx.get::<1usize>(offset) = 13u8.to_le_bytes();
                            Ok(())
                        }
                    }
                }
            }
            unsafe impl wasmtime::component::Lift for DbDataType {
                #[inline]
                fn lift(
                    cx: &mut wasmtime::component::__internal::LiftContext<'_>,
                    ty: wasmtime::component::__internal::InterfaceType,
                    src: &Self::Lower,
                ) -> wasmtime::component::__internal::anyhow::Result<Self> {
                    let ty = match ty {
                        wasmtime::component::__internal::InterfaceType::Enum(i) => {
                            &cx.types[i]
                        }
                        _ => wasmtime::component::__internal::bad_type_info(),
                    };
                    Ok(
                        match src.tag.get_u32() {
                            0u32 => Self::Boolean,
                            1u32 => Self::Int8,
                            2u32 => Self::Int16,
                            3u32 => Self::Int32,
                            4u32 => Self::Int64,
                            5u32 => Self::Uint8,
                            6u32 => Self::Uint16,
                            7u32 => Self::Uint32,
                            8u32 => Self::Uint64,
                            9u32 => Self::Floating32,
                            10u32 => Self::Floating64,
                            11u32 => Self::Str,
                            12u32 => Self::Binary,
                            13u32 => Self::Other,
                            discrim => {
                                return ::anyhow::__private::Err(
                                    ::anyhow::Error::msg({
                                        let res = ::alloc::fmt::format(
                                            format_args!("unexpected discriminant: {0}", discrim),
                                        );
                                        res
                                    }),
                                );
                            }
                        },
                    )
                }
                #[inline]
                fn load(
                    cx: &mut wasmtime::component::__internal::LiftContext<'_>,
                    ty: wasmtime::component::__internal::InterfaceType,
                    bytes: &[u8],
                ) -> wasmtime::component::__internal::anyhow::Result<Self> {
                    let align = <Self as wasmtime::component::ComponentType>::ALIGN32;
                    if true {
                        if !((bytes.as_ptr() as usize) % (align as usize) == 0) {
                            ::core::panicking::panic(
                                "assertion failed: (bytes.as_ptr() as usize) % (align as usize) == 0",
                            )
                        }
                    }
                    let discrim = bytes[0];
                    let payload_offset = <Self as wasmtime::component::__internal::ComponentVariant>::PAYLOAD_OFFSET32;
                    let payload = &bytes[payload_offset..];
                    let ty = match ty {
                        wasmtime::component::__internal::InterfaceType::Enum(i) => {
                            &cx.types[i]
                        }
                        _ => wasmtime::component::__internal::bad_type_info(),
                    };
                    Ok(
                        match discrim {
                            0u8 => Self::Boolean,
                            1u8 => Self::Int8,
                            2u8 => Self::Int16,
                            3u8 => Self::Int32,
                            4u8 => Self::Int64,
                            5u8 => Self::Uint8,
                            6u8 => Self::Uint16,
                            7u8 => Self::Uint32,
                            8u8 => Self::Uint64,
                            9u8 => Self::Floating32,
                            10u8 => Self::Floating64,
                            11u8 => Self::Str,
                            12u8 => Self::Binary,
                            13u8 => Self::Other,
                            discrim => {
                                return ::anyhow::__private::Err(
                                    ::anyhow::Error::msg({
                                        let res = ::alloc::fmt::format(
                                            format_args!("unexpected discriminant: {0}", discrim),
                                        );
                                        res
                                    }),
                                );
                            }
                        },
                    )
                }
            }
            const _: () = {
                #[doc(hidden)]
                #[repr(C)]
                pub struct LowerDbDataType {
                    tag: wasmtime::ValRaw,
                    payload: LowerPayloadDbDataType,
                }
                #[automatically_derived]
                impl ::core::clone::Clone for LowerDbDataType {
                    #[inline]
                    fn clone(&self) -> LowerDbDataType {
                        let _: ::core::clone::AssertParamIsClone<wasmtime::ValRaw>;
                        let _: ::core::clone::AssertParamIsClone<LowerPayloadDbDataType>;
                        *self
                    }
                }
                #[automatically_derived]
                impl ::core::marker::Copy for LowerDbDataType {}
                #[doc(hidden)]
                #[allow(non_snake_case)]
                #[repr(C)]
                union LowerPayloadDbDataType {
                    Boolean: [wasmtime::ValRaw; 0],
                    Int8: [wasmtime::ValRaw; 0],
                    Int16: [wasmtime::ValRaw; 0],
                    Int32: [wasmtime::ValRaw; 0],
                    Int64: [wasmtime::ValRaw; 0],
                    Uint8: [wasmtime::ValRaw; 0],
                    Uint16: [wasmtime::ValRaw; 0],
                    Uint32: [wasmtime::ValRaw; 0],
                    Uint64: [wasmtime::ValRaw; 0],
                    Floating32: [wasmtime::ValRaw; 0],
                    Floating64: [wasmtime::ValRaw; 0],
                    Str: [wasmtime::ValRaw; 0],
                    Binary: [wasmtime::ValRaw; 0],
                    Other: [wasmtime::ValRaw; 0],
                }
                #[automatically_derived]
                #[allow(non_snake_case)]
                impl ::core::clone::Clone for LowerPayloadDbDataType {
                    #[inline]
                    fn clone(&self) -> LowerPayloadDbDataType {
                        let _: ::core::clone::AssertParamIsCopy<Self>;
                        *self
                    }
                }
                #[automatically_derived]
                #[allow(non_snake_case)]
                impl ::core::marker::Copy for LowerPayloadDbDataType {}
                unsafe impl wasmtime::component::ComponentType for DbDataType {
                    type Lower = LowerDbDataType;
                    #[inline]
                    fn typecheck(
                        ty: &wasmtime::component::__internal::InterfaceType,
                        types: &wasmtime::component::__internal::InstanceType<'_>,
                    ) -> wasmtime::component::__internal::anyhow::Result<()> {
                        wasmtime::component::__internal::typecheck_enum(
                            ty,
                            types,
                            &[
                                "boolean",
                                "int8",
                                "int16",
                                "int32",
                                "int64",
                                "uint8",
                                "uint16",
                                "uint32",
                                "uint64",
                                "floating32",
                                "floating64",
                                "str",
                                "binary",
                                "other",
                            ],
                        )
                    }
                    const ABI: wasmtime::component::__internal::CanonicalAbiInfo = wasmtime::component::__internal::CanonicalAbiInfo::variant_static(
                        &[
                            None,
                            None,
                            None,
                            None,
                            None,
                            None,
                            None,
                            None,
                            None,
                            None,
                            None,
                            None,
                            None,
                            None,
                        ],
                    );
                }
                unsafe impl wasmtime::component::__internal::ComponentVariant
                for DbDataType {
                    const CASES: &'static [Option<
                        wasmtime::component::__internal::CanonicalAbiInfo,
                    >] = &[
                        None,
                        None,
                        None,
                        None,
                        None,
                        None,
                        None,
                        None,
                        None,
                        None,
                        None,
                        None,
                        None,
                        None,
                    ];
                }
            };
            impl core::fmt::Debug for DbDataType {
                fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
                    match self {
                        DbDataType::Boolean => {
                            f.debug_tuple("DbDataType::Boolean").finish()
                        }
                        DbDataType::Int8 => f.debug_tuple("DbDataType::Int8").finish(),
                        DbDataType::Int16 => f.debug_tuple("DbDataType::Int16").finish(),
                        DbDataType::Int32 => f.debug_tuple("DbDataType::Int32").finish(),
                        DbDataType::Int64 => f.debug_tuple("DbDataType::Int64").finish(),
                        DbDataType::Uint8 => f.debug_tuple("DbDataType::Uint8").finish(),
                        DbDataType::Uint16 => {
                            f.debug_tuple("DbDataType::Uint16").finish()
                        }
                        DbDataType::Uint32 => {
                            f.debug_tuple("DbDataType::Uint32").finish()
                        }
                        DbDataType::Uint64 => {
                            f.debug_tuple("DbDataType::Uint64").finish()
                        }
                        DbDataType::Floating32 => {
                            f.debug_tuple("DbDataType::Floating32").finish()
                        }
                        DbDataType::Floating64 => {
                            f.debug_tuple("DbDataType::Floating64").finish()
                        }
                        DbDataType::Str => f.debug_tuple("DbDataType::Str").finish(),
                        DbDataType::Binary => {
                            f.debug_tuple("DbDataType::Binary").finish()
                        }
                        DbDataType::Other => f.debug_tuple("DbDataType::Other").finish(),
                    }
                }
            }
            const _: () = {
                if !(1 == <DbDataType as wasmtime::component::ComponentType>::SIZE32) {
                    ::core::panicking::panic(
                        "assertion failed: 1 == <DbDataType as wasmtime::component::ComponentType>::SIZE32",
                    )
                }
                if !(1 == <DbDataType as wasmtime::component::ComponentType>::ALIGN32) {
                    ::core::panicking::panic(
                        "assertion failed: 1 == <DbDataType as wasmtime::component::ComponentType>::ALIGN32",
                    )
                }
            };
            #[component(variant)]
            pub enum DbValue {
                #[component(name = "boolean")]
                Boolean(bool),
                #[component(name = "int8")]
                Int8(i8),
                #[component(name = "int16")]
                Int16(i16),
                #[component(name = "int32")]
                Int32(i32),
                #[component(name = "int64")]
                Int64(i64),
                #[component(name = "uint8")]
                Uint8(u8),
                #[component(name = "uint16")]
                Uint16(u16),
                #[component(name = "uint32")]
                Uint32(u32),
                #[component(name = "uint64")]
                Uint64(u64),
                #[component(name = "floating32")]
                Floating32(f32),
                #[component(name = "floating64")]
                Floating64(f64),
                #[component(name = "str")]
                Str(String),
                #[component(name = "binary")]
                Binary(Vec<u8>),
                #[component(name = "db-null")]
                DbNull,
                #[component(name = "unsupported")]
                Unsupported,
            }
            #[automatically_derived]
            impl ::core::clone::Clone for DbValue {
                #[inline]
                fn clone(&self) -> DbValue {
                    match self {
                        DbValue::Boolean(__self_0) => {
                            DbValue::Boolean(::core::clone::Clone::clone(__self_0))
                        }
                        DbValue::Int8(__self_0) => {
                            DbValue::Int8(::core::clone::Clone::clone(__self_0))
                        }
                        DbValue::Int16(__self_0) => {
                            DbValue::Int16(::core::clone::Clone::clone(__self_0))
                        }
                        DbValue::Int32(__self_0) => {
                            DbValue::Int32(::core::clone::Clone::clone(__self_0))
                        }
                        DbValue::Int64(__self_0) => {
                            DbValue::Int64(::core::clone::Clone::clone(__self_0))
                        }
                        DbValue::Uint8(__self_0) => {
                            DbValue::Uint8(::core::clone::Clone::clone(__self_0))
                        }
                        DbValue::Uint16(__self_0) => {
                            DbValue::Uint16(::core::clone::Clone::clone(__self_0))
                        }
                        DbValue::Uint32(__self_0) => {
                            DbValue::Uint32(::core::clone::Clone::clone(__self_0))
                        }
                        DbValue::Uint64(__self_0) => {
                            DbValue::Uint64(::core::clone::Clone::clone(__self_0))
                        }
                        DbValue::Floating32(__self_0) => {
                            DbValue::Floating32(::core::clone::Clone::clone(__self_0))
                        }
                        DbValue::Floating64(__self_0) => {
                            DbValue::Floating64(::core::clone::Clone::clone(__self_0))
                        }
                        DbValue::Str(__self_0) => {
                            DbValue::Str(::core::clone::Clone::clone(__self_0))
                        }
                        DbValue::Binary(__self_0) => {
                            DbValue::Binary(::core::clone::Clone::clone(__self_0))
                        }
                        DbValue::DbNull => DbValue::DbNull,
                        DbValue::Unsupported => DbValue::Unsupported,
                    }
                }
            }
            unsafe impl wasmtime::component::Lower for DbValue {
                #[inline]
                fn lower<T>(
                    &self,
                    cx: &mut wasmtime::component::__internal::LowerContext<'_, T>,
                    ty: wasmtime::component::__internal::InterfaceType,
                    dst: &mut std::mem::MaybeUninit<Self::Lower>,
                ) -> wasmtime::component::__internal::anyhow::Result<()> {
                    let ty = match ty {
                        wasmtime::component::__internal::InterfaceType::Variant(i) => {
                            &cx.types[i]
                        }
                        _ => wasmtime::component::__internal::bad_type_info(),
                    };
                    match self {
                        Self::Boolean(value) => {
                            {
                                #[allow(unused_unsafe)]
                                {
                                    unsafe {
                                        use ::wasmtime::component::__internal::MaybeUninitExt;
                                        let m: &mut std::mem::MaybeUninit<_> = dst;
                                        m.map(|p| &raw mut (*p).tag)
                                    }
                                }
                            }
                                .write(wasmtime::ValRaw::u32(0u32));
                            unsafe {
                                wasmtime::component::__internal::lower_payload(
                                    {
                                        #[allow(unused_unsafe)]
                                        {
                                            unsafe {
                                                use ::wasmtime::component::__internal::MaybeUninitExt;
                                                let m: &mut std::mem::MaybeUninit<_> = dst;
                                                m.map(|p| &raw mut (*p).payload)
                                            }
                                        }
                                    },
                                    |payload| {
                                        #[allow(unused_unsafe)]
                                        {
                                            unsafe {
                                                use ::wasmtime::component::__internal::MaybeUninitExt;
                                                let m: &mut std::mem::MaybeUninit<_> = payload;
                                                m.map(|p| &raw mut (*p).Boolean)
                                            }
                                        }
                                    },
                                    |dst| {
                                        value
                                            .lower(
                                                cx,
                                                ty
                                                    .cases[0usize]
                                                    .ty
                                                    .unwrap_or_else(
                                                        wasmtime::component::__internal::bad_type_info,
                                                    ),
                                                dst,
                                            )
                                    },
                                )
                            }
                        }
                        Self::Int8(value) => {
                            {
                                #[allow(unused_unsafe)]
                                {
                                    unsafe {
                                        use ::wasmtime::component::__internal::MaybeUninitExt;
                                        let m: &mut std::mem::MaybeUninit<_> = dst;
                                        m.map(|p| &raw mut (*p).tag)
                                    }
                                }
                            }
                                .write(wasmtime::ValRaw::u32(1u32));
                            unsafe {
                                wasmtime::component::__internal::lower_payload(
                                    {
                                        #[allow(unused_unsafe)]
                                        {
                                            unsafe {
                                                use ::wasmtime::component::__internal::MaybeUninitExt;
                                                let m: &mut std::mem::MaybeUninit<_> = dst;
                                                m.map(|p| &raw mut (*p).payload)
                                            }
                                        }
                                    },
                                    |payload| {
                                        #[allow(unused_unsafe)]
                                        {
                                            unsafe {
                                                use ::wasmtime::component::__internal::MaybeUninitExt;
                                                let m: &mut std::mem::MaybeUninit<_> = payload;
                                                m.map(|p| &raw mut (*p).Int8)
                                            }
                                        }
                                    },
                                    |dst| {
                                        value
                                            .lower(
                                                cx,
                                                ty
                                                    .cases[1usize]
                                                    .ty
                                                    .unwrap_or_else(
                                                        wasmtime::component::__internal::bad_type_info,
                                                    ),
                                                dst,
                                            )
                                    },
                                )
                            }
                        }
                        Self::Int16(value) => {
                            {
                                #[allow(unused_unsafe)]
                                {
                                    unsafe {
                                        use ::wasmtime::component::__internal::MaybeUninitExt;
                                        let m: &mut std::mem::MaybeUninit<_> = dst;
                                        m.map(|p| &raw mut (*p).tag)
                                    }
                                }
                            }
                                .write(wasmtime::ValRaw::u32(2u32));
                            unsafe {
                                wasmtime::component::__internal::lower_payload(
                                    {
                                        #[allow(unused_unsafe)]
                                        {
                                            unsafe {
                                                use ::wasmtime::component::__internal::MaybeUninitExt;
                                                let m: &mut std::mem::MaybeUninit<_> = dst;
                                                m.map(|p| &raw mut (*p).payload)
                                            }
                                        }
                                    },
                                    |payload| {
                                        #[allow(unused_unsafe)]
                                        {
                                            unsafe {
                                                use ::wasmtime::component::__internal::MaybeUninitExt;
                                                let m: &mut std::mem::MaybeUninit<_> = payload;
                                                m.map(|p| &raw mut (*p).Int16)
                                            }
                                        }
                                    },
                                    |dst| {
                                        value
                                            .lower(
                                                cx,
                                                ty
                                                    .cases[2usize]
                                                    .ty
                                                    .unwrap_or_else(
                                                        wasmtime::component::__internal::bad_type_info,
                                                    ),
                                                dst,
                                            )
                                    },
                                )
                            }
                        }
                        Self::Int32(value) => {
                            {
                                #[allow(unused_unsafe)]
                                {
                                    unsafe {
                                        use ::wasmtime::component::__internal::MaybeUninitExt;
                                        let m: &mut std::mem::MaybeUninit<_> = dst;
                                        m.map(|p| &raw mut (*p).tag)
                                    }
                                }
                            }
                                .write(wasmtime::ValRaw::u32(3u32));
                            unsafe {
                                wasmtime::component::__internal::lower_payload(
                                    {
                                        #[allow(unused_unsafe)]
                                        {
                                            unsafe {
                                                use ::wasmtime::component::__internal::MaybeUninitExt;
                                                let m: &mut std::mem::MaybeUninit<_> = dst;
                                                m.map(|p| &raw mut (*p).payload)
                                            }
                                        }
                                    },
                                    |payload| {
                                        #[allow(unused_unsafe)]
                                        {
                                            unsafe {
                                                use ::wasmtime::component::__internal::MaybeUninitExt;
                                                let m: &mut std::mem::MaybeUninit<_> = payload;
                                                m.map(|p| &raw mut (*p).Int32)
                                            }
                                        }
                                    },
                                    |dst| {
                                        value
                                            .lower(
                                                cx,
                                                ty
                                                    .cases[3usize]
                                                    .ty
                                                    .unwrap_or_else(
                                                        wasmtime::component::__internal::bad_type_info,
                                                    ),
                                                dst,
                                            )
                                    },
                                )
                            }
                        }
                        Self::Int64(value) => {
                            {
                                #[allow(unused_unsafe)]
                                {
                                    unsafe {
                                        use ::wasmtime::component::__internal::MaybeUninitExt;
                                        let m: &mut std::mem::MaybeUninit<_> = dst;
                                        m.map(|p| &raw mut (*p).tag)
                                    }
                                }
                            }
                                .write(wasmtime::ValRaw::u32(4u32));
                            unsafe {
                                wasmtime::component::__internal::lower_payload(
                                    {
                                        #[allow(unused_unsafe)]
                                        {
                                            unsafe {
                                                use ::wasmtime::component::__internal::MaybeUninitExt;
                                                let m: &mut std::mem::MaybeUninit<_> = dst;
                                                m.map(|p| &raw mut (*p).payload)
                                            }
                                        }
                                    },
                                    |payload| {
                                        #[allow(unused_unsafe)]
                                        {
                                            unsafe {
                                                use ::wasmtime::component::__internal::MaybeUninitExt;
                                                let m: &mut std::mem::MaybeUninit<_> = payload;
                                                m.map(|p| &raw mut (*p).Int64)
                                            }
                                        }
                                    },
                                    |dst| {
                                        value
                                            .lower(
                                                cx,
                                                ty
                                                    .cases[4usize]
                                                    .ty
                                                    .unwrap_or_else(
                                                        wasmtime::component::__internal::bad_type_info,
                                                    ),
                                                dst,
                                            )
                                    },
                                )
                            }
                        }
                        Self::Uint8(value) => {
                            {
                                #[allow(unused_unsafe)]
                                {
                                    unsafe {
                                        use ::wasmtime::component::__internal::MaybeUninitExt;
                                        let m: &mut std::mem::MaybeUninit<_> = dst;
                                        m.map(|p| &raw mut (*p).tag)
                                    }
                                }
                            }
                                .write(wasmtime::ValRaw::u32(5u32));
                            unsafe {
                                wasmtime::component::__internal::lower_payload(
                                    {
                                        #[allow(unused_unsafe)]
                                        {
                                            unsafe {
                                                use ::wasmtime::component::__internal::MaybeUninitExt;
                                                let m: &mut std::mem::MaybeUninit<_> = dst;
                                                m.map(|p| &raw mut (*p).payload)
                                            }
                                        }
                                    },
                                    |payload| {
                                        #[allow(unused_unsafe)]
                                        {
                                            unsafe {
                                                use ::wasmtime::component::__internal::MaybeUninitExt;
                                                let m: &mut std::mem::MaybeUninit<_> = payload;
                                                m.map(|p| &raw mut (*p).Uint8)
                                            }
                                        }
                                    },
                                    |dst| {
                                        value
                                            .lower(
                                                cx,
                                                ty
                                                    .cases[5usize]
                                                    .ty
                                                    .unwrap_or_else(
                                                        wasmtime::component::__internal::bad_type_info,
                                                    ),
                                                dst,
                                            )
                                    },
                                )
                            }
                        }
                        Self::Uint16(value) => {
                            {
                                #[allow(unused_unsafe)]
                                {
                                    unsafe {
                                        use ::wasmtime::component::__internal::MaybeUninitExt;
                                        let m: &mut std::mem::MaybeUninit<_> = dst;
                                        m.map(|p| &raw mut (*p).tag)
                                    }
                                }
                            }
                                .write(wasmtime::ValRaw::u32(6u32));
                            unsafe {
                                wasmtime::component::__internal::lower_payload(
                                    {
                                        #[allow(unused_unsafe)]
                                        {
                                            unsafe {
                                                use ::wasmtime::component::__internal::MaybeUninitExt;
                                                let m: &mut std::mem::MaybeUninit<_> = dst;
                                                m.map(|p| &raw mut (*p).payload)
                                            }
                                        }
                                    },
                                    |payload| {
                                        #[allow(unused_unsafe)]
                                        {
                                            unsafe {
                                                use ::wasmtime::component::__internal::MaybeUninitExt;
                                                let m: &mut std::mem::MaybeUninit<_> = payload;
                                                m.map(|p| &raw mut (*p).Uint16)
                                            }
                                        }
                                    },
                                    |dst| {
                                        value
                                            .lower(
                                                cx,
                                                ty
                                                    .cases[6usize]
                                                    .ty
                                                    .unwrap_or_else(
                                                        wasmtime::component::__internal::bad_type_info,
                                                    ),
                                                dst,
                                            )
                                    },
                                )
                            }
                        }
                        Self::Uint32(value) => {
                            {
                                #[allow(unused_unsafe)]
                                {
                                    unsafe {
                                        use ::wasmtime::component::__internal::MaybeUninitExt;
                                        let m: &mut std::mem::MaybeUninit<_> = dst;
                                        m.map(|p| &raw mut (*p).tag)
                                    }
                                }
                            }
                                .write(wasmtime::ValRaw::u32(7u32));
                            unsafe {
                                wasmtime::component::__internal::lower_payload(
                                    {
                                        #[allow(unused_unsafe)]
                                        {
                                            unsafe {
                                                use ::wasmtime::component::__internal::MaybeUninitExt;
                                                let m: &mut std::mem::MaybeUninit<_> = dst;
                                                m.map(|p| &raw mut (*p).payload)
                                            }
                                        }
                                    },
                                    |payload| {
                                        #[allow(unused_unsafe)]
                                        {
                                            unsafe {
                                                use ::wasmtime::component::__internal::MaybeUninitExt;
                                                let m: &mut std::mem::MaybeUninit<_> = payload;
                                                m.map(|p| &raw mut (*p).Uint32)
                                            }
                                        }
                                    },
                                    |dst| {
                                        value
                                            .lower(
                                                cx,
                                                ty
                                                    .cases[7usize]
                                                    .ty
                                                    .unwrap_or_else(
                                                        wasmtime::component::__internal::bad_type_info,
                                                    ),
                                                dst,
                                            )
                                    },
                                )
                            }
                        }
                        Self::Uint64(value) => {
                            {
                                #[allow(unused_unsafe)]
                                {
                                    unsafe {
                                        use ::wasmtime::component::__internal::MaybeUninitExt;
                                        let m: &mut std::mem::MaybeUninit<_> = dst;
                                        m.map(|p| &raw mut (*p).tag)
                                    }
                                }
                            }
                                .write(wasmtime::ValRaw::u32(8u32));
                            unsafe {
                                wasmtime::component::__internal::lower_payload(
                                    {
                                        #[allow(unused_unsafe)]
                                        {
                                            unsafe {
                                                use ::wasmtime::component::__internal::MaybeUninitExt;
                                                let m: &mut std::mem::MaybeUninit<_> = dst;
                                                m.map(|p| &raw mut (*p).payload)
                                            }
                                        }
                                    },
                                    |payload| {
                                        #[allow(unused_unsafe)]
                                        {
                                            unsafe {
                                                use ::wasmtime::component::__internal::MaybeUninitExt;
                                                let m: &mut std::mem::MaybeUninit<_> = payload;
                                                m.map(|p| &raw mut (*p).Uint64)
                                            }
                                        }
                                    },
                                    |dst| {
                                        value
                                            .lower(
                                                cx,
                                                ty
                                                    .cases[8usize]
                                                    .ty
                                                    .unwrap_or_else(
                                                        wasmtime::component::__internal::bad_type_info,
                                                    ),
                                                dst,
                                            )
                                    },
                                )
                            }
                        }
                        Self::Floating32(value) => {
                            {
                                #[allow(unused_unsafe)]
                                {
                                    unsafe {
                                        use ::wasmtime::component::__internal::MaybeUninitExt;
                                        let m: &mut std::mem::MaybeUninit<_> = dst;
                                        m.map(|p| &raw mut (*p).tag)
                                    }
                                }
                            }
                                .write(wasmtime::ValRaw::u32(9u32));
                            unsafe {
                                wasmtime::component::__internal::lower_payload(
                                    {
                                        #[allow(unused_unsafe)]
                                        {
                                            unsafe {
                                                use ::wasmtime::component::__internal::MaybeUninitExt;
                                                let m: &mut std::mem::MaybeUninit<_> = dst;
                                                m.map(|p| &raw mut (*p).payload)
                                            }
                                        }
                                    },
                                    |payload| {
                                        #[allow(unused_unsafe)]
                                        {
                                            unsafe {
                                                use ::wasmtime::component::__internal::MaybeUninitExt;
                                                let m: &mut std::mem::MaybeUninit<_> = payload;
                                                m.map(|p| &raw mut (*p).Floating32)
                                            }
                                        }
                                    },
                                    |dst| {
                                        value
                                            .lower(
                                                cx,
                                                ty
                                                    .cases[9usize]
                                                    .ty
                                                    .unwrap_or_else(
                                                        wasmtime::component::__internal::bad_type_info,
                                                    ),
                                                dst,
                                            )
                                    },
                                )
                            }
                        }
                        Self::Floating64(value) => {
                            {
                                #[allow(unused_unsafe)]
                                {
                                    unsafe {
                                        use ::wasmtime::component::__internal::MaybeUninitExt;
                                        let m: &mut std::mem::MaybeUninit<_> = dst;
                                        m.map(|p| &raw mut (*p).tag)
                                    }
                                }
                            }
                                .write(wasmtime::ValRaw::u32(10u32));
                            unsafe {
                                wasmtime::component::__internal::lower_payload(
                                    {
                                        #[allow(unused_unsafe)]
                                        {
                                            unsafe {
                                                use ::wasmtime::component::__internal::MaybeUninitExt;
                                                let m: &mut std::mem::MaybeUninit<_> = dst;
                                                m.map(|p| &raw mut (*p).payload)
                                            }
                                        }
                                    },
                                    |payload| {
                                        #[allow(unused_unsafe)]
                                        {
                                            unsafe {
                                                use ::wasmtime::component::__internal::MaybeUninitExt;
                                                let m: &mut std::mem::MaybeUninit<_> = payload;
                                                m.map(|p| &raw mut (*p).Floating64)
                                            }
                                        }
                                    },
                                    |dst| {
                                        value
                                            .lower(
                                                cx,
                                                ty
                                                    .cases[10usize]
                                                    .ty
                                                    .unwrap_or_else(
                                                        wasmtime::component::__internal::bad_type_info,
                                                    ),
                                                dst,
                                            )
                                    },
                                )
                            }
                        }
                        Self::Str(value) => {
                            {
                                #[allow(unused_unsafe)]
                                {
                                    unsafe {
                                        use ::wasmtime::component::__internal::MaybeUninitExt;
                                        let m: &mut std::mem::MaybeUninit<_> = dst;
                                        m.map(|p| &raw mut (*p).tag)
                                    }
                                }
                            }
                                .write(wasmtime::ValRaw::u32(11u32));
                            unsafe {
                                wasmtime::component::__internal::lower_payload(
                                    {
                                        #[allow(unused_unsafe)]
                                        {
                                            unsafe {
                                                use ::wasmtime::component::__internal::MaybeUninitExt;
                                                let m: &mut std::mem::MaybeUninit<_> = dst;
                                                m.map(|p| &raw mut (*p).payload)
                                            }
                                        }
                                    },
                                    |payload| {
                                        #[allow(unused_unsafe)]
                                        {
                                            unsafe {
                                                use ::wasmtime::component::__internal::MaybeUninitExt;
                                                let m: &mut std::mem::MaybeUninit<_> = payload;
                                                m.map(|p| &raw mut (*p).Str)
                                            }
                                        }
                                    },
                                    |dst| {
                                        value
                                            .lower(
                                                cx,
                                                ty
                                                    .cases[11usize]
                                                    .ty
                                                    .unwrap_or_else(
                                                        wasmtime::component::__internal::bad_type_info,
                                                    ),
                                                dst,
                                            )
                                    },
                                )
                            }
                        }
                        Self::Binary(value) => {
                            {
                                #[allow(unused_unsafe)]
                                {
                                    unsafe {
                                        use ::wasmtime::component::__internal::MaybeUninitExt;
                                        let m: &mut std::mem::MaybeUninit<_> = dst;
                                        m.map(|p| &raw mut (*p).tag)
                                    }
                                }
                            }
                                .write(wasmtime::ValRaw::u32(12u32));
                            unsafe {
                                wasmtime::component::__internal::lower_payload(
                                    {
                                        #[allow(unused_unsafe)]
                                        {
                                            unsafe {
                                                use ::wasmtime::component::__internal::MaybeUninitExt;
                                                let m: &mut std::mem::MaybeUninit<_> = dst;
                                                m.map(|p| &raw mut (*p).payload)
                                            }
                                        }
                                    },
                                    |payload| {
                                        #[allow(unused_unsafe)]
                                        {
                                            unsafe {
                                                use ::wasmtime::component::__internal::MaybeUninitExt;
                                                let m: &mut std::mem::MaybeUninit<_> = payload;
                                                m.map(|p| &raw mut (*p).Binary)
                                            }
                                        }
                                    },
                                    |dst| {
                                        value
                                            .lower(
                                                cx,
                                                ty
                                                    .cases[12usize]
                                                    .ty
                                                    .unwrap_or_else(
                                                        wasmtime::component::__internal::bad_type_info,
                                                    ),
                                                dst,
                                            )
                                    },
                                )
                            }
                        }
                        Self::DbNull => {
                            {
                                #[allow(unused_unsafe)]
                                {
                                    unsafe {
                                        use ::wasmtime::component::__internal::MaybeUninitExt;
                                        let m: &mut std::mem::MaybeUninit<_> = dst;
                                        m.map(|p| &raw mut (*p).tag)
                                    }
                                }
                            }
                                .write(wasmtime::ValRaw::u32(13u32));
                            unsafe {
                                wasmtime::component::__internal::lower_payload(
                                    {
                                        #[allow(unused_unsafe)]
                                        {
                                            unsafe {
                                                use ::wasmtime::component::__internal::MaybeUninitExt;
                                                let m: &mut std::mem::MaybeUninit<_> = dst;
                                                m.map(|p| &raw mut (*p).payload)
                                            }
                                        }
                                    },
                                    |payload| {
                                        #[allow(unused_unsafe)]
                                        {
                                            unsafe {
                                                use ::wasmtime::component::__internal::MaybeUninitExt;
                                                let m: &mut std::mem::MaybeUninit<_> = payload;
                                                m.map(|p| &raw mut (*p).DbNull)
                                            }
                                        }
                                    },
                                    |dst| Ok(()),
                                )
                            }
                        }
                        Self::Unsupported => {
                            {
                                #[allow(unused_unsafe)]
                                {
                                    unsafe {
                                        use ::wasmtime::component::__internal::MaybeUninitExt;
                                        let m: &mut std::mem::MaybeUninit<_> = dst;
                                        m.map(|p| &raw mut (*p).tag)
                                    }
                                }
                            }
                                .write(wasmtime::ValRaw::u32(14u32));
                            unsafe {
                                wasmtime::component::__internal::lower_payload(
                                    {
                                        #[allow(unused_unsafe)]
                                        {
                                            unsafe {
                                                use ::wasmtime::component::__internal::MaybeUninitExt;
                                                let m: &mut std::mem::MaybeUninit<_> = dst;
                                                m.map(|p| &raw mut (*p).payload)
                                            }
                                        }
                                    },
                                    |payload| {
                                        #[allow(unused_unsafe)]
                                        {
                                            unsafe {
                                                use ::wasmtime::component::__internal::MaybeUninitExt;
                                                let m: &mut std::mem::MaybeUninit<_> = payload;
                                                m.map(|p| &raw mut (*p).Unsupported)
                                            }
                                        }
                                    },
                                    |dst| Ok(()),
                                )
                            }
                        }
                    }
                }
                #[inline]
                fn store<T>(
                    &self,
                    cx: &mut wasmtime::component::__internal::LowerContext<'_, T>,
                    ty: wasmtime::component::__internal::InterfaceType,
                    mut offset: usize,
                ) -> wasmtime::component::__internal::anyhow::Result<()> {
                    let ty = match ty {
                        wasmtime::component::__internal::InterfaceType::Variant(i) => {
                            &cx.types[i]
                        }
                        _ => wasmtime::component::__internal::bad_type_info(),
                    };
                    if true {
                        if !(offset
                            % (<Self as wasmtime::component::ComponentType>::ALIGN32
                                as usize) == 0)
                        {
                            ::core::panicking::panic(
                                "assertion failed: offset % (<Self as wasmtime::component::ComponentType>::ALIGN32 as usize) == 0",
                            )
                        }
                    }
                    match self {
                        Self::Boolean(value) => {
                            *cx.get::<1usize>(offset) = 0u8.to_le_bytes();
                            value
                                .store(
                                    cx,
                                    ty
                                        .cases[0usize]
                                        .ty
                                        .unwrap_or_else(
                                            wasmtime::component::__internal::bad_type_info,
                                        ),
                                    offset
                                        + <Self as wasmtime::component::__internal::ComponentVariant>::PAYLOAD_OFFSET32,
                                )
                        }
                        Self::Int8(value) => {
                            *cx.get::<1usize>(offset) = 1u8.to_le_bytes();
                            value
                                .store(
                                    cx,
                                    ty
                                        .cases[1usize]
                                        .ty
                                        .unwrap_or_else(
                                            wasmtime::component::__internal::bad_type_info,
                                        ),
                                    offset
                                        + <Self as wasmtime::component::__internal::ComponentVariant>::PAYLOAD_OFFSET32,
                                )
                        }
                        Self::Int16(value) => {
                            *cx.get::<1usize>(offset) = 2u8.to_le_bytes();
                            value
                                .store(
                                    cx,
                                    ty
                                        .cases[2usize]
                                        .ty
                                        .unwrap_or_else(
                                            wasmtime::component::__internal::bad_type_info,
                                        ),
                                    offset
                                        + <Self as wasmtime::component::__internal::ComponentVariant>::PAYLOAD_OFFSET32,
                                )
                        }
                        Self::Int32(value) => {
                            *cx.get::<1usize>(offset) = 3u8.to_le_bytes();
                            value
                                .store(
                                    cx,
                                    ty
                                        .cases[3usize]
                                        .ty
                                        .unwrap_or_else(
                                            wasmtime::component::__internal::bad_type_info,
                                        ),
                                    offset
                                        + <Self as wasmtime::component::__internal::ComponentVariant>::PAYLOAD_OFFSET32,
                                )
                        }
                        Self::Int64(value) => {
                            *cx.get::<1usize>(offset) = 4u8.to_le_bytes();
                            value
                                .store(
                                    cx,
                                    ty
                                        .cases[4usize]
                                        .ty
                                        .unwrap_or_else(
                                            wasmtime::component::__internal::bad_type_info,
                                        ),
                                    offset
                                        + <Self as wasmtime::component::__internal::ComponentVariant>::PAYLOAD_OFFSET32,
                                )
                        }
                        Self::Uint8(value) => {
                            *cx.get::<1usize>(offset) = 5u8.to_le_bytes();
                            value
                                .store(
                                    cx,
                                    ty
                                        .cases[5usize]
                                        .ty
                                        .unwrap_or_else(
                                            wasmtime::component::__internal::bad_type_info,
                                        ),
                                    offset
                                        + <Self as wasmtime::component::__internal::ComponentVariant>::PAYLOAD_OFFSET32,
                                )
                        }
                        Self::Uint16(value) => {
                            *cx.get::<1usize>(offset) = 6u8.to_le_bytes();
                            value
                                .store(
                                    cx,
                                    ty
                                        .cases[6usize]
                                        .ty
                                        .unwrap_or_else(
                                            wasmtime::component::__internal::bad_type_info,
                                        ),
                                    offset
                                        + <Self as wasmtime::component::__internal::ComponentVariant>::PAYLOAD_OFFSET32,
                                )
                        }
                        Self::Uint32(value) => {
                            *cx.get::<1usize>(offset) = 7u8.to_le_bytes();
                            value
                                .store(
                                    cx,
                                    ty
                                        .cases[7usize]
                                        .ty
                                        .unwrap_or_else(
                                            wasmtime::component::__internal::bad_type_info,
                                        ),
                                    offset
                                        + <Self as wasmtime::component::__internal::ComponentVariant>::PAYLOAD_OFFSET32,
                                )
                        }
                        Self::Uint64(value) => {
                            *cx.get::<1usize>(offset) = 8u8.to_le_bytes();
                            value
                                .store(
                                    cx,
                                    ty
                                        .cases[8usize]
                                        .ty
                                        .unwrap_or_else(
                                            wasmtime::component::__internal::bad_type_info,
                                        ),
                                    offset
                                        + <Self as wasmtime::component::__internal::ComponentVariant>::PAYLOAD_OFFSET32,
                                )
                        }
                        Self::Floating32(value) => {
                            *cx.get::<1usize>(offset) = 9u8.to_le_bytes();
                            value
                                .store(
                                    cx,
                                    ty
                                        .cases[9usize]
                                        .ty
                                        .unwrap_or_else(
                                            wasmtime::component::__internal::bad_type_info,
                                        ),
                                    offset
                                        + <Self as wasmtime::component::__internal::ComponentVariant>::PAYLOAD_OFFSET32,
                                )
                        }
                        Self::Floating64(value) => {
                            *cx.get::<1usize>(offset) = 10u8.to_le_bytes();
                            value
                                .store(
                                    cx,
                                    ty
                                        .cases[10usize]
                                        .ty
                                        .unwrap_or_else(
                                            wasmtime::component::__internal::bad_type_info,
                                        ),
                                    offset
                                        + <Self as wasmtime::component::__internal::ComponentVariant>::PAYLOAD_OFFSET32,
                                )
                        }
                        Self::Str(value) => {
                            *cx.get::<1usize>(offset) = 11u8.to_le_bytes();
                            value
                                .store(
                                    cx,
                                    ty
                                        .cases[11usize]
                                        .ty
                                        .unwrap_or_else(
                                            wasmtime::component::__internal::bad_type_info,
                                        ),
                                    offset
                                        + <Self as wasmtime::component::__internal::ComponentVariant>::PAYLOAD_OFFSET32,
                                )
                        }
                        Self::Binary(value) => {
                            *cx.get::<1usize>(offset) = 12u8.to_le_bytes();
                            value
                                .store(
                                    cx,
                                    ty
                                        .cases[12usize]
                                        .ty
                                        .unwrap_or_else(
                                            wasmtime::component::__internal::bad_type_info,
                                        ),
                                    offset
                                        + <Self as wasmtime::component::__internal::ComponentVariant>::PAYLOAD_OFFSET32,
                                )
                        }
                        Self::DbNull => {
                            *cx.get::<1usize>(offset) = 13u8.to_le_bytes();
                            Ok(())
                        }
                        Self::Unsupported => {
                            *cx.get::<1usize>(offset) = 14u8.to_le_bytes();
                            Ok(())
                        }
                    }
                }
            }
            unsafe impl wasmtime::component::Lift for DbValue {
                #[inline]
                fn lift(
                    cx: &mut wasmtime::component::__internal::LiftContext<'_>,
                    ty: wasmtime::component::__internal::InterfaceType,
                    src: &Self::Lower,
                ) -> wasmtime::component::__internal::anyhow::Result<Self> {
                    let ty = match ty {
                        wasmtime::component::__internal::InterfaceType::Variant(i) => {
                            &cx.types[i]
                        }
                        _ => wasmtime::component::__internal::bad_type_info(),
                    };
                    Ok(
                        match src.tag.get_u32() {
                            0u32 => {
                                Self::Boolean(
                                    <bool as wasmtime::component::Lift>::lift(
                                        cx,
                                        ty
                                            .cases[0usize]
                                            .ty
                                            .unwrap_or_else(
                                                wasmtime::component::__internal::bad_type_info,
                                            ),
                                        unsafe { &src.payload.Boolean },
                                    )?,
                                )
                            }
                            1u32 => {
                                Self::Int8(
                                    <i8 as wasmtime::component::Lift>::lift(
                                        cx,
                                        ty
                                            .cases[1usize]
                                            .ty
                                            .unwrap_or_else(
                                                wasmtime::component::__internal::bad_type_info,
                                            ),
                                        unsafe { &src.payload.Int8 },
                                    )?,
                                )
                            }
                            2u32 => {
                                Self::Int16(
                                    <i16 as wasmtime::component::Lift>::lift(
                                        cx,
                                        ty
                                            .cases[2usize]
                                            .ty
                                            .unwrap_or_else(
                                                wasmtime::component::__internal::bad_type_info,
                                            ),
                                        unsafe { &src.payload.Int16 },
                                    )?,
                                )
                            }
                            3u32 => {
                                Self::Int32(
                                    <i32 as wasmtime::component::Lift>::lift(
                                        cx,
                                        ty
                                            .cases[3usize]
                                            .ty
                                            .unwrap_or_else(
                                                wasmtime::component::__internal::bad_type_info,
                                            ),
                                        unsafe { &src.payload.Int32 },
                                    )?,
                                )
                            }
                            4u32 => {
                                Self::Int64(
                                    <i64 as wasmtime::component::Lift>::lift(
                                        cx,
                                        ty
                                            .cases[4usize]
                                            .ty
                                            .unwrap_or_else(
                                                wasmtime::component::__internal::bad_type_info,
                                            ),
                                        unsafe { &src.payload.Int64 },
                                    )?,
                                )
                            }
                            5u32 => {
                                Self::Uint8(
                                    <u8 as wasmtime::component::Lift>::lift(
                                        cx,
                                        ty
                                            .cases[5usize]
                                            .ty
                                            .unwrap_or_else(
                                                wasmtime::component::__internal::bad_type_info,
                                            ),
                                        unsafe { &src.payload.Uint8 },
                                    )?,
                                )
                            }
                            6u32 => {
                                Self::Uint16(
                                    <u16 as wasmtime::component::Lift>::lift(
                                        cx,
                                        ty
                                            .cases[6usize]
                                            .ty
                                            .unwrap_or_else(
                                                wasmtime::component::__internal::bad_type_info,
                                            ),
                                        unsafe { &src.payload.Uint16 },
                                    )?,
                                )
                            }
                            7u32 => {
                                Self::Uint32(
                                    <u32 as wasmtime::component::Lift>::lift(
                                        cx,
                                        ty
                                            .cases[7usize]
                                            .ty
                                            .unwrap_or_else(
                                                wasmtime::component::__internal::bad_type_info,
                                            ),
                                        unsafe { &src.payload.Uint32 },
                                    )?,
                                )
                            }
                            8u32 => {
                                Self::Uint64(
                                    <u64 as wasmtime::component::Lift>::lift(
                                        cx,
                                        ty
                                            .cases[8usize]
                                            .ty
                                            .unwrap_or_else(
                                                wasmtime::component::__internal::bad_type_info,
                                            ),
                                        unsafe { &src.payload.Uint64 },
                                    )?,
                                )
                            }
                            9u32 => {
                                Self::Floating32(
                                    <f32 as wasmtime::component::Lift>::lift(
                                        cx,
                                        ty
                                            .cases[9usize]
                                            .ty
                                            .unwrap_or_else(
                                                wasmtime::component::__internal::bad_type_info,
                                            ),
                                        unsafe { &src.payload.Floating32 },
                                    )?,
                                )
                            }
                            10u32 => {
                                Self::Floating64(
                                    <f64 as wasmtime::component::Lift>::lift(
                                        cx,
                                        ty
                                            .cases[10usize]
                                            .ty
                                            .unwrap_or_else(
                                                wasmtime::component::__internal::bad_type_info,
                                            ),
                                        unsafe { &src.payload.Floating64 },
                                    )?,
                                )
                            }
                            11u32 => {
                                Self::Str(
                                    <String as wasmtime::component::Lift>::lift(
                                        cx,
                                        ty
                                            .cases[11usize]
                                            .ty
                                            .unwrap_or_else(
                                                wasmtime::component::__internal::bad_type_info,
                                            ),
                                        unsafe { &src.payload.Str },
                                    )?,
                                )
                            }
                            12u32 => {
                                Self::Binary(
                                    <Vec<
                                        u8,
                                    > as wasmtime::component::Lift>::lift(
                                        cx,
                                        ty
                                            .cases[12usize]
                                            .ty
                                            .unwrap_or_else(
                                                wasmtime::component::__internal::bad_type_info,
                                            ),
                                        unsafe { &src.payload.Binary },
                                    )?,
                                )
                            }
                            13u32 => Self::DbNull,
                            14u32 => Self::Unsupported,
                            discrim => {
                                return ::anyhow::__private::Err(
                                    ::anyhow::Error::msg({
                                        let res = ::alloc::fmt::format(
                                            format_args!("unexpected discriminant: {0}", discrim),
                                        );
                                        res
                                    }),
                                );
                            }
                        },
                    )
                }
                #[inline]
                fn load(
                    cx: &mut wasmtime::component::__internal::LiftContext<'_>,
                    ty: wasmtime::component::__internal::InterfaceType,
                    bytes: &[u8],
                ) -> wasmtime::component::__internal::anyhow::Result<Self> {
                    let align = <Self as wasmtime::component::ComponentType>::ALIGN32;
                    if true {
                        if !((bytes.as_ptr() as usize) % (align as usize) == 0) {
                            ::core::panicking::panic(
                                "assertion failed: (bytes.as_ptr() as usize) % (align as usize) == 0",
                            )
                        }
                    }
                    let discrim = bytes[0];
                    let payload_offset = <Self as wasmtime::component::__internal::ComponentVariant>::PAYLOAD_OFFSET32;
                    let payload = &bytes[payload_offset..];
                    let ty = match ty {
                        wasmtime::component::__internal::InterfaceType::Variant(i) => {
                            &cx.types[i]
                        }
                        _ => wasmtime::component::__internal::bad_type_info(),
                    };
                    Ok(
                        match discrim {
                            0u8 => {
                                Self::Boolean(
                                    <bool as wasmtime::component::Lift>::load(
                                        cx,
                                        ty
                                            .cases[0usize]
                                            .ty
                                            .unwrap_or_else(
                                                wasmtime::component::__internal::bad_type_info,
                                            ),
                                        &payload[..<bool as wasmtime::component::ComponentType>::SIZE32],
                                    )?,
                                )
                            }
                            1u8 => {
                                Self::Int8(
                                    <i8 as wasmtime::component::Lift>::load(
                                        cx,
                                        ty
                                            .cases[1usize]
                                            .ty
                                            .unwrap_or_else(
                                                wasmtime::component::__internal::bad_type_info,
                                            ),
                                        &payload[..<i8 as wasmtime::component::ComponentType>::SIZE32],
                                    )?,
                                )
                            }
                            2u8 => {
                                Self::Int16(
                                    <i16 as wasmtime::component::Lift>::load(
                                        cx,
                                        ty
                                            .cases[2usize]
                                            .ty
                                            .unwrap_or_else(
                                                wasmtime::component::__internal::bad_type_info,
                                            ),
                                        &payload[..<i16 as wasmtime::component::ComponentType>::SIZE32],
                                    )?,
                                )
                            }
                            3u8 => {
                                Self::Int32(
                                    <i32 as wasmtime::component::Lift>::load(
                                        cx,
                                        ty
                                            .cases[3usize]
                                            .ty
                                            .unwrap_or_else(
                                                wasmtime::component::__internal::bad_type_info,
                                            ),
                                        &payload[..<i32 as wasmtime::component::ComponentType>::SIZE32],
                                    )?,
                                )
                            }
                            4u8 => {
                                Self::Int64(
                                    <i64 as wasmtime::component::Lift>::load(
                                        cx,
                                        ty
                                            .cases[4usize]
                                            .ty
                                            .unwrap_or_else(
                                                wasmtime::component::__internal::bad_type_info,
                                            ),
                                        &payload[..<i64 as wasmtime::component::ComponentType>::SIZE32],
                                    )?,
                                )
                            }
                            5u8 => {
                                Self::Uint8(
                                    <u8 as wasmtime::component::Lift>::load(
                                        cx,
                                        ty
                                            .cases[5usize]
                                            .ty
                                            .unwrap_or_else(
                                                wasmtime::component::__internal::bad_type_info,
                                            ),
                                        &payload[..<u8 as wasmtime::component::ComponentType>::SIZE32],
                                    )?,
                                )
                            }
                            6u8 => {
                                Self::Uint16(
                                    <u16 as wasmtime::component::Lift>::load(
                                        cx,
                                        ty
                                            .cases[6usize]
                                            .ty
                                            .unwrap_or_else(
                                                wasmtime::component::__internal::bad_type_info,
                                            ),
                                        &payload[..<u16 as wasmtime::component::ComponentType>::SIZE32],
                                    )?,
                                )
                            }
                            7u8 => {
                                Self::Uint32(
                                    <u32 as wasmtime::component::Lift>::load(
                                        cx,
                                        ty
                                            .cases[7usize]
                                            .ty
                                            .unwrap_or_else(
                                                wasmtime::component::__internal::bad_type_info,
                                            ),
                                        &payload[..<u32 as wasmtime::component::ComponentType>::SIZE32],
                                    )?,
                                )
                            }
                            8u8 => {
                                Self::Uint64(
                                    <u64 as wasmtime::component::Lift>::load(
                                        cx,
                                        ty
                                            .cases[8usize]
                                            .ty
                                            .unwrap_or_else(
                                                wasmtime::component::__internal::bad_type_info,
                                            ),
                                        &payload[..<u64 as wasmtime::component::ComponentType>::SIZE32],
                                    )?,
                                )
                            }
                            9u8 => {
                                Self::Floating32(
                                    <f32 as wasmtime::component::Lift>::load(
                                        cx,
                                        ty
                                            .cases[9usize]
                                            .ty
                                            .unwrap_or_else(
                                                wasmtime::component::__internal::bad_type_info,
                                            ),
                                        &payload[..<f32 as wasmtime::component::ComponentType>::SIZE32],
                                    )?,
                                )
                            }
                            10u8 => {
                                Self::Floating64(
                                    <f64 as wasmtime::component::Lift>::load(
                                        cx,
                                        ty
                                            .cases[10usize]
                                            .ty
                                            .unwrap_or_else(
                                                wasmtime::component::__internal::bad_type_info,
                                            ),
                                        &payload[..<f64 as wasmtime::component::ComponentType>::SIZE32],
                                    )?,
                                )
                            }
                            11u8 => {
                                Self::Str(
                                    <String as wasmtime::component::Lift>::load(
                                        cx,
                                        ty
                                            .cases[11usize]
                                            .ty
                                            .unwrap_or_else(
                                                wasmtime::component::__internal::bad_type_info,
                                            ),
                                        &payload[..<String as wasmtime::component::ComponentType>::SIZE32],
                                    )?,
                                )
                            }
                            12u8 => {
                                Self::Binary(
                                    <Vec<
                                        u8,
                                    > as wasmtime::component::Lift>::load(
                                        cx,
                                        ty
                                            .cases[12usize]
                                            .ty
                                            .unwrap_or_else(
                                                wasmtime::component::__internal::bad_type_info,
                                            ),
                                        &payload[..<Vec<
                                            u8,
                                        > as wasmtime::component::ComponentType>::SIZE32],
                                    )?,
                                )
                            }
                            13u8 => Self::DbNull,
                            14u8 => Self::Unsupported,
                            discrim => {
                                return ::anyhow::__private::Err(
                                    ::anyhow::Error::msg({
                                        let res = ::alloc::fmt::format(
                                            format_args!("unexpected discriminant: {0}", discrim),
                                        );
                                        res
                                    }),
                                );
                            }
                        },
                    )
                }
            }
            const _: () = {
                #[doc(hidden)]
                #[repr(C)]
                pub struct LowerDbValue<
                    T0: Copy,
                    T1: Copy,
                    T2: Copy,
                    T3: Copy,
                    T4: Copy,
                    T5: Copy,
                    T6: Copy,
                    T7: Copy,
                    T8: Copy,
                    T9: Copy,
                    T10: Copy,
                    T11: Copy,
                    T12: Copy,
                > {
                    tag: wasmtime::ValRaw,
                    payload: LowerPayloadDbValue<
                        T0,
                        T1,
                        T2,
                        T3,
                        T4,
                        T5,
                        T6,
                        T7,
                        T8,
                        T9,
                        T10,
                        T11,
                        T12,
                    >,
                }
                #[automatically_derived]
                impl<
                    T0: ::core::clone::Clone + Copy,
                    T1: ::core::clone::Clone + Copy,
                    T2: ::core::clone::Clone + Copy,
                    T3: ::core::clone::Clone + Copy,
                    T4: ::core::clone::Clone + Copy,
                    T5: ::core::clone::Clone + Copy,
                    T6: ::core::clone::Clone + Copy,
                    T7: ::core::clone::Clone + Copy,
                    T8: ::core::clone::Clone + Copy,
                    T9: ::core::clone::Clone + Copy,
                    T10: ::core::clone::Clone + Copy,
                    T11: ::core::clone::Clone + Copy,
                    T12: ::core::clone::Clone + Copy,
                > ::core::clone::Clone
                for LowerDbValue<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12> {
                    #[inline]
                    fn clone(
                        &self,
                    ) -> LowerDbValue<
                        T0,
                        T1,
                        T2,
                        T3,
                        T4,
                        T5,
                        T6,
                        T7,
                        T8,
                        T9,
                        T10,
                        T11,
                        T12,
                    > {
                        LowerDbValue {
                            tag: ::core::clone::Clone::clone(&self.tag),
                            payload: ::core::clone::Clone::clone(&self.payload),
                        }
                    }
                }
                #[automatically_derived]
                impl<
                    T0: ::core::marker::Copy + Copy,
                    T1: ::core::marker::Copy + Copy,
                    T2: ::core::marker::Copy + Copy,
                    T3: ::core::marker::Copy + Copy,
                    T4: ::core::marker::Copy + Copy,
                    T5: ::core::marker::Copy + Copy,
                    T6: ::core::marker::Copy + Copy,
                    T7: ::core::marker::Copy + Copy,
                    T8: ::core::marker::Copy + Copy,
                    T9: ::core::marker::Copy + Copy,
                    T10: ::core::marker::Copy + Copy,
                    T11: ::core::marker::Copy + Copy,
                    T12: ::core::marker::Copy + Copy,
                > ::core::marker::Copy
                for LowerDbValue<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12> {}
                #[doc(hidden)]
                #[allow(non_snake_case)]
                #[repr(C)]
                union LowerPayloadDbValue<
                    T0: Copy,
                    T1: Copy,
                    T2: Copy,
                    T3: Copy,
                    T4: Copy,
                    T5: Copy,
                    T6: Copy,
                    T7: Copy,
                    T8: Copy,
                    T9: Copy,
                    T10: Copy,
                    T11: Copy,
                    T12: Copy,
                > {
                    Boolean: T0,
                    Int8: T1,
                    Int16: T2,
                    Int32: T3,
                    Int64: T4,
                    Uint8: T5,
                    Uint16: T6,
                    Uint32: T7,
                    Uint64: T8,
                    Floating32: T9,
                    Floating64: T10,
                    Str: T11,
                    Binary: T12,
                    DbNull: [wasmtime::ValRaw; 0],
                    Unsupported: [wasmtime::ValRaw; 0],
                }
                #[automatically_derived]
                #[allow(non_snake_case)]
                impl<
                    T0: ::core::marker::Copy + ::core::clone::Clone + Copy,
                    T1: ::core::marker::Copy + ::core::clone::Clone + Copy,
                    T2: ::core::marker::Copy + ::core::clone::Clone + Copy,
                    T3: ::core::marker::Copy + ::core::clone::Clone + Copy,
                    T4: ::core::marker::Copy + ::core::clone::Clone + Copy,
                    T5: ::core::marker::Copy + ::core::clone::Clone + Copy,
                    T6: ::core::marker::Copy + ::core::clone::Clone + Copy,
                    T7: ::core::marker::Copy + ::core::clone::Clone + Copy,
                    T8: ::core::marker::Copy + ::core::clone::Clone + Copy,
                    T9: ::core::marker::Copy + ::core::clone::Clone + Copy,
                    T10: ::core::marker::Copy + ::core::clone::Clone + Copy,
                    T11: ::core::marker::Copy + ::core::clone::Clone + Copy,
                    T12: ::core::marker::Copy + ::core::clone::Clone + Copy,
                > ::core::clone::Clone
                for LowerPayloadDbValue<
                    T0,
                    T1,
                    T2,
                    T3,
                    T4,
                    T5,
                    T6,
                    T7,
                    T8,
                    T9,
                    T10,
                    T11,
                    T12,
                > {
                    #[inline]
                    fn clone(
                        &self,
                    ) -> LowerPayloadDbValue<
                        T0,
                        T1,
                        T2,
                        T3,
                        T4,
                        T5,
                        T6,
                        T7,
                        T8,
                        T9,
                        T10,
                        T11,
                        T12,
                    > {
                        let _: ::core::clone::AssertParamIsCopy<Self>;
                        *self
                    }
                }
                #[automatically_derived]
                #[allow(non_snake_case)]
                impl<
                    T0: ::core::marker::Copy + Copy,
                    T1: ::core::marker::Copy + Copy,
                    T2: ::core::marker::Copy + Copy,
                    T3: ::core::marker::Copy + Copy,
                    T4: ::core::marker::Copy + Copy,
                    T5: ::core::marker::Copy + Copy,
                    T6: ::core::marker::Copy + Copy,
                    T7: ::core::marker::Copy + Copy,
                    T8: ::core::marker::Copy + Copy,
                    T9: ::core::marker::Copy + Copy,
                    T10: ::core::marker::Copy + Copy,
                    T11: ::core::marker::Copy + Copy,
                    T12: ::core::marker::Copy + Copy,
                > ::core::marker::Copy
                for LowerPayloadDbValue<
                    T0,
                    T1,
                    T2,
                    T3,
                    T4,
                    T5,
                    T6,
                    T7,
                    T8,
                    T9,
                    T10,
                    T11,
                    T12,
                > {}
                unsafe impl wasmtime::component::ComponentType for DbValue {
                    type Lower = LowerDbValue<
                        <bool as wasmtime::component::ComponentType>::Lower,
                        <i8 as wasmtime::component::ComponentType>::Lower,
                        <i16 as wasmtime::component::ComponentType>::Lower,
                        <i32 as wasmtime::component::ComponentType>::Lower,
                        <i64 as wasmtime::component::ComponentType>::Lower,
                        <u8 as wasmtime::component::ComponentType>::Lower,
                        <u16 as wasmtime::component::ComponentType>::Lower,
                        <u32 as wasmtime::component::ComponentType>::Lower,
                        <u64 as wasmtime::component::ComponentType>::Lower,
                        <f32 as wasmtime::component::ComponentType>::Lower,
                        <f64 as wasmtime::component::ComponentType>::Lower,
                        <String as wasmtime::component::ComponentType>::Lower,
                        <Vec<u8> as wasmtime::component::ComponentType>::Lower,
                    >;
                    #[inline]
                    fn typecheck(
                        ty: &wasmtime::component::__internal::InterfaceType,
                        types: &wasmtime::component::__internal::InstanceType<'_>,
                    ) -> wasmtime::component::__internal::anyhow::Result<()> {
                        wasmtime::component::__internal::typecheck_variant(
                            ty,
                            types,
                            &[
                                (
                                    "boolean",
                                    Some(
                                        <bool as wasmtime::component::ComponentType>::typecheck,
                                    ),
                                ),
                                (
                                    "int8",
                                    Some(<i8 as wasmtime::component::ComponentType>::typecheck),
                                ),
                                (
                                    "int16",
                                    Some(<i16 as wasmtime::component::ComponentType>::typecheck),
                                ),
                                (
                                    "int32",
                                    Some(<i32 as wasmtime::component::ComponentType>::typecheck),
                                ),
                                (
                                    "int64",
                                    Some(<i64 as wasmtime::component::ComponentType>::typecheck),
                                ),
                                (
                                    "uint8",
                                    Some(<u8 as wasmtime::component::ComponentType>::typecheck),
                                ),
                                (
                                    "uint16",
                                    Some(<u16 as wasmtime::component::ComponentType>::typecheck),
                                ),
                                (
                                    "uint32",
                                    Some(<u32 as wasmtime::component::ComponentType>::typecheck),
                                ),
                                (
                                    "uint64",
                                    Some(<u64 as wasmtime::component::ComponentType>::typecheck),
                                ),
                                (
                                    "floating32",
                                    Some(<f32 as wasmtime::component::ComponentType>::typecheck),
                                ),
                                (
                                    "floating64",
                                    Some(<f64 as wasmtime::component::ComponentType>::typecheck),
                                ),
                                (
                                    "str",
                                    Some(
                                        <String as wasmtime::component::ComponentType>::typecheck,
                                    ),
                                ),
                                (
                                    "binary",
                                    Some(
                                        <Vec<u8> as wasmtime::component::ComponentType>::typecheck,
                                    ),
                                ),
                                ("db-null", None),
                                ("unsupported", None),
                            ],
                        )
                    }
                    const ABI: wasmtime::component::__internal::CanonicalAbiInfo = wasmtime::component::__internal::CanonicalAbiInfo::variant_static(
                        &[
                            Some(<bool as wasmtime::component::ComponentType>::ABI),
                            Some(<i8 as wasmtime::component::ComponentType>::ABI),
                            Some(<i16 as wasmtime::component::ComponentType>::ABI),
                            Some(<i32 as wasmtime::component::ComponentType>::ABI),
                            Some(<i64 as wasmtime::component::ComponentType>::ABI),
                            Some(<u8 as wasmtime::component::ComponentType>::ABI),
                            Some(<u16 as wasmtime::component::ComponentType>::ABI),
                            Some(<u32 as wasmtime::component::ComponentType>::ABI),
                            Some(<u64 as wasmtime::component::ComponentType>::ABI),
                            Some(<f32 as wasmtime::component::ComponentType>::ABI),
                            Some(<f64 as wasmtime::component::ComponentType>::ABI),
                            Some(<String as wasmtime::component::ComponentType>::ABI),
                            Some(<Vec<u8> as wasmtime::component::ComponentType>::ABI),
                            None,
                            None,
                        ],
                    );
                }
                unsafe impl wasmtime::component::__internal::ComponentVariant
                for DbValue {
                    const CASES: &'static [Option<
                        wasmtime::component::__internal::CanonicalAbiInfo,
                    >] = &[
                        Some(<bool as wasmtime::component::ComponentType>::ABI),
                        Some(<i8 as wasmtime::component::ComponentType>::ABI),
                        Some(<i16 as wasmtime::component::ComponentType>::ABI),
                        Some(<i32 as wasmtime::component::ComponentType>::ABI),
                        Some(<i64 as wasmtime::component::ComponentType>::ABI),
                        Some(<u8 as wasmtime::component::ComponentType>::ABI),
                        Some(<u16 as wasmtime::component::ComponentType>::ABI),
                        Some(<u32 as wasmtime::component::ComponentType>::ABI),
                        Some(<u64 as wasmtime::component::ComponentType>::ABI),
                        Some(<f32 as wasmtime::component::ComponentType>::ABI),
                        Some(<f64 as wasmtime::component::ComponentType>::ABI),
                        Some(<String as wasmtime::component::ComponentType>::ABI),
                        Some(<Vec<u8> as wasmtime::component::ComponentType>::ABI),
                        None,
                        None,
                    ];
                }
            };
            impl core::fmt::Debug for DbValue {
                fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
                    match self {
                        DbValue::Boolean(e) => {
                            f.debug_tuple("DbValue::Boolean").field(e).finish()
                        }
                        DbValue::Int8(e) => {
                            f.debug_tuple("DbValue::Int8").field(e).finish()
                        }
                        DbValue::Int16(e) => {
                            f.debug_tuple("DbValue::Int16").field(e).finish()
                        }
                        DbValue::Int32(e) => {
                            f.debug_tuple("DbValue::Int32").field(e).finish()
                        }
                        DbValue::Int64(e) => {
                            f.debug_tuple("DbValue::Int64").field(e).finish()
                        }
                        DbValue::Uint8(e) => {
                            f.debug_tuple("DbValue::Uint8").field(e).finish()
                        }
                        DbValue::Uint16(e) => {
                            f.debug_tuple("DbValue::Uint16").field(e).finish()
                        }
                        DbValue::Uint32(e) => {
                            f.debug_tuple("DbValue::Uint32").field(e).finish()
                        }
                        DbValue::Uint64(e) => {
                            f.debug_tuple("DbValue::Uint64").field(e).finish()
                        }
                        DbValue::Floating32(e) => {
                            f.debug_tuple("DbValue::Floating32").field(e).finish()
                        }
                        DbValue::Floating64(e) => {
                            f.debug_tuple("DbValue::Floating64").field(e).finish()
                        }
                        DbValue::Str(e) => {
                            f.debug_tuple("DbValue::Str").field(e).finish()
                        }
                        DbValue::Binary(e) => {
                            f.debug_tuple("DbValue::Binary").field(e).finish()
                        }
                        DbValue::DbNull => f.debug_tuple("DbValue::DbNull").finish(),
                        DbValue::Unsupported => {
                            f.debug_tuple("DbValue::Unsupported").finish()
                        }
                    }
                }
            }
            const _: () = {
                if !(16 == <DbValue as wasmtime::component::ComponentType>::SIZE32) {
                    ::core::panicking::panic(
                        "assertion failed: 16 == <DbValue as wasmtime::component::ComponentType>::SIZE32",
                    )
                }
                if !(8 == <DbValue as wasmtime::component::ComponentType>::ALIGN32) {
                    ::core::panicking::panic(
                        "assertion failed: 8 == <DbValue as wasmtime::component::ComponentType>::ALIGN32",
                    )
                }
            };
            #[component(variant)]
            pub enum ParameterValue {
                #[component(name = "boolean")]
                Boolean(bool),
                #[component(name = "int8")]
                Int8(i8),
                #[component(name = "int16")]
                Int16(i16),
                #[component(name = "int32")]
                Int32(i32),
                #[component(name = "int64")]
                Int64(i64),
                #[component(name = "uint8")]
                Uint8(u8),
                #[component(name = "uint16")]
                Uint16(u16),
                #[component(name = "uint32")]
                Uint32(u32),
                #[component(name = "uint64")]
                Uint64(u64),
                #[component(name = "floating32")]
                Floating32(f32),
                #[component(name = "floating64")]
                Floating64(f64),
                #[component(name = "str")]
                Str(String),
                #[component(name = "binary")]
                Binary(Vec<u8>),
                #[component(name = "db-null")]
                DbNull,
            }
            #[automatically_derived]
            impl ::core::clone::Clone for ParameterValue {
                #[inline]
                fn clone(&self) -> ParameterValue {
                    match self {
                        ParameterValue::Boolean(__self_0) => {
                            ParameterValue::Boolean(
                                ::core::clone::Clone::clone(__self_0),
                            )
                        }
                        ParameterValue::Int8(__self_0) => {
                            ParameterValue::Int8(::core::clone::Clone::clone(__self_0))
                        }
                        ParameterValue::Int16(__self_0) => {
                            ParameterValue::Int16(::core::clone::Clone::clone(__self_0))
                        }
                        ParameterValue::Int32(__self_0) => {
                            ParameterValue::Int32(::core::clone::Clone::clone(__self_0))
                        }
                        ParameterValue::Int64(__self_0) => {
                            ParameterValue::Int64(::core::clone::Clone::clone(__self_0))
                        }
                        ParameterValue::Uint8(__self_0) => {
                            ParameterValue::Uint8(::core::clone::Clone::clone(__self_0))
                        }
                        ParameterValue::Uint16(__self_0) => {
                            ParameterValue::Uint16(::core::clone::Clone::clone(__self_0))
                        }
                        ParameterValue::Uint32(__self_0) => {
                            ParameterValue::Uint32(::core::clone::Clone::clone(__self_0))
                        }
                        ParameterValue::Uint64(__self_0) => {
                            ParameterValue::Uint64(::core::clone::Clone::clone(__self_0))
                        }
                        ParameterValue::Floating32(__self_0) => {
                            ParameterValue::Floating32(
                                ::core::clone::Clone::clone(__self_0),
                            )
                        }
                        ParameterValue::Floating64(__self_0) => {
                            ParameterValue::Floating64(
                                ::core::clone::Clone::clone(__self_0),
                            )
                        }
                        ParameterValue::Str(__self_0) => {
                            ParameterValue::Str(::core::clone::Clone::clone(__self_0))
                        }
                        ParameterValue::Binary(__self_0) => {
                            ParameterValue::Binary(::core::clone::Clone::clone(__self_0))
                        }
                        ParameterValue::DbNull => ParameterValue::DbNull,
                    }
                }
            }
            unsafe impl wasmtime::component::Lower for ParameterValue {
                #[inline]
                fn lower<T>(
                    &self,
                    cx: &mut wasmtime::component::__internal::LowerContext<'_, T>,
                    ty: wasmtime::component::__internal::InterfaceType,
                    dst: &mut std::mem::MaybeUninit<Self::Lower>,
                ) -> wasmtime::component::__internal::anyhow::Result<()> {
                    let ty = match ty {
                        wasmtime::component::__internal::InterfaceType::Variant(i) => {
                            &cx.types[i]
                        }
                        _ => wasmtime::component::__internal::bad_type_info(),
                    };
                    match self {
                        Self::Boolean(value) => {
                            {
                                #[allow(unused_unsafe)]
                                {
                                    unsafe {
                                        use ::wasmtime::component::__internal::MaybeUninitExt;
                                        let m: &mut std::mem::MaybeUninit<_> = dst;
                                        m.map(|p| &raw mut (*p).tag)
                                    }
                                }
                            }
                                .write(wasmtime::ValRaw::u32(0u32));
                            unsafe {
                                wasmtime::component::__internal::lower_payload(
                                    {
                                        #[allow(unused_unsafe)]
                                        {
                                            unsafe {
                                                use ::wasmtime::component::__internal::MaybeUninitExt;
                                                let m: &mut std::mem::MaybeUninit<_> = dst;
                                                m.map(|p| &raw mut (*p).payload)
                                            }
                                        }
                                    },
                                    |payload| {
                                        #[allow(unused_unsafe)]
                                        {
                                            unsafe {
                                                use ::wasmtime::component::__internal::MaybeUninitExt;
                                                let m: &mut std::mem::MaybeUninit<_> = payload;
                                                m.map(|p| &raw mut (*p).Boolean)
                                            }
                                        }
                                    },
                                    |dst| {
                                        value
                                            .lower(
                                                cx,
                                                ty
                                                    .cases[0usize]
                                                    .ty
                                                    .unwrap_or_else(
                                                        wasmtime::component::__internal::bad_type_info,
                                                    ),
                                                dst,
                                            )
                                    },
                                )
                            }
                        }
                        Self::Int8(value) => {
                            {
                                #[allow(unused_unsafe)]
                                {
                                    unsafe {
                                        use ::wasmtime::component::__internal::MaybeUninitExt;
                                        let m: &mut std::mem::MaybeUninit<_> = dst;
                                        m.map(|p| &raw mut (*p).tag)
                                    }
                                }
                            }
                                .write(wasmtime::ValRaw::u32(1u32));
                            unsafe {
                                wasmtime::component::__internal::lower_payload(
                                    {
                                        #[allow(unused_unsafe)]
                                        {
                                            unsafe {
                                                use ::wasmtime::component::__internal::MaybeUninitExt;
                                                let m: &mut std::mem::MaybeUninit<_> = dst;
                                                m.map(|p| &raw mut (*p).payload)
                                            }
                                        }
                                    },
                                    |payload| {
                                        #[allow(unused_unsafe)]
                                        {
                                            unsafe {
                                                use ::wasmtime::component::__internal::MaybeUninitExt;
                                                let m: &mut std::mem::MaybeUninit<_> = payload;
                                                m.map(|p| &raw mut (*p).Int8)
                                            }
                                        }
                                    },
                                    |dst| {
                                        value
                                            .lower(
                                                cx,
                                                ty
                                                    .cases[1usize]
                                                    .ty
                                                    .unwrap_or_else(
                                                        wasmtime::component::__internal::bad_type_info,
                                                    ),
                                                dst,
                                            )
                                    },
                                )
                            }
                        }
                        Self::Int16(value) => {
                            {
                                #[allow(unused_unsafe)]
                                {
                                    unsafe {
                                        use ::wasmtime::component::__internal::MaybeUninitExt;
                                        let m: &mut std::mem::MaybeUninit<_> = dst;
                                        m.map(|p| &raw mut (*p).tag)
                                    }
                                }
                            }
                                .write(wasmtime::ValRaw::u32(2u32));
                            unsafe {
                                wasmtime::component::__internal::lower_payload(
                                    {
                                        #[allow(unused_unsafe)]
                                        {
                                            unsafe {
                                                use ::wasmtime::component::__internal::MaybeUninitExt;
                                                let m: &mut std::mem::MaybeUninit<_> = dst;
                                                m.map(|p| &raw mut (*p).payload)
                                            }
                                        }
                                    },
                                    |payload| {
                                        #[allow(unused_unsafe)]
                                        {
                                            unsafe {
                                                use ::wasmtime::component::__internal::MaybeUninitExt;
                                                let m: &mut std::mem::MaybeUninit<_> = payload;
                                                m.map(|p| &raw mut (*p).Int16)
                                            }
                                        }
                                    },
                                    |dst| {
                                        value
                                            .lower(
                                                cx,
                                                ty
                                                    .cases[2usize]
                                                    .ty
                                                    .unwrap_or_else(
                                                        wasmtime::component::__internal::bad_type_info,
                                                    ),
                                                dst,
                                            )
                                    },
                                )
                            }
                        }
                        Self::Int32(value) => {
                            {
                                #[allow(unused_unsafe)]
                                {
                                    unsafe {
                                        use ::wasmtime::component::__internal::MaybeUninitExt;
                                        let m: &mut std::mem::MaybeUninit<_> = dst;
                                        m.map(|p| &raw mut (*p).tag)
                                    }
                                }
                            }
                                .write(wasmtime::ValRaw::u32(3u32));
                            unsafe {
                                wasmtime::component::__internal::lower_payload(
                                    {
                                        #[allow(unused_unsafe)]
                                        {
                                            unsafe {
                                                use ::wasmtime::component::__internal::MaybeUninitExt;
                                                let m: &mut std::mem::MaybeUninit<_> = dst;
                                                m.map(|p| &raw mut (*p).payload)
                                            }
                                        }
                                    },
                                    |payload| {
                                        #[allow(unused_unsafe)]
                                        {
                                            unsafe {
                                                use ::wasmtime::component::__internal::MaybeUninitExt;
                                                let m: &mut std::mem::MaybeUninit<_> = payload;
                                                m.map(|p| &raw mut (*p).Int32)
                                            }
                                        }
                                    },
                                    |dst| {
                                        value
                                            .lower(
                                                cx,
                                                ty
                                                    .cases[3usize]
                                                    .ty
                                                    .unwrap_or_else(
                                                        wasmtime::component::__internal::bad_type_info,
                                                    ),
                                                dst,
                                            )
                                    },
                                )
                            }
                        }
                        Self::Int64(value) => {
                            {
                                #[allow(unused_unsafe)]
                                {
                                    unsafe {
                                        use ::wasmtime::component::__internal::MaybeUninitExt;
                                        let m: &mut std::mem::MaybeUninit<_> = dst;
                                        m.map(|p| &raw mut (*p).tag)
                                    }
                                }
                            }
                                .write(wasmtime::ValRaw::u32(4u32));
                            unsafe {
                                wasmtime::component::__internal::lower_payload(
                                    {
                                        #[allow(unused_unsafe)]
                                        {
                                            unsafe {
                                                use ::wasmtime::component::__internal::MaybeUninitExt;
                                                let m: &mut std::mem::MaybeUninit<_> = dst;
                                                m.map(|p| &raw mut (*p).payload)
                                            }
                                        }
                                    },
                                    |payload| {
                                        #[allow(unused_unsafe)]
                                        {
                                            unsafe {
                                                use ::wasmtime::component::__internal::MaybeUninitExt;
                                                let m: &mut std::mem::MaybeUninit<_> = payload;
                                                m.map(|p| &raw mut (*p).Int64)
                                            }
                                        }
                                    },
                                    |dst| {
                                        value
                                            .lower(
                                                cx,
                                                ty
                                                    .cases[4usize]
                                                    .ty
                                                    .unwrap_or_else(
                                                        wasmtime::component::__internal::bad_type_info,
                                                    ),
                                                dst,
                                            )
                                    },
                                )
                            }
                        }
                        Self::Uint8(value) => {
                            {
                                #[allow(unused_unsafe)]
                                {
                                    unsafe {
                                        use ::wasmtime::component::__internal::MaybeUninitExt;
                                        let m: &mut std::mem::MaybeUninit<_> = dst;
                                        m.map(|p| &raw mut (*p).tag)
                                    }
                                }
                            }
                                .write(wasmtime::ValRaw::u32(5u32));
                            unsafe {
                                wasmtime::component::__internal::lower_payload(
                                    {
                                        #[allow(unused_unsafe)]
                                        {
                                            unsafe {
                                                use ::wasmtime::component::__internal::MaybeUninitExt;
                                                let m: &mut std::mem::MaybeUninit<_> = dst;
                                                m.map(|p| &raw mut (*p).payload)
                                            }
                                        }
                                    },
                                    |payload| {
                                        #[allow(unused_unsafe)]
                                        {
                                            unsafe {
                                                use ::wasmtime::component::__internal::MaybeUninitExt;
                                                let m: &mut std::mem::MaybeUninit<_> = payload;
                                                m.map(|p| &raw mut (*p).Uint8)
                                            }
                                        }
                                    },
                                    |dst| {
                                        value
                                            .lower(
                                                cx,
                                                ty
                                                    .cases[5usize]
                                                    .ty
                                                    .unwrap_or_else(
                                                        wasmtime::component::__internal::bad_type_info,
                                                    ),
                                                dst,
                                            )
                                    },
                                )
                            }
                        }
                        Self::Uint16(value) => {
                            {
                                #[allow(unused_unsafe)]
                                {
                                    unsafe {
                                        use ::wasmtime::component::__internal::MaybeUninitExt;
                                        let m: &mut std::mem::MaybeUninit<_> = dst;
                                        m.map(|p| &raw mut (*p).tag)
                                    }
                                }
                            }
                                .write(wasmtime::ValRaw::u32(6u32));
                            unsafe {
                                wasmtime::component::__internal::lower_payload(
                                    {
                                        #[allow(unused_unsafe)]
                                        {
                                            unsafe {
                                                use ::wasmtime::component::__internal::MaybeUninitExt;
                                                let m: &mut std::mem::MaybeUninit<_> = dst;
                                                m.map(|p| &raw mut (*p).payload)
                                            }
                                        }
                                    },
                                    |payload| {
                                        #[allow(unused_unsafe)]
                                        {
                                            unsafe {
                                                use ::wasmtime::component::__internal::MaybeUninitExt;
                                                let m: &mut std::mem::MaybeUninit<_> = payload;
                                                m.map(|p| &raw mut (*p).Uint16)
                                            }
                                        }
                                    },
                                    |dst| {
                                        value
                                            .lower(
                                                cx,
                                                ty
                                                    .cases[6usize]
                                                    .ty
                                                    .unwrap_or_else(
                                                        wasmtime::component::__internal::bad_type_info,
                                                    ),
                                                dst,
                                            )
                                    },
                                )
                            }
                        }
                        Self::Uint32(value) => {
                            {
                                #[allow(unused_unsafe)]
                                {
                                    unsafe {
                                        use ::wasmtime::component::__internal::MaybeUninitExt;
                                        let m: &mut std::mem::MaybeUninit<_> = dst;
                                        m.map(|p| &raw mut (*p).tag)
                                    }
                                }
                            }
                                .write(wasmtime::ValRaw::u32(7u32));
                            unsafe {
                                wasmtime::component::__internal::lower_payload(
                                    {
                                        #[allow(unused_unsafe)]
                                        {
                                            unsafe {
                                                use ::wasmtime::component::__internal::MaybeUninitExt;
                                                let m: &mut std::mem::MaybeUninit<_> = dst;
                                                m.map(|p| &raw mut (*p).payload)
                                            }
                                        }
                                    },
                                    |payload| {
                                        #[allow(unused_unsafe)]
                                        {
                                            unsafe {
                                                use ::wasmtime::component::__internal::MaybeUninitExt;
                                                let m: &mut std::mem::MaybeUninit<_> = payload;
                                                m.map(|p| &raw mut (*p).Uint32)
                                            }
                                        }
                                    },
                                    |dst| {
                                        value
                                            .lower(
                                                cx,
                                                ty
                                                    .cases[7usize]
                                                    .ty
                                                    .unwrap_or_else(
                                                        wasmtime::component::__internal::bad_type_info,
                                                    ),
                                                dst,
                                            )
                                    },
                                )
                            }
                        }
                        Self::Uint64(value) => {
                            {
                                #[allow(unused_unsafe)]
                                {
                                    unsafe {
                                        use ::wasmtime::component::__internal::MaybeUninitExt;
                                        let m: &mut std::mem::MaybeUninit<_> = dst;
                                        m.map(|p| &raw mut (*p).tag)
                                    }
                                }
                            }
                                .write(wasmtime::ValRaw::u32(8u32));
                            unsafe {
                                wasmtime::component::__internal::lower_payload(
                                    {
                                        #[allow(unused_unsafe)]
                                        {
                                            unsafe {
                                                use ::wasmtime::component::__internal::MaybeUninitExt;
                                                let m: &mut std::mem::MaybeUninit<_> = dst;
                                                m.map(|p| &raw mut (*p).payload)
                                            }
                                        }
                                    },
                                    |payload| {
                                        #[allow(unused_unsafe)]
                                        {
                                            unsafe {
                                                use ::wasmtime::component::__internal::MaybeUninitExt;
                                                let m: &mut std::mem::MaybeUninit<_> = payload;
                                                m.map(|p| &raw mut (*p).Uint64)
                                            }
                                        }
                                    },
                                    |dst| {
                                        value
                                            .lower(
                                                cx,
                                                ty
                                                    .cases[8usize]
                                                    .ty
                                                    .unwrap_or_else(
                                                        wasmtime::component::__internal::bad_type_info,
                                                    ),
                                                dst,
                                            )
                                    },
                                )
                            }
                        }
                        Self::Floating32(value) => {
                            {
                                #[allow(unused_unsafe)]
                                {
                                    unsafe {
                                        use ::wasmtime::component::__internal::MaybeUninitExt;
                                        let m: &mut std::mem::MaybeUninit<_> = dst;
                                        m.map(|p| &raw mut (*p).tag)
                                    }
                                }
                            }
                                .write(wasmtime::ValRaw::u32(9u32));
                            unsafe {
                                wasmtime::component::__internal::lower_payload(
                                    {
                                        #[allow(unused_unsafe)]
                                        {
                                            unsafe {
                                                use ::wasmtime::component::__internal::MaybeUninitExt;
                                                let m: &mut std::mem::MaybeUninit<_> = dst;
                                                m.map(|p| &raw mut (*p).payload)
                                            }
                                        }
                                    },
                                    |payload| {
                                        #[allow(unused_unsafe)]
                                        {
                                            unsafe {
                                                use ::wasmtime::component::__internal::MaybeUninitExt;
                                                let m: &mut std::mem::MaybeUninit<_> = payload;
                                                m.map(|p| &raw mut (*p).Floating32)
                                            }
                                        }
                                    },
                                    |dst| {
                                        value
                                            .lower(
                                                cx,
                                                ty
                                                    .cases[9usize]
                                                    .ty
                                                    .unwrap_or_else(
                                                        wasmtime::component::__internal::bad_type_info,
                                                    ),
                                                dst,
                                            )
                                    },
                                )
                            }
                        }
                        Self::Floating64(value) => {
                            {
                                #[allow(unused_unsafe)]
                                {
                                    unsafe {
                                        use ::wasmtime::component::__internal::MaybeUninitExt;
                                        let m: &mut std::mem::MaybeUninit<_> = dst;
                                        m.map(|p| &raw mut (*p).tag)
                                    }
                                }
                            }
                                .write(wasmtime::ValRaw::u32(10u32));
                            unsafe {
                                wasmtime::component::__internal::lower_payload(
                                    {
                                        #[allow(unused_unsafe)]
                                        {
                                            unsafe {
                                                use ::wasmtime::component::__internal::MaybeUninitExt;
                                                let m: &mut std::mem::MaybeUninit<_> = dst;
                                                m.map(|p| &raw mut (*p).payload)
                                            }
                                        }
                                    },
                                    |payload| {
                                        #[allow(unused_unsafe)]
                                        {
                                            unsafe {
                                                use ::wasmtime::component::__internal::MaybeUninitExt;
                                                let m: &mut std::mem::MaybeUninit<_> = payload;
                                                m.map(|p| &raw mut (*p).Floating64)
                                            }
                                        }
                                    },
                                    |dst| {
                                        value
                                            .lower(
                                                cx,
                                                ty
                                                    .cases[10usize]
                                                    .ty
                                                    .unwrap_or_else(
                                                        wasmtime::component::__internal::bad_type_info,
                                                    ),
                                                dst,
                                            )
                                    },
                                )
                            }
                        }
                        Self::Str(value) => {
                            {
                                #[allow(unused_unsafe)]
                                {
                                    unsafe {
                                        use ::wasmtime::component::__internal::MaybeUninitExt;
                                        let m: &mut std::mem::MaybeUninit<_> = dst;
                                        m.map(|p| &raw mut (*p).tag)
                                    }
                                }
                            }
                                .write(wasmtime::ValRaw::u32(11u32));
                            unsafe {
                                wasmtime::component::__internal::lower_payload(
                                    {
                                        #[allow(unused_unsafe)]
                                        {
                                            unsafe {
                                                use ::wasmtime::component::__internal::MaybeUninitExt;
                                                let m: &mut std::mem::MaybeUninit<_> = dst;
                                                m.map(|p| &raw mut (*p).payload)
                                            }
                                        }
                                    },
                                    |payload| {
                                        #[allow(unused_unsafe)]
                                        {
                                            unsafe {
                                                use ::wasmtime::component::__internal::MaybeUninitExt;
                                                let m: &mut std::mem::MaybeUninit<_> = payload;
                                                m.map(|p| &raw mut (*p).Str)
                                            }
                                        }
                                    },
                                    |dst| {
                                        value
                                            .lower(
                                                cx,
                                                ty
                                                    .cases[11usize]
                                                    .ty
                                                    .unwrap_or_else(
                                                        wasmtime::component::__internal::bad_type_info,
                                                    ),
                                                dst,
                                            )
                                    },
                                )
                            }
                        }
                        Self::Binary(value) => {
                            {
                                #[allow(unused_unsafe)]
                                {
                                    unsafe {
                                        use ::wasmtime::component::__internal::MaybeUninitExt;
                                        let m: &mut std::mem::MaybeUninit<_> = dst;
                                        m.map(|p| &raw mut (*p).tag)
                                    }
                                }
                            }
                                .write(wasmtime::ValRaw::u32(12u32));
                            unsafe {
                                wasmtime::component::__internal::lower_payload(
                                    {
                                        #[allow(unused_unsafe)]
                                        {
                                            unsafe {
                                                use ::wasmtime::component::__internal::MaybeUninitExt;
                                                let m: &mut std::mem::MaybeUninit<_> = dst;
                                                m.map(|p| &raw mut (*p).payload)
                                            }
                                        }
                                    },
                                    |payload| {
                                        #[allow(unused_unsafe)]
                                        {
                                            unsafe {
                                                use ::wasmtime::component::__internal::MaybeUninitExt;
                                                let m: &mut std::mem::MaybeUninit<_> = payload;
                                                m.map(|p| &raw mut (*p).Binary)
                                            }
                                        }
                                    },
                                    |dst| {
                                        value
                                            .lower(
                                                cx,
                                                ty
                                                    .cases[12usize]
                                                    .ty
                                                    .unwrap_or_else(
                                                        wasmtime::component::__internal::bad_type_info,
                                                    ),
                                                dst,
                                            )
                                    },
                                )
                            }
                        }
                        Self::DbNull => {
                            {
                                #[allow(unused_unsafe)]
                                {
                                    unsafe {
                                        use ::wasmtime::component::__internal::MaybeUninitExt;
                                        let m: &mut std::mem::MaybeUninit<_> = dst;
                                        m.map(|p| &raw mut (*p).tag)
                                    }
                                }
                            }
                                .write(wasmtime::ValRaw::u32(13u32));
                            unsafe {
                                wasmtime::component::__internal::lower_payload(
                                    {
                                        #[allow(unused_unsafe)]
                                        {
                                            unsafe {
                                                use ::wasmtime::component::__internal::MaybeUninitExt;
                                                let m: &mut std::mem::MaybeUninit<_> = dst;
                                                m.map(|p| &raw mut (*p).payload)
                                            }
                                        }
                                    },
                                    |payload| {
                                        #[allow(unused_unsafe)]
                                        {
                                            unsafe {
                                                use ::wasmtime::component::__internal::MaybeUninitExt;
                                                let m: &mut std::mem::MaybeUninit<_> = payload;
                                                m.map(|p| &raw mut (*p).DbNull)
                                            }
                                        }
                                    },
                                    |dst| Ok(()),
                                )
                            }
                        }
                    }
                }
                #[inline]
                fn store<T>(
                    &self,
                    cx: &mut wasmtime::component::__internal::LowerContext<'_, T>,
                    ty: wasmtime::component::__internal::InterfaceType,
                    mut offset: usize,
                ) -> wasmtime::component::__internal::anyhow::Result<()> {
                    let ty = match ty {
                        wasmtime::component::__internal::InterfaceType::Variant(i) => {
                            &cx.types[i]
                        }
                        _ => wasmtime::component::__internal::bad_type_info(),
                    };
                    if true {
                        if !(offset
                            % (<Self as wasmtime::component::ComponentType>::ALIGN32
                                as usize) == 0)
                        {
                            ::core::panicking::panic(
                                "assertion failed: offset % (<Self as wasmtime::component::ComponentType>::ALIGN32 as usize) == 0",
                            )
                        }
                    }
                    match self {
                        Self::Boolean(value) => {
                            *cx.get::<1usize>(offset) = 0u8.to_le_bytes();
                            value
                                .store(
                                    cx,
                                    ty
                                        .cases[0usize]
                                        .ty
                                        .unwrap_or_else(
                                            wasmtime::component::__internal::bad_type_info,
                                        ),
                                    offset
                                        + <Self as wasmtime::component::__internal::ComponentVariant>::PAYLOAD_OFFSET32,
                                )
                        }
                        Self::Int8(value) => {
                            *cx.get::<1usize>(offset) = 1u8.to_le_bytes();
                            value
                                .store(
                                    cx,
                                    ty
                                        .cases[1usize]
                                        .ty
                                        .unwrap_or_else(
                                            wasmtime::component::__internal::bad_type_info,
                                        ),
                                    offset
                                        + <Self as wasmtime::component::__internal::ComponentVariant>::PAYLOAD_OFFSET32,
                                )
                        }
                        Self::Int16(value) => {
                            *cx.get::<1usize>(offset) = 2u8.to_le_bytes();
                            value
                                .store(
                                    cx,
                                    ty
                                        .cases[2usize]
                                        .ty
                                        .unwrap_or_else(
                                            wasmtime::component::__internal::bad_type_info,
                                        ),
                                    offset
                                        + <Self as wasmtime::component::__internal::ComponentVariant>::PAYLOAD_OFFSET32,
                                )
                        }
                        Self::Int32(value) => {
                            *cx.get::<1usize>(offset) = 3u8.to_le_bytes();
                            value
                                .store(
                                    cx,
                                    ty
                                        .cases[3usize]
                                        .ty
                                        .unwrap_or_else(
                                            wasmtime::component::__internal::bad_type_info,
                                        ),
                                    offset
                                        + <Self as wasmtime::component::__internal::ComponentVariant>::PAYLOAD_OFFSET32,
                                )
                        }
                        Self::Int64(value) => {
                            *cx.get::<1usize>(offset) = 4u8.to_le_bytes();
                            value
                                .store(
                                    cx,
                                    ty
                                        .cases[4usize]
                                        .ty
                                        .unwrap_or_else(
                                            wasmtime::component::__internal::bad_type_info,
                                        ),
                                    offset
                                        + <Self as wasmtime::component::__internal::ComponentVariant>::PAYLOAD_OFFSET32,
                                )
                        }
                        Self::Uint8(value) => {
                            *cx.get::<1usize>(offset) = 5u8.to_le_bytes();
                            value
                                .store(
                                    cx,
                                    ty
                                        .cases[5usize]
                                        .ty
                                        .unwrap_or_else(
                                            wasmtime::component::__internal::bad_type_info,
                                        ),
                                    offset
                                        + <Self as wasmtime::component::__internal::ComponentVariant>::PAYLOAD_OFFSET32,
                                )
                        }
                        Self::Uint16(value) => {
                            *cx.get::<1usize>(offset) = 6u8.to_le_bytes();
                            value
                                .store(
                                    cx,
                                    ty
                                        .cases[6usize]
                                        .ty
                                        .unwrap_or_else(
                                            wasmtime::component::__internal::bad_type_info,
                                        ),
                                    offset
                                        + <Self as wasmtime::component::__internal::ComponentVariant>::PAYLOAD_OFFSET32,
                                )
                        }
                        Self::Uint32(value) => {
                            *cx.get::<1usize>(offset) = 7u8.to_le_bytes();
                            value
                                .store(
                                    cx,
                                    ty
                                        .cases[7usize]
                                        .ty
                                        .unwrap_or_else(
                                            wasmtime::component::__internal::bad_type_info,
                                        ),
                                    offset
                                        + <Self as wasmtime::component::__internal::ComponentVariant>::PAYLOAD_OFFSET32,
                                )
                        }
                        Self::Uint64(value) => {
                            *cx.get::<1usize>(offset) = 8u8.to_le_bytes();
                            value
                                .store(
                                    cx,
                                    ty
                                        .cases[8usize]
                                        .ty
                                        .unwrap_or_else(
                                            wasmtime::component::__internal::bad_type_info,
                                        ),
                                    offset
                                        + <Self as wasmtime::component::__internal::ComponentVariant>::PAYLOAD_OFFSET32,
                                )
                        }
                        Self::Floating32(value) => {
                            *cx.get::<1usize>(offset) = 9u8.to_le_bytes();
                            value
                                .store(
                                    cx,
                                    ty
                                        .cases[9usize]
                                        .ty
                                        .unwrap_or_else(
                                            wasmtime::component::__internal::bad_type_info,
                                        ),
                                    offset
                                        + <Self as wasmtime::component::__internal::ComponentVariant>::PAYLOAD_OFFSET32,
                                )
                        }
                        Self::Floating64(value) => {
                            *cx.get::<1usize>(offset) = 10u8.to_le_bytes();
                            value
                                .store(
                                    cx,
                                    ty
                                        .cases[10usize]
                                        .ty
                                        .unwrap_or_else(
                                            wasmtime::component::__internal::bad_type_info,
                                        ),
                                    offset
                                        + <Self as wasmtime::component::__internal::ComponentVariant>::PAYLOAD_OFFSET32,
                                )
                        }
                        Self::Str(value) => {
                            *cx.get::<1usize>(offset) = 11u8.to_le_bytes();
                            value
                                .store(
                                    cx,
                                    ty
                                        .cases[11usize]
                                        .ty
                                        .unwrap_or_else(
                                            wasmtime::component::__internal::bad_type_info,
                                        ),
                                    offset
                                        + <Self as wasmtime::component::__internal::ComponentVariant>::PAYLOAD_OFFSET32,
                                )
                        }
                        Self::Binary(value) => {
                            *cx.get::<1usize>(offset) = 12u8.to_le_bytes();
                            value
                                .store(
                                    cx,
                                    ty
                                        .cases[12usize]
                                        .ty
                                        .unwrap_or_else(
                                            wasmtime::component::__internal::bad_type_info,
                                        ),
                                    offset
                                        + <Self as wasmtime::component::__internal::ComponentVariant>::PAYLOAD_OFFSET32,
                                )
                        }
                        Self::DbNull => {
                            *cx.get::<1usize>(offset) = 13u8.to_le_bytes();
                            Ok(())
                        }
                    }
                }
            }
            unsafe impl wasmtime::component::Lift for ParameterValue {
                #[inline]
                fn lift(
                    cx: &mut wasmtime::component::__internal::LiftContext<'_>,
                    ty: wasmtime::component::__internal::InterfaceType,
                    src: &Self::Lower,
                ) -> wasmtime::component::__internal::anyhow::Result<Self> {
                    let ty = match ty {
                        wasmtime::component::__internal::InterfaceType::Variant(i) => {
                            &cx.types[i]
                        }
                        _ => wasmtime::component::__internal::bad_type_info(),
                    };
                    Ok(
                        match src.tag.get_u32() {
                            0u32 => {
                                Self::Boolean(
                                    <bool as wasmtime::component::Lift>::lift(
                                        cx,
                                        ty
                                            .cases[0usize]
                                            .ty
                                            .unwrap_or_else(
                                                wasmtime::component::__internal::bad_type_info,
                                            ),
                                        unsafe { &src.payload.Boolean },
                                    )?,
                                )
                            }
                            1u32 => {
                                Self::Int8(
                                    <i8 as wasmtime::component::Lift>::lift(
                                        cx,
                                        ty
                                            .cases[1usize]
                                            .ty
                                            .unwrap_or_else(
                                                wasmtime::component::__internal::bad_type_info,
                                            ),
                                        unsafe { &src.payload.Int8 },
                                    )?,
                                )
                            }
                            2u32 => {
                                Self::Int16(
                                    <i16 as wasmtime::component::Lift>::lift(
                                        cx,
                                        ty
                                            .cases[2usize]
                                            .ty
                                            .unwrap_or_else(
                                                wasmtime::component::__internal::bad_type_info,
                                            ),
                                        unsafe { &src.payload.Int16 },
                                    )?,
                                )
                            }
                            3u32 => {
                                Self::Int32(
                                    <i32 as wasmtime::component::Lift>::lift(
                                        cx,
                                        ty
                                            .cases[3usize]
                                            .ty
                                            .unwrap_or_else(
                                                wasmtime::component::__internal::bad_type_info,
                                            ),
                                        unsafe { &src.payload.Int32 },
                                    )?,
                                )
                            }
                            4u32 => {
                                Self::Int64(
                                    <i64 as wasmtime::component::Lift>::lift(
                                        cx,
                                        ty
                                            .cases[4usize]
                                            .ty
                                            .unwrap_or_else(
                                                wasmtime::component::__internal::bad_type_info,
                                            ),
                                        unsafe { &src.payload.Int64 },
                                    )?,
                                )
                            }
                            5u32 => {
                                Self::Uint8(
                                    <u8 as wasmtime::component::Lift>::lift(
                                        cx,
                                        ty
                                            .cases[5usize]
                                            .ty
                                            .unwrap_or_else(
                                                wasmtime::component::__internal::bad_type_info,
                                            ),
                                        unsafe { &src.payload.Uint8 },
                                    )?,
                                )
                            }
                            6u32 => {
                                Self::Uint16(
                                    <u16 as wasmtime::component::Lift>::lift(
                                        cx,
                                        ty
                                            .cases[6usize]
                                            .ty
                                            .unwrap_or_else(
                                                wasmtime::component::__internal::bad_type_info,
                                            ),
                                        unsafe { &src.payload.Uint16 },
                                    )?,
                                )
                            }
                            7u32 => {
                                Self::Uint32(
                                    <u32 as wasmtime::component::Lift>::lift(
                                        cx,
                                        ty
                                            .cases[7usize]
                                            .ty
                                            .unwrap_or_else(
                                                wasmtime::component::__internal::bad_type_info,
                                            ),
                                        unsafe { &src.payload.Uint32 },
                                    )?,
                                )
                            }
                            8u32 => {
                                Self::Uint64(
                                    <u64 as wasmtime::component::Lift>::lift(
                                        cx,
                                        ty
                                            .cases[8usize]
                                            .ty
                                            .unwrap_or_else(
                                                wasmtime::component::__internal::bad_type_info,
                                            ),
                                        unsafe { &src.payload.Uint64 },
                                    )?,
                                )
                            }
                            9u32 => {
                                Self::Floating32(
                                    <f32 as wasmtime::component::Lift>::lift(
                                        cx,
                                        ty
                                            .cases[9usize]
                                            .ty
                                            .unwrap_or_else(
                                                wasmtime::component::__internal::bad_type_info,
                                            ),
                                        unsafe { &src.payload.Floating32 },
                                    )?,
                                )
                            }
                            10u32 => {
                                Self::Floating64(
                                    <f64 as wasmtime::component::Lift>::lift(
                                        cx,
                                        ty
                                            .cases[10usize]
                                            .ty
                                            .unwrap_or_else(
                                                wasmtime::component::__internal::bad_type_info,
                                            ),
                                        unsafe { &src.payload.Floating64 },
                                    )?,
                                )
                            }
                            11u32 => {
                                Self::Str(
                                    <String as wasmtime::component::Lift>::lift(
                                        cx,
                                        ty
                                            .cases[11usize]
                                            .ty
                                            .unwrap_or_else(
                                                wasmtime::component::__internal::bad_type_info,
                                            ),
                                        unsafe { &src.payload.Str },
                                    )?,
                                )
                            }
                            12u32 => {
                                Self::Binary(
                                    <Vec<
                                        u8,
                                    > as wasmtime::component::Lift>::lift(
                                        cx,
                                        ty
                                            .cases[12usize]
                                            .ty
                                            .unwrap_or_else(
                                                wasmtime::component::__internal::bad_type_info,
                                            ),
                                        unsafe { &src.payload.Binary },
                                    )?,
                                )
                            }
                            13u32 => Self::DbNull,
                            discrim => {
                                return ::anyhow::__private::Err(
                                    ::anyhow::Error::msg({
                                        let res = ::alloc::fmt::format(
                                            format_args!("unexpected discriminant: {0}", discrim),
                                        );
                                        res
                                    }),
                                );
                            }
                        },
                    )
                }
                #[inline]
                fn load(
                    cx: &mut wasmtime::component::__internal::LiftContext<'_>,
                    ty: wasmtime::component::__internal::InterfaceType,
                    bytes: &[u8],
                ) -> wasmtime::component::__internal::anyhow::Result<Self> {
                    let align = <Self as wasmtime::component::ComponentType>::ALIGN32;
                    if true {
                        if !((bytes.as_ptr() as usize) % (align as usize) == 0) {
                            ::core::panicking::panic(
                                "assertion failed: (bytes.as_ptr() as usize) % (align as usize) == 0",
                            )
                        }
                    }
                    let discrim = bytes[0];
                    let payload_offset = <Self as wasmtime::component::__internal::ComponentVariant>::PAYLOAD_OFFSET32;
                    let payload = &bytes[payload_offset..];
                    let ty = match ty {
                        wasmtime::component::__internal::InterfaceType::Variant(i) => {
                            &cx.types[i]
                        }
                        _ => wasmtime::component::__internal::bad_type_info(),
                    };
                    Ok(
                        match discrim {
                            0u8 => {
                                Self::Boolean(
                                    <bool as wasmtime::component::Lift>::load(
                                        cx,
                                        ty
                                            .cases[0usize]
                                            .ty
                                            .unwrap_or_else(
                                                wasmtime::component::__internal::bad_type_info,
                                            ),
                                        &payload[..<bool as wasmtime::component::ComponentType>::SIZE32],
                                    )?,
                                )
                            }
                            1u8 => {
                                Self::Int8(
                                    <i8 as wasmtime::component::Lift>::load(
                                        cx,
                                        ty
                                            .cases[1usize]
                                            .ty
                                            .unwrap_or_else(
                                                wasmtime::component::__internal::bad_type_info,
                                            ),
                                        &payload[..<i8 as wasmtime::component::ComponentType>::SIZE32],
                                    )?,
                                )
                            }
                            2u8 => {
                                Self::Int16(
                                    <i16 as wasmtime::component::Lift>::load(
                                        cx,
                                        ty
                                            .cases[2usize]
                                            .ty
                                            .unwrap_or_else(
                                                wasmtime::component::__internal::bad_type_info,
                                            ),
                                        &payload[..<i16 as wasmtime::component::ComponentType>::SIZE32],
                                    )?,
                                )
                            }
                            3u8 => {
                                Self::Int32(
                                    <i32 as wasmtime::component::Lift>::load(
                                        cx,
                                        ty
                                            .cases[3usize]
                                            .ty
                                            .unwrap_or_else(
                                                wasmtime::component::__internal::bad_type_info,
                                            ),
                                        &payload[..<i32 as wasmtime::component::ComponentType>::SIZE32],
                                    )?,
                                )
                            }
                            4u8 => {
                                Self::Int64(
                                    <i64 as wasmtime::component::Lift>::load(
                                        cx,
                                        ty
                                            .cases[4usize]
                                            .ty
                                            .unwrap_or_else(
                                                wasmtime::component::__internal::bad_type_info,
                                            ),
                                        &payload[..<i64 as wasmtime::component::ComponentType>::SIZE32],
                                    )?,
                                )
                            }
                            5u8 => {
                                Self::Uint8(
                                    <u8 as wasmtime::component::Lift>::load(
                                        cx,
                                        ty
                                            .cases[5usize]
                                            .ty
                                            .unwrap_or_else(
                                                wasmtime::component::__internal::bad_type_info,
                                            ),
                                        &payload[..<u8 as wasmtime::component::ComponentType>::SIZE32],
                                    )?,
                                )
                            }
                            6u8 => {
                                Self::Uint16(
                                    <u16 as wasmtime::component::Lift>::load(
                                        cx,
                                        ty
                                            .cases[6usize]
                                            .ty
                                            .unwrap_or_else(
                                                wasmtime::component::__internal::bad_type_info,
                                            ),
                                        &payload[..<u16 as wasmtime::component::ComponentType>::SIZE32],
                                    )?,
                                )
                            }
                            7u8 => {
                                Self::Uint32(
                                    <u32 as wasmtime::component::Lift>::load(
                                        cx,
                                        ty
                                            .cases[7usize]
                                            .ty
                                            .unwrap_or_else(
                                                wasmtime::component::__internal::bad_type_info,
                                            ),
                                        &payload[..<u32 as wasmtime::component::ComponentType>::SIZE32],
                                    )?,
                                )
                            }
                            8u8 => {
                                Self::Uint64(
                                    <u64 as wasmtime::component::Lift>::load(
                                        cx,
                                        ty
                                            .cases[8usize]
                                            .ty
                                            .unwrap_or_else(
                                                wasmtime::component::__internal::bad_type_info,
                                            ),
                                        &payload[..<u64 as wasmtime::component::ComponentType>::SIZE32],
                                    )?,
                                )
                            }
                            9u8 => {
                                Self::Floating32(
                                    <f32 as wasmtime::component::Lift>::load(
                                        cx,
                                        ty
                                            .cases[9usize]
                                            .ty
                                            .unwrap_or_else(
                                                wasmtime::component::__internal::bad_type_info,
                                            ),
                                        &payload[..<f32 as wasmtime::component::ComponentType>::SIZE32],
                                    )?,
                                )
                            }
                            10u8 => {
                                Self::Floating64(
                                    <f64 as wasmtime::component::Lift>::load(
                                        cx,
                                        ty
                                            .cases[10usize]
                                            .ty
                                            .unwrap_or_else(
                                                wasmtime::component::__internal::bad_type_info,
                                            ),
                                        &payload[..<f64 as wasmtime::component::ComponentType>::SIZE32],
                                    )?,
                                )
                            }
                            11u8 => {
                                Self::Str(
                                    <String as wasmtime::component::Lift>::load(
                                        cx,
                                        ty
                                            .cases[11usize]
                                            .ty
                                            .unwrap_or_else(
                                                wasmtime::component::__internal::bad_type_info,
                                            ),
                                        &payload[..<String as wasmtime::component::ComponentType>::SIZE32],
                                    )?,
                                )
                            }
                            12u8 => {
                                Self::Binary(
                                    <Vec<
                                        u8,
                                    > as wasmtime::component::Lift>::load(
                                        cx,
                                        ty
                                            .cases[12usize]
                                            .ty
                                            .unwrap_or_else(
                                                wasmtime::component::__internal::bad_type_info,
                                            ),
                                        &payload[..<Vec<
                                            u8,
                                        > as wasmtime::component::ComponentType>::SIZE32],
                                    )?,
                                )
                            }
                            13u8 => Self::DbNull,
                            discrim => {
                                return ::anyhow::__private::Err(
                                    ::anyhow::Error::msg({
                                        let res = ::alloc::fmt::format(
                                            format_args!("unexpected discriminant: {0}", discrim),
                                        );
                                        res
                                    }),
                                );
                            }
                        },
                    )
                }
            }
            const _: () = {
                #[doc(hidden)]
                #[repr(C)]
                pub struct LowerParameterValue<
                    T0: Copy,
                    T1: Copy,
                    T2: Copy,
                    T3: Copy,
                    T4: Copy,
                    T5: Copy,
                    T6: Copy,
                    T7: Copy,
                    T8: Copy,
                    T9: Copy,
                    T10: Copy,
                    T11: Copy,
                    T12: Copy,
                > {
                    tag: wasmtime::ValRaw,
                    payload: LowerPayloadParameterValue<
                        T0,
                        T1,
                        T2,
                        T3,
                        T4,
                        T5,
                        T6,
                        T7,
                        T8,
                        T9,
                        T10,
                        T11,
                        T12,
                    >,
                }
                #[automatically_derived]
                impl<
                    T0: ::core::clone::Clone + Copy,
                    T1: ::core::clone::Clone + Copy,
                    T2: ::core::clone::Clone + Copy,
                    T3: ::core::clone::Clone + Copy,
                    T4: ::core::clone::Clone + Copy,
                    T5: ::core::clone::Clone + Copy,
                    T6: ::core::clone::Clone + Copy,
                    T7: ::core::clone::Clone + Copy,
                    T8: ::core::clone::Clone + Copy,
                    T9: ::core::clone::Clone + Copy,
                    T10: ::core::clone::Clone + Copy,
                    T11: ::core::clone::Clone + Copy,
                    T12: ::core::clone::Clone + Copy,
                > ::core::clone::Clone
                for LowerParameterValue<
                    T0,
                    T1,
                    T2,
                    T3,
                    T4,
                    T5,
                    T6,
                    T7,
                    T8,
                    T9,
                    T10,
                    T11,
                    T12,
                > {
                    #[inline]
                    fn clone(
                        &self,
                    ) -> LowerParameterValue<
                        T0,
                        T1,
                        T2,
                        T3,
                        T4,
                        T5,
                        T6,
                        T7,
                        T8,
                        T9,
                        T10,
                        T11,
                        T12,
                    > {
                        LowerParameterValue {
                            tag: ::core::clone::Clone::clone(&self.tag),
                            payload: ::core::clone::Clone::clone(&self.payload),
                        }
                    }
                }
                #[automatically_derived]
                impl<
                    T0: ::core::marker::Copy + Copy,
                    T1: ::core::marker::Copy + Copy,
                    T2: ::core::marker::Copy + Copy,
                    T3: ::core::marker::Copy + Copy,
                    T4: ::core::marker::Copy + Copy,
                    T5: ::core::marker::Copy + Copy,
                    T6: ::core::marker::Copy + Copy,
                    T7: ::core::marker::Copy + Copy,
                    T8: ::core::marker::Copy + Copy,
                    T9: ::core::marker::Copy + Copy,
                    T10: ::core::marker::Copy + Copy,
                    T11: ::core::marker::Copy + Copy,
                    T12: ::core::marker::Copy + Copy,
                > ::core::marker::Copy
                for LowerParameterValue<
                    T0,
                    T1,
                    T2,
                    T3,
                    T4,
                    T5,
                    T6,
                    T7,
                    T8,
                    T9,
                    T10,
                    T11,
                    T12,
                > {}
                #[doc(hidden)]
                #[allow(non_snake_case)]
                #[repr(C)]
                union LowerPayloadParameterValue<
                    T0: Copy,
                    T1: Copy,
                    T2: Copy,
                    T3: Copy,
                    T4: Copy,
                    T5: Copy,
                    T6: Copy,
                    T7: Copy,
                    T8: Copy,
                    T9: Copy,
                    T10: Copy,
                    T11: Copy,
                    T12: Copy,
                > {
                    Boolean: T0,
                    Int8: T1,
                    Int16: T2,
                    Int32: T3,
                    Int64: T4,
                    Uint8: T5,
                    Uint16: T6,
                    Uint32: T7,
                    Uint64: T8,
                    Floating32: T9,
                    Floating64: T10,
                    Str: T11,
                    Binary: T12,
                    DbNull: [wasmtime::ValRaw; 0],
                }
                #[automatically_derived]
                #[allow(non_snake_case)]
                impl<
                    T0: ::core::marker::Copy + ::core::clone::Clone + Copy,
                    T1: ::core::marker::Copy + ::core::clone::Clone + Copy,
                    T2: ::core::marker::Copy + ::core::clone::Clone + Copy,
                    T3: ::core::marker::Copy + ::core::clone::Clone + Copy,
                    T4: ::core::marker::Copy + ::core::clone::Clone + Copy,
                    T5: ::core::marker::Copy + ::core::clone::Clone + Copy,
                    T6: ::core::marker::Copy + ::core::clone::Clone + Copy,
                    T7: ::core::marker::Copy + ::core::clone::Clone + Copy,
                    T8: ::core::marker::Copy + ::core::clone::Clone + Copy,
                    T9: ::core::marker::Copy + ::core::clone::Clone + Copy,
                    T10: ::core::marker::Copy + ::core::clone::Clone + Copy,
                    T11: ::core::marker::Copy + ::core::clone::Clone + Copy,
                    T12: ::core::marker::Copy + ::core::clone::Clone + Copy,
                > ::core::clone::Clone
                for LowerPayloadParameterValue<
                    T0,
                    T1,
                    T2,
                    T3,
                    T4,
                    T5,
                    T6,
                    T7,
                    T8,
                    T9,
                    T10,
                    T11,
                    T12,
                > {
                    #[inline]
                    fn clone(
                        &self,
                    ) -> LowerPayloadParameterValue<
                        T0,
                        T1,
                        T2,
                        T3,
                        T4,
                        T5,
                        T6,
                        T7,
                        T8,
                        T9,
                        T10,
                        T11,
                        T12,
                    > {
                        let _: ::core::clone::AssertParamIsCopy<Self>;
                        *self
                    }
                }
                #[automatically_derived]
                #[allow(non_snake_case)]
                impl<
                    T0: ::core::marker::Copy + Copy,
                    T1: ::core::marker::Copy + Copy,
                    T2: ::core::marker::Copy + Copy,
                    T3: ::core::marker::Copy + Copy,
                    T4: ::core::marker::Copy + Copy,
                    T5: ::core::marker::Copy + Copy,
                    T6: ::core::marker::Copy + Copy,
                    T7: ::core::marker::Copy + Copy,
                    T8: ::core::marker::Copy + Copy,
                    T9: ::core::marker::Copy + Copy,
                    T10: ::core::marker::Copy + Copy,
                    T11: ::core::marker::Copy + Copy,
                    T12: ::core::marker::Copy + Copy,
                > ::core::marker::Copy
                for LowerPayloadParameterValue<
                    T0,
                    T1,
                    T2,
                    T3,
                    T4,
                    T5,
                    T6,
                    T7,
                    T8,
                    T9,
                    T10,
                    T11,
                    T12,
                > {}
                unsafe impl wasmtime::component::ComponentType for ParameterValue {
                    type Lower = LowerParameterValue<
                        <bool as wasmtime::component::ComponentType>::Lower,
                        <i8 as wasmtime::component::ComponentType>::Lower,
                        <i16 as wasmtime::component::ComponentType>::Lower,
                        <i32 as wasmtime::component::ComponentType>::Lower,
                        <i64 as wasmtime::component::ComponentType>::Lower,
                        <u8 as wasmtime::component::ComponentType>::Lower,
                        <u16 as wasmtime::component::ComponentType>::Lower,
                        <u32 as wasmtime::component::ComponentType>::Lower,
                        <u64 as wasmtime::component::ComponentType>::Lower,
                        <f32 as wasmtime::component::ComponentType>::Lower,
                        <f64 as wasmtime::component::ComponentType>::Lower,
                        <String as wasmtime::component::ComponentType>::Lower,
                        <Vec<u8> as wasmtime::component::ComponentType>::Lower,
                    >;
                    #[inline]
                    fn typecheck(
                        ty: &wasmtime::component::__internal::InterfaceType,
                        types: &wasmtime::component::__internal::InstanceType<'_>,
                    ) -> wasmtime::component::__internal::anyhow::Result<()> {
                        wasmtime::component::__internal::typecheck_variant(
                            ty,
                            types,
                            &[
                                (
                                    "boolean",
                                    Some(
                                        <bool as wasmtime::component::ComponentType>::typecheck,
                                    ),
                                ),
                                (
                                    "int8",
                                    Some(<i8 as wasmtime::component::ComponentType>::typecheck),
                                ),
                                (
                                    "int16",
                                    Some(<i16 as wasmtime::component::ComponentType>::typecheck),
                                ),
                                (
                                    "int32",
                                    Some(<i32 as wasmtime::component::ComponentType>::typecheck),
                                ),
                                (
                                    "int64",
                                    Some(<i64 as wasmtime::component::ComponentType>::typecheck),
                                ),
                                (
                                    "uint8",
                                    Some(<u8 as wasmtime::component::ComponentType>::typecheck),
                                ),
                                (
                                    "uint16",
                                    Some(<u16 as wasmtime::component::ComponentType>::typecheck),
                                ),
                                (
                                    "uint32",
                                    Some(<u32 as wasmtime::component::ComponentType>::typecheck),
                                ),
                                (
                                    "uint64",
                                    Some(<u64 as wasmtime::component::ComponentType>::typecheck),
                                ),
                                (
                                    "floating32",
                                    Some(<f32 as wasmtime::component::ComponentType>::typecheck),
                                ),
                                (
                                    "floating64",
                                    Some(<f64 as wasmtime::component::ComponentType>::typecheck),
                                ),
                                (
                                    "str",
                                    Some(
                                        <String as wasmtime::component::ComponentType>::typecheck,
                                    ),
                                ),
                                (
                                    "binary",
                                    Some(
                                        <Vec<u8> as wasmtime::component::ComponentType>::typecheck,
                                    ),
                                ),
                                ("db-null", None),
                            ],
                        )
                    }
                    const ABI: wasmtime::component::__internal::CanonicalAbiInfo = wasmtime::component::__internal::CanonicalAbiInfo::variant_static(
                        &[
                            Some(<bool as wasmtime::component::ComponentType>::ABI),
                            Some(<i8 as wasmtime::component::ComponentType>::ABI),
                            Some(<i16 as wasmtime::component::ComponentType>::ABI),
                            Some(<i32 as wasmtime::component::ComponentType>::ABI),
                            Some(<i64 as wasmtime::component::ComponentType>::ABI),
                            Some(<u8 as wasmtime::component::ComponentType>::ABI),
                            Some(<u16 as wasmtime::component::ComponentType>::ABI),
                            Some(<u32 as wasmtime::component::ComponentType>::ABI),
                            Some(<u64 as wasmtime::component::ComponentType>::ABI),
                            Some(<f32 as wasmtime::component::ComponentType>::ABI),
                            Some(<f64 as wasmtime::component::ComponentType>::ABI),
                            Some(<String as wasmtime::component::ComponentType>::ABI),
                            Some(<Vec<u8> as wasmtime::component::ComponentType>::ABI),
                            None,
                        ],
                    );
                }
                unsafe impl wasmtime::component::__internal::ComponentVariant
                for ParameterValue {
                    const CASES: &'static [Option<
                        wasmtime::component::__internal::CanonicalAbiInfo,
                    >] = &[
                        Some(<bool as wasmtime::component::ComponentType>::ABI),
                        Some(<i8 as wasmtime::component::ComponentType>::ABI),
                        Some(<i16 as wasmtime::component::ComponentType>::ABI),
                        Some(<i32 as wasmtime::component::ComponentType>::ABI),
                        Some(<i64 as wasmtime::component::ComponentType>::ABI),
                        Some(<u8 as wasmtime::component::ComponentType>::ABI),
                        Some(<u16 as wasmtime::component::ComponentType>::ABI),
                        Some(<u32 as wasmtime::component::ComponentType>::ABI),
                        Some(<u64 as wasmtime::component::ComponentType>::ABI),
                        Some(<f32 as wasmtime::component::ComponentType>::ABI),
                        Some(<f64 as wasmtime::component::ComponentType>::ABI),
                        Some(<String as wasmtime::component::ComponentType>::ABI),
                        Some(<Vec<u8> as wasmtime::component::ComponentType>::ABI),
                        None,
                    ];
                }
            };
            impl core::fmt::Debug for ParameterValue {
                fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
                    match self {
                        ParameterValue::Boolean(e) => {
                            f.debug_tuple("ParameterValue::Boolean").field(e).finish()
                        }
                        ParameterValue::Int8(e) => {
                            f.debug_tuple("ParameterValue::Int8").field(e).finish()
                        }
                        ParameterValue::Int16(e) => {
                            f.debug_tuple("ParameterValue::Int16").field(e).finish()
                        }
                        ParameterValue::Int32(e) => {
                            f.debug_tuple("ParameterValue::Int32").field(e).finish()
                        }
                        ParameterValue::Int64(e) => {
                            f.debug_tuple("ParameterValue::Int64").field(e).finish()
                        }
                        ParameterValue::Uint8(e) => {
                            f.debug_tuple("ParameterValue::Uint8").field(e).finish()
                        }
                        ParameterValue::Uint16(e) => {
                            f.debug_tuple("ParameterValue::Uint16").field(e).finish()
                        }
                        ParameterValue::Uint32(e) => {
                            f.debug_tuple("ParameterValue::Uint32").field(e).finish()
                        }
                        ParameterValue::Uint64(e) => {
                            f.debug_tuple("ParameterValue::Uint64").field(e).finish()
                        }
                        ParameterValue::Floating32(e) => {
                            f.debug_tuple("ParameterValue::Floating32").field(e).finish()
                        }
                        ParameterValue::Floating64(e) => {
                            f.debug_tuple("ParameterValue::Floating64").field(e).finish()
                        }
                        ParameterValue::Str(e) => {
                            f.debug_tuple("ParameterValue::Str").field(e).finish()
                        }
                        ParameterValue::Binary(e) => {
                            f.debug_tuple("ParameterValue::Binary").field(e).finish()
                        }
                        ParameterValue::DbNull => {
                            f.debug_tuple("ParameterValue::DbNull").finish()
                        }
                    }
                }
            }
            const _: () = {
                if !(16
                    == <ParameterValue as wasmtime::component::ComponentType>::SIZE32)
                {
                    ::core::panicking::panic(
                        "assertion failed: 16 == <ParameterValue as wasmtime::component::ComponentType>::SIZE32",
                    )
                }
                if !(8
                    == <ParameterValue as wasmtime::component::ComponentType>::ALIGN32)
                {
                    ::core::panicking::panic(
                        "assertion failed: 8 == <ParameterValue as wasmtime::component::ComponentType>::ALIGN32",
                    )
                }
            };
            #[component(record)]
            pub struct Column {
                #[component(name = "name")]
                pub name: String,
                #[component(name = "data-type")]
                pub data_type: DbDataType,
            }
            #[automatically_derived]
            impl ::core::clone::Clone for Column {
                #[inline]
                fn clone(&self) -> Column {
                    Column {
                        name: ::core::clone::Clone::clone(&self.name),
                        data_type: ::core::clone::Clone::clone(&self.data_type),
                    }
                }
            }
            unsafe impl wasmtime::component::Lower for Column {
                #[inline]
                fn lower<T>(
                    &self,
                    cx: &mut wasmtime::component::__internal::LowerContext<'_, T>,
                    ty: wasmtime::component::__internal::InterfaceType,
                    dst: &mut std::mem::MaybeUninit<Self::Lower>,
                ) -> wasmtime::component::__internal::anyhow::Result<()> {
                    let ty = match ty {
                        wasmtime::component::__internal::InterfaceType::Record(i) => {
                            &cx.types[i]
                        }
                        _ => wasmtime::component::__internal::bad_type_info(),
                    };
                    wasmtime::component::Lower::lower(
                        &self.name,
                        cx,
                        ty.fields[0usize].ty,
                        {
                            #[allow(unused_unsafe)]
                            {
                                unsafe {
                                    use ::wasmtime::component::__internal::MaybeUninitExt;
                                    let m: &mut std::mem::MaybeUninit<_> = dst;
                                    m.map(|p| &raw mut (*p).name)
                                }
                            }
                        },
                    )?;
                    wasmtime::component::Lower::lower(
                        &self.data_type,
                        cx,
                        ty.fields[1usize].ty,
                        {
                            #[allow(unused_unsafe)]
                            {
                                unsafe {
                                    use ::wasmtime::component::__internal::MaybeUninitExt;
                                    let m: &mut std::mem::MaybeUninit<_> = dst;
                                    m.map(|p| &raw mut (*p).data_type)
                                }
                            }
                        },
                    )?;
                    Ok(())
                }
                #[inline]
                fn store<T>(
                    &self,
                    cx: &mut wasmtime::component::__internal::LowerContext<'_, T>,
                    ty: wasmtime::component::__internal::InterfaceType,
                    mut offset: usize,
                ) -> wasmtime::component::__internal::anyhow::Result<()> {
                    if true {
                        if !(offset
                            % (<Self as wasmtime::component::ComponentType>::ALIGN32
                                as usize) == 0)
                        {
                            ::core::panicking::panic(
                                "assertion failed: offset % (<Self as wasmtime::component::ComponentType>::ALIGN32 as usize) == 0",
                            )
                        }
                    }
                    let ty = match ty {
                        wasmtime::component::__internal::InterfaceType::Record(i) => {
                            &cx.types[i]
                        }
                        _ => wasmtime::component::__internal::bad_type_info(),
                    };
                    wasmtime::component::Lower::store(
                        &self.name,
                        cx,
                        ty.fields[0usize].ty,
                        <String as wasmtime::component::ComponentType>::ABI
                            .next_field32_size(&mut offset),
                    )?;
                    wasmtime::component::Lower::store(
                        &self.data_type,
                        cx,
                        ty.fields[1usize].ty,
                        <DbDataType as wasmtime::component::ComponentType>::ABI
                            .next_field32_size(&mut offset),
                    )?;
                    Ok(())
                }
            }
            unsafe impl wasmtime::component::Lift for Column {
                #[inline]
                fn lift(
                    cx: &mut wasmtime::component::__internal::LiftContext<'_>,
                    ty: wasmtime::component::__internal::InterfaceType,
                    src: &Self::Lower,
                ) -> wasmtime::component::__internal::anyhow::Result<Self> {
                    let ty = match ty {
                        wasmtime::component::__internal::InterfaceType::Record(i) => {
                            &cx.types[i]
                        }
                        _ => wasmtime::component::__internal::bad_type_info(),
                    };
                    Ok(Self {
                        name: <String as wasmtime::component::Lift>::lift(
                            cx,
                            ty.fields[0usize].ty,
                            &src.name,
                        )?,
                        data_type: <DbDataType as wasmtime::component::Lift>::lift(
                            cx,
                            ty.fields[1usize].ty,
                            &src.data_type,
                        )?,
                    })
                }
                #[inline]
                fn load(
                    cx: &mut wasmtime::component::__internal::LiftContext<'_>,
                    ty: wasmtime::component::__internal::InterfaceType,
                    bytes: &[u8],
                ) -> wasmtime::component::__internal::anyhow::Result<Self> {
                    let ty = match ty {
                        wasmtime::component::__internal::InterfaceType::Record(i) => {
                            &cx.types[i]
                        }
                        _ => wasmtime::component::__internal::bad_type_info(),
                    };
                    if true {
                        if !((bytes.as_ptr() as usize)
                            % (<Self as wasmtime::component::ComponentType>::ALIGN32
                                as usize) == 0)
                        {
                            ::core::panicking::panic(
                                "assertion failed: (bytes.as_ptr() as usize) %\\n        (<Self as wasmtime::component::ComponentType>::ALIGN32 as usize) == 0",
                            )
                        }
                    }
                    let mut offset = 0;
                    Ok(Self {
                        name: <String as wasmtime::component::Lift>::load(
                            cx,
                            ty.fields[0usize].ty,
                            &bytes[<String as wasmtime::component::ComponentType>::ABI
                                .next_field32_size(
                                    &mut offset,
                                )..][..<String as wasmtime::component::ComponentType>::SIZE32],
                        )?,
                        data_type: <DbDataType as wasmtime::component::Lift>::load(
                            cx,
                            ty.fields[1usize].ty,
                            &bytes[<DbDataType as wasmtime::component::ComponentType>::ABI
                                .next_field32_size(
                                    &mut offset,
                                )..][..<DbDataType as wasmtime::component::ComponentType>::SIZE32],
                        )?,
                    })
                }
            }
            const _: () = {
                #[doc(hidden)]
                #[repr(C)]
                pub struct LowerColumn<T0: Copy, T1: Copy> {
                    name: T0,
                    data_type: T1,
                    _align: [wasmtime::ValRaw; 0],
                }
                #[automatically_derived]
                impl<
                    T0: ::core::clone::Clone + Copy,
                    T1: ::core::clone::Clone + Copy,
                > ::core::clone::Clone for LowerColumn<T0, T1> {
                    #[inline]
                    fn clone(&self) -> LowerColumn<T0, T1> {
                        LowerColumn {
                            name: ::core::clone::Clone::clone(&self.name),
                            data_type: ::core::clone::Clone::clone(&self.data_type),
                            _align: ::core::clone::Clone::clone(&self._align),
                        }
                    }
                }
                #[automatically_derived]
                impl<
                    T0: ::core::marker::Copy + Copy,
                    T1: ::core::marker::Copy + Copy,
                > ::core::marker::Copy for LowerColumn<T0, T1> {}
                unsafe impl wasmtime::component::ComponentType for Column {
                    type Lower = LowerColumn<
                        <String as wasmtime::component::ComponentType>::Lower,
                        <DbDataType as wasmtime::component::ComponentType>::Lower,
                    >;
                    const ABI: wasmtime::component::__internal::CanonicalAbiInfo = wasmtime::component::__internal::CanonicalAbiInfo::record_static(
                        &[
                            <String as wasmtime::component::ComponentType>::ABI,
                            <DbDataType as wasmtime::component::ComponentType>::ABI,
                        ],
                    );
                    #[inline]
                    fn typecheck(
                        ty: &wasmtime::component::__internal::InterfaceType,
                        types: &wasmtime::component::__internal::InstanceType<'_>,
                    ) -> wasmtime::component::__internal::anyhow::Result<()> {
                        wasmtime::component::__internal::typecheck_record(
                            ty,
                            types,
                            &[
                                (
                                    "name",
                                    <String as wasmtime::component::ComponentType>::typecheck,
                                ),
                                (
                                    "data-type",
                                    <DbDataType as wasmtime::component::ComponentType>::typecheck,
                                ),
                            ],
                        )
                    }
                }
            };
            impl core::fmt::Debug for Column {
                fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
                    f.debug_struct("Column")
                        .field("name", &self.name)
                        .field("data-type", &self.data_type)
                        .finish()
                }
            }
            const _: () = {
                if !(12 == <Column as wasmtime::component::ComponentType>::SIZE32) {
                    ::core::panicking::panic(
                        "assertion failed: 12 == <Column as wasmtime::component::ComponentType>::SIZE32",
                    )
                }
                if !(4 == <Column as wasmtime::component::ComponentType>::ALIGN32) {
                    ::core::panicking::panic(
                        "assertion failed: 4 == <Column as wasmtime::component::ComponentType>::ALIGN32",
                    )
                }
            };
            pub type Row = Vec<DbValue>;
            const _: () = {
                if !(8 == <Row as wasmtime::component::ComponentType>::SIZE32) {
                    ::core::panicking::panic(
                        "assertion failed: 8 == <Row as wasmtime::component::ComponentType>::SIZE32",
                    )
                }
                if !(4 == <Row as wasmtime::component::ComponentType>::ALIGN32) {
                    ::core::panicking::panic(
                        "assertion failed: 4 == <Row as wasmtime::component::ComponentType>::ALIGN32",
                    )
                }
            };
            #[component(record)]
            pub struct RowSet {
                #[component(name = "columns")]
                pub columns: Vec<Column>,
                #[component(name = "rows")]
                pub rows: Vec<Row>,
            }
            #[automatically_derived]
            impl ::core::clone::Clone for RowSet {
                #[inline]
                fn clone(&self) -> RowSet {
                    RowSet {
                        columns: ::core::clone::Clone::clone(&self.columns),
                        rows: ::core::clone::Clone::clone(&self.rows),
                    }
                }
            }
            unsafe impl wasmtime::component::Lower for RowSet {
                #[inline]
                fn lower<T>(
                    &self,
                    cx: &mut wasmtime::component::__internal::LowerContext<'_, T>,
                    ty: wasmtime::component::__internal::InterfaceType,
                    dst: &mut std::mem::MaybeUninit<Self::Lower>,
                ) -> wasmtime::component::__internal::anyhow::Result<()> {
                    let ty = match ty {
                        wasmtime::component::__internal::InterfaceType::Record(i) => {
                            &cx.types[i]
                        }
                        _ => wasmtime::component::__internal::bad_type_info(),
                    };
                    wasmtime::component::Lower::lower(
                        &self.columns,
                        cx,
                        ty.fields[0usize].ty,
                        {
                            #[allow(unused_unsafe)]
                            {
                                unsafe {
                                    use ::wasmtime::component::__internal::MaybeUninitExt;
                                    let m: &mut std::mem::MaybeUninit<_> = dst;
                                    m.map(|p| &raw mut (*p).columns)
                                }
                            }
                        },
                    )?;
                    wasmtime::component::Lower::lower(
                        &self.rows,
                        cx,
                        ty.fields[1usize].ty,
                        {
                            #[allow(unused_unsafe)]
                            {
                                unsafe {
                                    use ::wasmtime::component::__internal::MaybeUninitExt;
                                    let m: &mut std::mem::MaybeUninit<_> = dst;
                                    m.map(|p| &raw mut (*p).rows)
                                }
                            }
                        },
                    )?;
                    Ok(())
                }
                #[inline]
                fn store<T>(
                    &self,
                    cx: &mut wasmtime::component::__internal::LowerContext<'_, T>,
                    ty: wasmtime::component::__internal::InterfaceType,
                    mut offset: usize,
                ) -> wasmtime::component::__internal::anyhow::Result<()> {
                    if true {
                        if !(offset
                            % (<Self as wasmtime::component::ComponentType>::ALIGN32
                                as usize) == 0)
                        {
                            ::core::panicking::panic(
                                "assertion failed: offset % (<Self as wasmtime::component::ComponentType>::ALIGN32 as usize) == 0",
                            )
                        }
                    }
                    let ty = match ty {
                        wasmtime::component::__internal::InterfaceType::Record(i) => {
                            &cx.types[i]
                        }
                        _ => wasmtime::component::__internal::bad_type_info(),
                    };
                    wasmtime::component::Lower::store(
                        &self.columns,
                        cx,
                        ty.fields[0usize].ty,
                        <Vec<Column> as wasmtime::component::ComponentType>::ABI
                            .next_field32_size(&mut offset),
                    )?;
                    wasmtime::component::Lower::store(
                        &self.rows,
                        cx,
                        ty.fields[1usize].ty,
                        <Vec<Row> as wasmtime::component::ComponentType>::ABI
                            .next_field32_size(&mut offset),
                    )?;
                    Ok(())
                }
            }
            unsafe impl wasmtime::component::Lift for RowSet {
                #[inline]
                fn lift(
                    cx: &mut wasmtime::component::__internal::LiftContext<'_>,
                    ty: wasmtime::component::__internal::InterfaceType,
                    src: &Self::Lower,
                ) -> wasmtime::component::__internal::anyhow::Result<Self> {
                    let ty = match ty {
                        wasmtime::component::__internal::InterfaceType::Record(i) => {
                            &cx.types[i]
                        }
                        _ => wasmtime::component::__internal::bad_type_info(),
                    };
                    Ok(Self {
                        columns: <Vec<
                            Column,
                        > as wasmtime::component::Lift>::lift(
                            cx,
                            ty.fields[0usize].ty,
                            &src.columns,
                        )?,
                        rows: <Vec<
                            Row,
                        > as wasmtime::component::Lift>::lift(
                            cx,
                            ty.fields[1usize].ty,
                            &src.rows,
                        )?,
                    })
                }
                #[inline]
                fn load(
                    cx: &mut wasmtime::component::__internal::LiftContext<'_>,
                    ty: wasmtime::component::__internal::InterfaceType,
                    bytes: &[u8],
                ) -> wasmtime::component::__internal::anyhow::Result<Self> {
                    let ty = match ty {
                        wasmtime::component::__internal::InterfaceType::Record(i) => {
                            &cx.types[i]
                        }
                        _ => wasmtime::component::__internal::bad_type_info(),
                    };
                    if true {
                        if !((bytes.as_ptr() as usize)
                            % (<Self as wasmtime::component::ComponentType>::ALIGN32
                                as usize) == 0)
                        {
                            ::core::panicking::panic(
                                "assertion failed: (bytes.as_ptr() as usize) %\\n        (<Self as wasmtime::component::ComponentType>::ALIGN32 as usize) == 0",
                            )
                        }
                    }
                    let mut offset = 0;
                    Ok(Self {
                        columns: <Vec<
                            Column,
                        > as wasmtime::component::Lift>::load(
                            cx,
                            ty.fields[0usize].ty,
                            &bytes[<Vec<
                                Column,
                            > as wasmtime::component::ComponentType>::ABI
                                .next_field32_size(
                                    &mut offset,
                                )..][..<Vec<
                                Column,
                            > as wasmtime::component::ComponentType>::SIZE32],
                        )?,
                        rows: <Vec<
                            Row,
                        > as wasmtime::component::Lift>::load(
                            cx,
                            ty.fields[1usize].ty,
                            &bytes[<Vec<Row> as wasmtime::component::ComponentType>::ABI
                                .next_field32_size(
                                    &mut offset,
                                )..][..<Vec<
                                Row,
                            > as wasmtime::component::ComponentType>::SIZE32],
                        )?,
                    })
                }
            }
            const _: () = {
                #[doc(hidden)]
                #[repr(C)]
                pub struct LowerRowSet<T0: Copy, T1: Copy> {
                    columns: T0,
                    rows: T1,
                    _align: [wasmtime::ValRaw; 0],
                }
                #[automatically_derived]
                impl<
                    T0: ::core::clone::Clone + Copy,
                    T1: ::core::clone::Clone + Copy,
                > ::core::clone::Clone for LowerRowSet<T0, T1> {
                    #[inline]
                    fn clone(&self) -> LowerRowSet<T0, T1> {
                        LowerRowSet {
                            columns: ::core::clone::Clone::clone(&self.columns),
                            rows: ::core::clone::Clone::clone(&self.rows),
                            _align: ::core::clone::Clone::clone(&self._align),
                        }
                    }
                }
                #[automatically_derived]
                impl<
                    T0: ::core::marker::Copy + Copy,
                    T1: ::core::marker::Copy + Copy,
                > ::core::marker::Copy for LowerRowSet<T0, T1> {}
                unsafe impl wasmtime::component::ComponentType for RowSet {
                    type Lower = LowerRowSet<
                        <Vec<Column> as wasmtime::component::ComponentType>::Lower,
                        <Vec<Row> as wasmtime::component::ComponentType>::Lower,
                    >;
                    const ABI: wasmtime::component::__internal::CanonicalAbiInfo = wasmtime::component::__internal::CanonicalAbiInfo::record_static(
                        &[
                            <Vec<Column> as wasmtime::component::ComponentType>::ABI,
                            <Vec<Row> as wasmtime::component::ComponentType>::ABI,
                        ],
                    );
                    #[inline]
                    fn typecheck(
                        ty: &wasmtime::component::__internal::InterfaceType,
                        types: &wasmtime::component::__internal::InstanceType<'_>,
                    ) -> wasmtime::component::__internal::anyhow::Result<()> {
                        wasmtime::component::__internal::typecheck_record(
                            ty,
                            types,
                            &[
                                (
                                    "columns",
                                    <Vec<
                                        Column,
                                    > as wasmtime::component::ComponentType>::typecheck,
                                ),
                                (
                                    "rows",
                                    <Vec<Row> as wasmtime::component::ComponentType>::typecheck,
                                ),
                            ],
                        )
                    }
                }
            };
            impl core::fmt::Debug for RowSet {
                fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
                    f.debug_struct("RowSet")
                        .field("columns", &self.columns)
                        .field("rows", &self.rows)
                        .finish()
                }
            }
            const _: () = {
                if !(16 == <RowSet as wasmtime::component::ComponentType>::SIZE32) {
                    ::core::panicking::panic(
                        "assertion failed: 16 == <RowSet as wasmtime::component::ComponentType>::SIZE32",
                    )
                }
                if !(4 == <RowSet as wasmtime::component::ComponentType>::ALIGN32) {
                    ::core::panicking::panic(
                        "assertion failed: 4 == <RowSet as wasmtime::component::ComponentType>::ALIGN32",
                    )
                }
            };
            pub trait Host {}
            pub fn add_to_linker<T, U>(
                linker: &mut wasmtime::component::Linker<T>,
                get: impl Fn(&mut T) -> &mut U + Send + Sync + Copy + 'static,
            ) -> wasmtime::Result<()>
            where
                T: Send,
                U: Host + Send,
            {
                let mut inst = linker.instance("fermyon:spin/rdbms-types")?;
                Ok(())
            }
        }
        #[allow(clippy::all)]
        pub mod postgres {
            #[allow(unused_imports)]
            use wasmtime::component::__internal::anyhow;
            pub type ParameterValue = super::super::super::fermyon::spin::rdbms_types::ParameterValue;
            const _: () = {
                if !(16
                    == <ParameterValue as wasmtime::component::ComponentType>::SIZE32)
                {
                    ::core::panicking::panic(
                        "assertion failed: 16 == <ParameterValue as wasmtime::component::ComponentType>::SIZE32",
                    )
                }
                if !(8
                    == <ParameterValue as wasmtime::component::ComponentType>::ALIGN32)
                {
                    ::core::panicking::panic(
                        "assertion failed: 8 == <ParameterValue as wasmtime::component::ComponentType>::ALIGN32",
                    )
                }
            };
            pub type RowSet = super::super::super::fermyon::spin::rdbms_types::RowSet;
            const _: () = {
                if !(16 == <RowSet as wasmtime::component::ComponentType>::SIZE32) {
                    ::core::panicking::panic(
                        "assertion failed: 16 == <RowSet as wasmtime::component::ComponentType>::SIZE32",
                    )
                }
                if !(4 == <RowSet as wasmtime::component::ComponentType>::ALIGN32) {
                    ::core::panicking::panic(
                        "assertion failed: 4 == <RowSet as wasmtime::component::ComponentType>::ALIGN32",
                    )
                }
            };
            #[component(variant)]
            pub enum PgError {
                #[component(name = "success")]
                Success,
                #[component(name = "connection-failed")]
                ConnectionFailed(String),
                #[component(name = "bad-parameter")]
                BadParameter(String),
                #[component(name = "query-failed")]
                QueryFailed(String),
                #[component(name = "value-conversion-failed")]
                ValueConversionFailed(String),
                #[component(name = "other-error")]
                OtherError(String),
            }
            #[automatically_derived]
            impl ::core::clone::Clone for PgError {
                #[inline]
                fn clone(&self) -> PgError {
                    match self {
                        PgError::Success => PgError::Success,
                        PgError::ConnectionFailed(__self_0) => {
                            PgError::ConnectionFailed(
                                ::core::clone::Clone::clone(__self_0),
                            )
                        }
                        PgError::BadParameter(__self_0) => {
                            PgError::BadParameter(::core::clone::Clone::clone(__self_0))
                        }
                        PgError::QueryFailed(__self_0) => {
                            PgError::QueryFailed(::core::clone::Clone::clone(__self_0))
                        }
                        PgError::ValueConversionFailed(__self_0) => {
                            PgError::ValueConversionFailed(
                                ::core::clone::Clone::clone(__self_0),
                            )
                        }
                        PgError::OtherError(__self_0) => {
                            PgError::OtherError(::core::clone::Clone::clone(__self_0))
                        }
                    }
                }
            }
            unsafe impl wasmtime::component::Lower for PgError {
                #[inline]
                fn lower<T>(
                    &self,
                    cx: &mut wasmtime::component::__internal::LowerContext<'_, T>,
                    ty: wasmtime::component::__internal::InterfaceType,
                    dst: &mut std::mem::MaybeUninit<Self::Lower>,
                ) -> wasmtime::component::__internal::anyhow::Result<()> {
                    let ty = match ty {
                        wasmtime::component::__internal::InterfaceType::Variant(i) => {
                            &cx.types[i]
                        }
                        _ => wasmtime::component::__internal::bad_type_info(),
                    };
                    match self {
                        Self::Success => {
                            {
                                #[allow(unused_unsafe)]
                                {
                                    unsafe {
                                        use ::wasmtime::component::__internal::MaybeUninitExt;
                                        let m: &mut std::mem::MaybeUninit<_> = dst;
                                        m.map(|p| &raw mut (*p).tag)
                                    }
                                }
                            }
                                .write(wasmtime::ValRaw::u32(0u32));
                            unsafe {
                                wasmtime::component::__internal::lower_payload(
                                    {
                                        #[allow(unused_unsafe)]
                                        {
                                            unsafe {
                                                use ::wasmtime::component::__internal::MaybeUninitExt;
                                                let m: &mut std::mem::MaybeUninit<_> = dst;
                                                m.map(|p| &raw mut (*p).payload)
                                            }
                                        }
                                    },
                                    |payload| {
                                        #[allow(unused_unsafe)]
                                        {
                                            unsafe {
                                                use ::wasmtime::component::__internal::MaybeUninitExt;
                                                let m: &mut std::mem::MaybeUninit<_> = payload;
                                                m.map(|p| &raw mut (*p).Success)
                                            }
                                        }
                                    },
                                    |dst| Ok(()),
                                )
                            }
                        }
                        Self::ConnectionFailed(value) => {
                            {
                                #[allow(unused_unsafe)]
                                {
                                    unsafe {
                                        use ::wasmtime::component::__internal::MaybeUninitExt;
                                        let m: &mut std::mem::MaybeUninit<_> = dst;
                                        m.map(|p| &raw mut (*p).tag)
                                    }
                                }
                            }
                                .write(wasmtime::ValRaw::u32(1u32));
                            unsafe {
                                wasmtime::component::__internal::lower_payload(
                                    {
                                        #[allow(unused_unsafe)]
                                        {
                                            unsafe {
                                                use ::wasmtime::component::__internal::MaybeUninitExt;
                                                let m: &mut std::mem::MaybeUninit<_> = dst;
                                                m.map(|p| &raw mut (*p).payload)
                                            }
                                        }
                                    },
                                    |payload| {
                                        #[allow(unused_unsafe)]
                                        {
                                            unsafe {
                                                use ::wasmtime::component::__internal::MaybeUninitExt;
                                                let m: &mut std::mem::MaybeUninit<_> = payload;
                                                m.map(|p| &raw mut (*p).ConnectionFailed)
                                            }
                                        }
                                    },
                                    |dst| {
                                        value
                                            .lower(
                                                cx,
                                                ty
                                                    .cases[1usize]
                                                    .ty
                                                    .unwrap_or_else(
                                                        wasmtime::component::__internal::bad_type_info,
                                                    ),
                                                dst,
                                            )
                                    },
                                )
                            }
                        }
                        Self::BadParameter(value) => {
                            {
                                #[allow(unused_unsafe)]
                                {
                                    unsafe {
                                        use ::wasmtime::component::__internal::MaybeUninitExt;
                                        let m: &mut std::mem::MaybeUninit<_> = dst;
                                        m.map(|p| &raw mut (*p).tag)
                                    }
                                }
                            }
                                .write(wasmtime::ValRaw::u32(2u32));
                            unsafe {
                                wasmtime::component::__internal::lower_payload(
                                    {
                                        #[allow(unused_unsafe)]
                                        {
                                            unsafe {
                                                use ::wasmtime::component::__internal::MaybeUninitExt;
                                                let m: &mut std::mem::MaybeUninit<_> = dst;
                                                m.map(|p| &raw mut (*p).payload)
                                            }
                                        }
                                    },
                                    |payload| {
                                        #[allow(unused_unsafe)]
                                        {
                                            unsafe {
                                                use ::wasmtime::component::__internal::MaybeUninitExt;
                                                let m: &mut std::mem::MaybeUninit<_> = payload;
                                                m.map(|p| &raw mut (*p).BadParameter)
                                            }
                                        }
                                    },
                                    |dst| {
                                        value
                                            .lower(
                                                cx,
                                                ty
                                                    .cases[2usize]
                                                    .ty
                                                    .unwrap_or_else(
                                                        wasmtime::component::__internal::bad_type_info,
                                                    ),
                                                dst,
                                            )
                                    },
                                )
                            }
                        }
                        Self::QueryFailed(value) => {
                            {
                                #[allow(unused_unsafe)]
                                {
                                    unsafe {
                                        use ::wasmtime::component::__internal::MaybeUninitExt;
                                        let m: &mut std::mem::MaybeUninit<_> = dst;
                                        m.map(|p| &raw mut (*p).tag)
                                    }
                                }
                            }
                                .write(wasmtime::ValRaw::u32(3u32));
                            unsafe {
                                wasmtime::component::__internal::lower_payload(
                                    {
                                        #[allow(unused_unsafe)]
                                        {
                                            unsafe {
                                                use ::wasmtime::component::__internal::MaybeUninitExt;
                                                let m: &mut std::mem::MaybeUninit<_> = dst;
                                                m.map(|p| &raw mut (*p).payload)
                                            }
                                        }
                                    },
                                    |payload| {
                                        #[allow(unused_unsafe)]
                                        {
                                            unsafe {
                                                use ::wasmtime::component::__internal::MaybeUninitExt;
                                                let m: &mut std::mem::MaybeUninit<_> = payload;
                                                m.map(|p| &raw mut (*p).QueryFailed)
                                            }
                                        }
                                    },
                                    |dst| {
                                        value
                                            .lower(
                                                cx,
                                                ty
                                                    .cases[3usize]
                                                    .ty
                                                    .unwrap_or_else(
                                                        wasmtime::component::__internal::bad_type_info,
                                                    ),
                                                dst,
                                            )
                                    },
                                )
                            }
                        }
                        Self::ValueConversionFailed(value) => {
                            {
                                #[allow(unused_unsafe)]
                                {
                                    unsafe {
                                        use ::wasmtime::component::__internal::MaybeUninitExt;
                                        let m: &mut std::mem::MaybeUninit<_> = dst;
                                        m.map(|p| &raw mut (*p).tag)
                                    }
                                }
                            }
                                .write(wasmtime::ValRaw::u32(4u32));
                            unsafe {
                                wasmtime::component::__internal::lower_payload(
                                    {
                                        #[allow(unused_unsafe)]
                                        {
                                            unsafe {
                                                use ::wasmtime::component::__internal::MaybeUninitExt;
                                                let m: &mut std::mem::MaybeUninit<_> = dst;
                                                m.map(|p| &raw mut (*p).payload)
                                            }
                                        }
                                    },
                                    |payload| {
                                        #[allow(unused_unsafe)]
                                        {
                                            unsafe {
                                                use ::wasmtime::component::__internal::MaybeUninitExt;
                                                let m: &mut std::mem::MaybeUninit<_> = payload;
                                                m.map(|p| &raw mut (*p).ValueConversionFailed)
                                            }
                                        }
                                    },
                                    |dst| {
                                        value
                                            .lower(
                                                cx,
                                                ty
                                                    .cases[4usize]
                                                    .ty
                                                    .unwrap_or_else(
                                                        wasmtime::component::__internal::bad_type_info,
                                                    ),
                                                dst,
                                            )
                                    },
                                )
                            }
                        }
                        Self::OtherError(value) => {
                            {
                                #[allow(unused_unsafe)]
                                {
                                    unsafe {
                                        use ::wasmtime::component::__internal::MaybeUninitExt;
                                        let m: &mut std::mem::MaybeUninit<_> = dst;
                                        m.map(|p| &raw mut (*p).tag)
                                    }
                                }
                            }
                                .write(wasmtime::ValRaw::u32(5u32));
                            unsafe {
                                wasmtime::component::__internal::lower_payload(
                                    {
                                        #[allow(unused_unsafe)]
                                        {
                                            unsafe {
                                                use ::wasmtime::component::__internal::MaybeUninitExt;
                                                let m: &mut std::mem::MaybeUninit<_> = dst;
                                                m.map(|p| &raw mut (*p).payload)
                                            }
                                        }
                                    },
                                    |payload| {
                                        #[allow(unused_unsafe)]
                                        {
                                            unsafe {
                                                use ::wasmtime::component::__internal::MaybeUninitExt;
                                                let m: &mut std::mem::MaybeUninit<_> = payload;
                                                m.map(|p| &raw mut (*p).OtherError)
                                            }
                                        }
                                    },
                                    |dst| {
                                        value
                                            .lower(
                                                cx,
                                                ty
                                                    .cases[5usize]
                                                    .ty
                                                    .unwrap_or_else(
                                                        wasmtime::component::__internal::bad_type_info,
                                                    ),
                                                dst,
                                            )
                                    },
                                )
                            }
                        }
                    }
                }
                #[inline]
                fn store<T>(
                    &self,
                    cx: &mut wasmtime::component::__internal::LowerContext<'_, T>,
                    ty: wasmtime::component::__internal::InterfaceType,
                    mut offset: usize,
                ) -> wasmtime::component::__internal::anyhow::Result<()> {
                    let ty = match ty {
                        wasmtime::component::__internal::InterfaceType::Variant(i) => {
                            &cx.types[i]
                        }
                        _ => wasmtime::component::__internal::bad_type_info(),
                    };
                    if true {
                        if !(offset
                            % (<Self as wasmtime::component::ComponentType>::ALIGN32
                                as usize) == 0)
                        {
                            ::core::panicking::panic(
                                "assertion failed: offset % (<Self as wasmtime::component::ComponentType>::ALIGN32 as usize) == 0",
                            )
                        }
                    }
                    match self {
                        Self::Success => {
                            *cx.get::<1usize>(offset) = 0u8.to_le_bytes();
                            Ok(())
                        }
                        Self::ConnectionFailed(value) => {
                            *cx.get::<1usize>(offset) = 1u8.to_le_bytes();
                            value
                                .store(
                                    cx,
                                    ty
                                        .cases[1usize]
                                        .ty
                                        .unwrap_or_else(
                                            wasmtime::component::__internal::bad_type_info,
                                        ),
                                    offset
                                        + <Self as wasmtime::component::__internal::ComponentVariant>::PAYLOAD_OFFSET32,
                                )
                        }
                        Self::BadParameter(value) => {
                            *cx.get::<1usize>(offset) = 2u8.to_le_bytes();
                            value
                                .store(
                                    cx,
                                    ty
                                        .cases[2usize]
                                        .ty
                                        .unwrap_or_else(
                                            wasmtime::component::__internal::bad_type_info,
                                        ),
                                    offset
                                        + <Self as wasmtime::component::__internal::ComponentVariant>::PAYLOAD_OFFSET32,
                                )
                        }
                        Self::QueryFailed(value) => {
                            *cx.get::<1usize>(offset) = 3u8.to_le_bytes();
                            value
                                .store(
                                    cx,
                                    ty
                                        .cases[3usize]
                                        .ty
                                        .unwrap_or_else(
                                            wasmtime::component::__internal::bad_type_info,
                                        ),
                                    offset
                                        + <Self as wasmtime::component::__internal::ComponentVariant>::PAYLOAD_OFFSET32,
                                )
                        }
                        Self::ValueConversionFailed(value) => {
                            *cx.get::<1usize>(offset) = 4u8.to_le_bytes();
                            value
                                .store(
                                    cx,
                                    ty
                                        .cases[4usize]
                                        .ty
                                        .unwrap_or_else(
                                            wasmtime::component::__internal::bad_type_info,
                                        ),
                                    offset
                                        + <Self as wasmtime::component::__internal::ComponentVariant>::PAYLOAD_OFFSET32,
                                )
                        }
                        Self::OtherError(value) => {
                            *cx.get::<1usize>(offset) = 5u8.to_le_bytes();
                            value
                                .store(
                                    cx,
                                    ty
                                        .cases[5usize]
                                        .ty
                                        .unwrap_or_else(
                                            wasmtime::component::__internal::bad_type_info,
                                        ),
                                    offset
                                        + <Self as wasmtime::component::__internal::ComponentVariant>::PAYLOAD_OFFSET32,
                                )
                        }
                    }
                }
            }
            unsafe impl wasmtime::component::Lift for PgError {
                #[inline]
                fn lift(
                    cx: &mut wasmtime::component::__internal::LiftContext<'_>,
                    ty: wasmtime::component::__internal::InterfaceType,
                    src: &Self::Lower,
                ) -> wasmtime::component::__internal::anyhow::Result<Self> {
                    let ty = match ty {
                        wasmtime::component::__internal::InterfaceType::Variant(i) => {
                            &cx.types[i]
                        }
                        _ => wasmtime::component::__internal::bad_type_info(),
                    };
                    Ok(
                        match src.tag.get_u32() {
                            0u32 => Self::Success,
                            1u32 => {
                                Self::ConnectionFailed(
                                    <String as wasmtime::component::Lift>::lift(
                                        cx,
                                        ty
                                            .cases[1usize]
                                            .ty
                                            .unwrap_or_else(
                                                wasmtime::component::__internal::bad_type_info,
                                            ),
                                        unsafe { &src.payload.ConnectionFailed },
                                    )?,
                                )
                            }
                            2u32 => {
                                Self::BadParameter(
                                    <String as wasmtime::component::Lift>::lift(
                                        cx,
                                        ty
                                            .cases[2usize]
                                            .ty
                                            .unwrap_or_else(
                                                wasmtime::component::__internal::bad_type_info,
                                            ),
                                        unsafe { &src.payload.BadParameter },
                                    )?,
                                )
                            }
                            3u32 => {
                                Self::QueryFailed(
                                    <String as wasmtime::component::Lift>::lift(
                                        cx,
                                        ty
                                            .cases[3usize]
                                            .ty
                                            .unwrap_or_else(
                                                wasmtime::component::__internal::bad_type_info,
                                            ),
                                        unsafe { &src.payload.QueryFailed },
                                    )?,
                                )
                            }
                            4u32 => {
                                Self::ValueConversionFailed(
                                    <String as wasmtime::component::Lift>::lift(
                                        cx,
                                        ty
                                            .cases[4usize]
                                            .ty
                                            .unwrap_or_else(
                                                wasmtime::component::__internal::bad_type_info,
                                            ),
                                        unsafe { &src.payload.ValueConversionFailed },
                                    )?,
                                )
                            }
                            5u32 => {
                                Self::OtherError(
                                    <String as wasmtime::component::Lift>::lift(
                                        cx,
                                        ty
                                            .cases[5usize]
                                            .ty
                                            .unwrap_or_else(
                                                wasmtime::component::__internal::bad_type_info,
                                            ),
                                        unsafe { &src.payload.OtherError },
                                    )?,
                                )
                            }
                            discrim => {
                                return ::anyhow::__private::Err(
                                    ::anyhow::Error::msg({
                                        let res = ::alloc::fmt::format(
                                            format_args!("unexpected discriminant: {0}", discrim),
                                        );
                                        res
                                    }),
                                );
                            }
                        },
                    )
                }
                #[inline]
                fn load(
                    cx: &mut wasmtime::component::__internal::LiftContext<'_>,
                    ty: wasmtime::component::__internal::InterfaceType,
                    bytes: &[u8],
                ) -> wasmtime::component::__internal::anyhow::Result<Self> {
                    let align = <Self as wasmtime::component::ComponentType>::ALIGN32;
                    if true {
                        if !((bytes.as_ptr() as usize) % (align as usize) == 0) {
                            ::core::panicking::panic(
                                "assertion failed: (bytes.as_ptr() as usize) % (align as usize) == 0",
                            )
                        }
                    }
                    let discrim = bytes[0];
                    let payload_offset = <Self as wasmtime::component::__internal::ComponentVariant>::PAYLOAD_OFFSET32;
                    let payload = &bytes[payload_offset..];
                    let ty = match ty {
                        wasmtime::component::__internal::InterfaceType::Variant(i) => {
                            &cx.types[i]
                        }
                        _ => wasmtime::component::__internal::bad_type_info(),
                    };
                    Ok(
                        match discrim {
                            0u8 => Self::Success,
                            1u8 => {
                                Self::ConnectionFailed(
                                    <String as wasmtime::component::Lift>::load(
                                        cx,
                                        ty
                                            .cases[1usize]
                                            .ty
                                            .unwrap_or_else(
                                                wasmtime::component::__internal::bad_type_info,
                                            ),
                                        &payload[..<String as wasmtime::component::ComponentType>::SIZE32],
                                    )?,
                                )
                            }
                            2u8 => {
                                Self::BadParameter(
                                    <String as wasmtime::component::Lift>::load(
                                        cx,
                                        ty
                                            .cases[2usize]
                                            .ty
                                            .unwrap_or_else(
                                                wasmtime::component::__internal::bad_type_info,
                                            ),
                                        &payload[..<String as wasmtime::component::ComponentType>::SIZE32],
                                    )?,
                                )
                            }
                            3u8 => {
                                Self::QueryFailed(
                                    <String as wasmtime::component::Lift>::load(
                                        cx,
                                        ty
                                            .cases[3usize]
                                            .ty
                                            .unwrap_or_else(
                                                wasmtime::component::__internal::bad_type_info,
                                            ),
                                        &payload[..<String as wasmtime::component::ComponentType>::SIZE32],
                                    )?,
                                )
                            }
                            4u8 => {
                                Self::ValueConversionFailed(
                                    <String as wasmtime::component::Lift>::load(
                                        cx,
                                        ty
                                            .cases[4usize]
                                            .ty
                                            .unwrap_or_else(
                                                wasmtime::component::__internal::bad_type_info,
                                            ),
                                        &payload[..<String as wasmtime::component::ComponentType>::SIZE32],
                                    )?,
                                )
                            }
                            5u8 => {
                                Self::OtherError(
                                    <String as wasmtime::component::Lift>::load(
                                        cx,
                                        ty
                                            .cases[5usize]
                                            .ty
                                            .unwrap_or_else(
                                                wasmtime::component::__internal::bad_type_info,
                                            ),
                                        &payload[..<String as wasmtime::component::ComponentType>::SIZE32],
                                    )?,
                                )
                            }
                            discrim => {
                                return ::anyhow::__private::Err(
                                    ::anyhow::Error::msg({
                                        let res = ::alloc::fmt::format(
                                            format_args!("unexpected discriminant: {0}", discrim),
                                        );
                                        res
                                    }),
                                );
                            }
                        },
                    )
                }
            }
            const _: () = {
                #[doc(hidden)]
                #[repr(C)]
                pub struct LowerPgError<
                    T1: Copy,
                    T2: Copy,
                    T3: Copy,
                    T4: Copy,
                    T5: Copy,
                > {
                    tag: wasmtime::ValRaw,
                    payload: LowerPayloadPgError<T1, T2, T3, T4, T5>,
                }
                #[automatically_derived]
                impl<
                    T1: ::core::clone::Clone + Copy,
                    T2: ::core::clone::Clone + Copy,
                    T3: ::core::clone::Clone + Copy,
                    T4: ::core::clone::Clone + Copy,
                    T5: ::core::clone::Clone + Copy,
                > ::core::clone::Clone for LowerPgError<T1, T2, T3, T4, T5> {
                    #[inline]
                    fn clone(&self) -> LowerPgError<T1, T2, T3, T4, T5> {
                        LowerPgError {
                            tag: ::core::clone::Clone::clone(&self.tag),
                            payload: ::core::clone::Clone::clone(&self.payload),
                        }
                    }
                }
                #[automatically_derived]
                impl<
                    T1: ::core::marker::Copy + Copy,
                    T2: ::core::marker::Copy + Copy,
                    T3: ::core::marker::Copy + Copy,
                    T4: ::core::marker::Copy + Copy,
                    T5: ::core::marker::Copy + Copy,
                > ::core::marker::Copy for LowerPgError<T1, T2, T3, T4, T5> {}
                #[doc(hidden)]
                #[allow(non_snake_case)]
                #[repr(C)]
                union LowerPayloadPgError<
                    T1: Copy,
                    T2: Copy,
                    T3: Copy,
                    T4: Copy,
                    T5: Copy,
                > {
                    Success: [wasmtime::ValRaw; 0],
                    ConnectionFailed: T1,
                    BadParameter: T2,
                    QueryFailed: T3,
                    ValueConversionFailed: T4,
                    OtherError: T5,
                }
                #[automatically_derived]
                #[allow(non_snake_case)]
                impl<
                    T1: ::core::marker::Copy + ::core::clone::Clone + Copy,
                    T2: ::core::marker::Copy + ::core::clone::Clone + Copy,
                    T3: ::core::marker::Copy + ::core::clone::Clone + Copy,
                    T4: ::core::marker::Copy + ::core::clone::Clone + Copy,
                    T5: ::core::marker::Copy + ::core::clone::Clone + Copy,
                > ::core::clone::Clone for LowerPayloadPgError<T1, T2, T3, T4, T5> {
                    #[inline]
                    fn clone(&self) -> LowerPayloadPgError<T1, T2, T3, T4, T5> {
                        let _: ::core::clone::AssertParamIsCopy<Self>;
                        *self
                    }
                }
                #[automatically_derived]
                #[allow(non_snake_case)]
                impl<
                    T1: ::core::marker::Copy + Copy,
                    T2: ::core::marker::Copy + Copy,
                    T3: ::core::marker::Copy + Copy,
                    T4: ::core::marker::Copy + Copy,
                    T5: ::core::marker::Copy + Copy,
                > ::core::marker::Copy for LowerPayloadPgError<T1, T2, T3, T4, T5> {}
                unsafe impl wasmtime::component::ComponentType for PgError {
                    type Lower = LowerPgError<
                        <String as wasmtime::component::ComponentType>::Lower,
                        <String as wasmtime::component::ComponentType>::Lower,
                        <String as wasmtime::component::ComponentType>::Lower,
                        <String as wasmtime::component::ComponentType>::Lower,
                        <String as wasmtime::component::ComponentType>::Lower,
                    >;
                    #[inline]
                    fn typecheck(
                        ty: &wasmtime::component::__internal::InterfaceType,
                        types: &wasmtime::component::__internal::InstanceType<'_>,
                    ) -> wasmtime::component::__internal::anyhow::Result<()> {
                        wasmtime::component::__internal::typecheck_variant(
                            ty,
                            types,
                            &[
                                ("success", None),
                                (
                                    "connection-failed",
                                    Some(
                                        <String as wasmtime::component::ComponentType>::typecheck,
                                    ),
                                ),
                                (
                                    "bad-parameter",
                                    Some(
                                        <String as wasmtime::component::ComponentType>::typecheck,
                                    ),
                                ),
                                (
                                    "query-failed",
                                    Some(
                                        <String as wasmtime::component::ComponentType>::typecheck,
                                    ),
                                ),
                                (
                                    "value-conversion-failed",
                                    Some(
                                        <String as wasmtime::component::ComponentType>::typecheck,
                                    ),
                                ),
                                (
                                    "other-error",
                                    Some(
                                        <String as wasmtime::component::ComponentType>::typecheck,
                                    ),
                                ),
                            ],
                        )
                    }
                    const ABI: wasmtime::component::__internal::CanonicalAbiInfo = wasmtime::component::__internal::CanonicalAbiInfo::variant_static(
                        &[
                            None,
                            Some(<String as wasmtime::component::ComponentType>::ABI),
                            Some(<String as wasmtime::component::ComponentType>::ABI),
                            Some(<String as wasmtime::component::ComponentType>::ABI),
                            Some(<String as wasmtime::component::ComponentType>::ABI),
                            Some(<String as wasmtime::component::ComponentType>::ABI),
                        ],
                    );
                }
                unsafe impl wasmtime::component::__internal::ComponentVariant
                for PgError {
                    const CASES: &'static [Option<
                        wasmtime::component::__internal::CanonicalAbiInfo,
                    >] = &[
                        None,
                        Some(<String as wasmtime::component::ComponentType>::ABI),
                        Some(<String as wasmtime::component::ComponentType>::ABI),
                        Some(<String as wasmtime::component::ComponentType>::ABI),
                        Some(<String as wasmtime::component::ComponentType>::ABI),
                        Some(<String as wasmtime::component::ComponentType>::ABI),
                    ];
                }
            };
            impl core::fmt::Debug for PgError {
                fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
                    match self {
                        PgError::Success => f.debug_tuple("PgError::Success").finish(),
                        PgError::ConnectionFailed(e) => {
                            f.debug_tuple("PgError::ConnectionFailed").field(e).finish()
                        }
                        PgError::BadParameter(e) => {
                            f.debug_tuple("PgError::BadParameter").field(e).finish()
                        }
                        PgError::QueryFailed(e) => {
                            f.debug_tuple("PgError::QueryFailed").field(e).finish()
                        }
                        PgError::ValueConversionFailed(e) => {
                            f.debug_tuple("PgError::ValueConversionFailed")
                                .field(e)
                                .finish()
                        }
                        PgError::OtherError(e) => {
                            f.debug_tuple("PgError::OtherError").field(e).finish()
                        }
                    }
                }
            }
            impl core::fmt::Display for PgError {
                fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
                    f.write_fmt(format_args!("{0:?}", self))
                }
            }
            impl std::error::Error for PgError {}
            const _: () = {
                if !(12 == <PgError as wasmtime::component::ComponentType>::SIZE32) {
                    ::core::panicking::panic(
                        "assertion failed: 12 == <PgError as wasmtime::component::ComponentType>::SIZE32",
                    )
                }
                if !(4 == <PgError as wasmtime::component::ComponentType>::ALIGN32) {
                    ::core::panicking::panic(
                        "assertion failed: 4 == <PgError as wasmtime::component::ComponentType>::ALIGN32",
                    )
                }
            };
            pub trait Host {
                #[must_use]
                #[allow(clippy::type_complexity, clippy::type_repetition_in_bounds)]
                fn query<'life0, 'async_trait>(
                    &'life0 mut self,
                    address: String,
                    statement: String,
                    params: Vec<ParameterValue>,
                ) -> ::core::pin::Pin<
                    Box<
                        dyn ::core::future::Future<
                            Output = wasmtime::Result<Result<RowSet, PgError>>,
                        > + ::core::marker::Send + 'async_trait,
                    >,
                >
                where
                    'life0: 'async_trait,
                    Self: 'async_trait;
                #[must_use]
                #[allow(clippy::type_complexity, clippy::type_repetition_in_bounds)]
                fn execute<'life0, 'async_trait>(
                    &'life0 mut self,
                    address: String,
                    statement: String,
                    params: Vec<ParameterValue>,
                ) -> ::core::pin::Pin<
                    Box<
                        dyn ::core::future::Future<
                            Output = wasmtime::Result<Result<u64, PgError>>,
                        > + ::core::marker::Send + 'async_trait,
                    >,
                >
                where
                    'life0: 'async_trait,
                    Self: 'async_trait;
            }
            pub fn add_to_linker<T, U>(
                linker: &mut wasmtime::component::Linker<T>,
                get: impl Fn(&mut T) -> &mut U + Send + Sync + Copy + 'static,
            ) -> wasmtime::Result<()>
            where
                T: Send,
                U: Host + Send,
            {
                let mut inst = linker.instance("fermyon:spin/postgres")?;
                inst.func_wrap_async(
                    "query",
                    move |
                        mut caller: wasmtime::StoreContextMut<'_, T>,
                        (arg0, arg1, arg2): (String, String, Vec<ParameterValue>)|
                    Box::new(async move {
                        let host = get(caller.data_mut());
                        let r = Host::query(host, arg0, arg1, arg2).await;
                        Ok((r?,))
                    }),
                )?;
                inst.func_wrap_async(
                    "execute",
                    move |
                        mut caller: wasmtime::StoreContextMut<'_, T>,
                        (arg0, arg1, arg2): (String, String, Vec<ParameterValue>)|
                    Box::new(async move {
                        let host = get(caller.data_mut());
                        let r = Host::execute(host, arg0, arg1, arg2).await;
                        Ok((r?,))
                    }),
                )?;
                Ok(())
            }
        }
        #[allow(clippy::all)]
        pub mod mysql {
            #[allow(unused_imports)]
            use wasmtime::component::__internal::anyhow;
            pub type ParameterValue = super::super::super::fermyon::spin::rdbms_types::ParameterValue;
            const _: () = {
                if !(16
                    == <ParameterValue as wasmtime::component::ComponentType>::SIZE32)
                {
                    ::core::panicking::panic(
                        "assertion failed: 16 == <ParameterValue as wasmtime::component::ComponentType>::SIZE32",
                    )
                }
                if !(8
                    == <ParameterValue as wasmtime::component::ComponentType>::ALIGN32)
                {
                    ::core::panicking::panic(
                        "assertion failed: 8 == <ParameterValue as wasmtime::component::ComponentType>::ALIGN32",
                    )
                }
            };
            pub type RowSet = super::super::super::fermyon::spin::rdbms_types::RowSet;
            const _: () = {
                if !(16 == <RowSet as wasmtime::component::ComponentType>::SIZE32) {
                    ::core::panicking::panic(
                        "assertion failed: 16 == <RowSet as wasmtime::component::ComponentType>::SIZE32",
                    )
                }
                if !(4 == <RowSet as wasmtime::component::ComponentType>::ALIGN32) {
                    ::core::panicking::panic(
                        "assertion failed: 4 == <RowSet as wasmtime::component::ComponentType>::ALIGN32",
                    )
                }
            };
            #[component(variant)]
            pub enum MysqlError {
                #[component(name = "success")]
                Success,
                #[component(name = "connection-failed")]
                ConnectionFailed(String),
                #[component(name = "bad-parameter")]
                BadParameter(String),
                #[component(name = "query-failed")]
                QueryFailed(String),
                #[component(name = "value-conversion-failed")]
                ValueConversionFailed(String),
                #[component(name = "other-error")]
                OtherError(String),
            }
            #[automatically_derived]
            impl ::core::clone::Clone for MysqlError {
                #[inline]
                fn clone(&self) -> MysqlError {
                    match self {
                        MysqlError::Success => MysqlError::Success,
                        MysqlError::ConnectionFailed(__self_0) => {
                            MysqlError::ConnectionFailed(
                                ::core::clone::Clone::clone(__self_0),
                            )
                        }
                        MysqlError::BadParameter(__self_0) => {
                            MysqlError::BadParameter(
                                ::core::clone::Clone::clone(__self_0),
                            )
                        }
                        MysqlError::QueryFailed(__self_0) => {
                            MysqlError::QueryFailed(
                                ::core::clone::Clone::clone(__self_0),
                            )
                        }
                        MysqlError::ValueConversionFailed(__self_0) => {
                            MysqlError::ValueConversionFailed(
                                ::core::clone::Clone::clone(__self_0),
                            )
                        }
                        MysqlError::OtherError(__self_0) => {
                            MysqlError::OtherError(::core::clone::Clone::clone(__self_0))
                        }
                    }
                }
            }
            unsafe impl wasmtime::component::Lower for MysqlError {
                #[inline]
                fn lower<T>(
                    &self,
                    cx: &mut wasmtime::component::__internal::LowerContext<'_, T>,
                    ty: wasmtime::component::__internal::InterfaceType,
                    dst: &mut std::mem::MaybeUninit<Self::Lower>,
                ) -> wasmtime::component::__internal::anyhow::Result<()> {
                    let ty = match ty {
                        wasmtime::component::__internal::InterfaceType::Variant(i) => {
                            &cx.types[i]
                        }
                        _ => wasmtime::component::__internal::bad_type_info(),
                    };
                    match self {
                        Self::Success => {
                            {
                                #[allow(unused_unsafe)]
                                {
                                    unsafe {
                                        use ::wasmtime::component::__internal::MaybeUninitExt;
                                        let m: &mut std::mem::MaybeUninit<_> = dst;
                                        m.map(|p| &raw mut (*p).tag)
                                    }
                                }
                            }
                                .write(wasmtime::ValRaw::u32(0u32));
                            unsafe {
                                wasmtime::component::__internal::lower_payload(
                                    {
                                        #[allow(unused_unsafe)]
                                        {
                                            unsafe {
                                                use ::wasmtime::component::__internal::MaybeUninitExt;
                                                let m: &mut std::mem::MaybeUninit<_> = dst;
                                                m.map(|p| &raw mut (*p).payload)
                                            }
                                        }
                                    },
                                    |payload| {
                                        #[allow(unused_unsafe)]
                                        {
                                            unsafe {
                                                use ::wasmtime::component::__internal::MaybeUninitExt;
                                                let m: &mut std::mem::MaybeUninit<_> = payload;
                                                m.map(|p| &raw mut (*p).Success)
                                            }
                                        }
                                    },
                                    |dst| Ok(()),
                                )
                            }
                        }
                        Self::ConnectionFailed(value) => {
                            {
                                #[allow(unused_unsafe)]
                                {
                                    unsafe {
                                        use ::wasmtime::component::__internal::MaybeUninitExt;
                                        let m: &mut std::mem::MaybeUninit<_> = dst;
                                        m.map(|p| &raw mut (*p).tag)
                                    }
                                }
                            }
                                .write(wasmtime::ValRaw::u32(1u32));
                            unsafe {
                                wasmtime::component::__internal::lower_payload(
                                    {
                                        #[allow(unused_unsafe)]
                                        {
                                            unsafe {
                                                use ::wasmtime::component::__internal::MaybeUninitExt;
                                                let m: &mut std::mem::MaybeUninit<_> = dst;
                                                m.map(|p| &raw mut (*p).payload)
                                            }
                                        }
                                    },
                                    |payload| {
                                        #[allow(unused_unsafe)]
                                        {
                                            unsafe {
                                                use ::wasmtime::component::__internal::MaybeUninitExt;
                                                let m: &mut std::mem::MaybeUninit<_> = payload;
                                                m.map(|p| &raw mut (*p).ConnectionFailed)
                                            }
                                        }
                                    },
                                    |dst| {
                                        value
                                            .lower(
                                                cx,
                                                ty
                                                    .cases[1usize]
                                                    .ty
                                                    .unwrap_or_else(
                                                        wasmtime::component::__internal::bad_type_info,
                                                    ),
                                                dst,
                                            )
                                    },
                                )
                            }
                        }
                        Self::BadParameter(value) => {
                            {
                                #[allow(unused_unsafe)]
                                {
                                    unsafe {
                                        use ::wasmtime::component::__internal::MaybeUninitExt;
                                        let m: &mut std::mem::MaybeUninit<_> = dst;
                                        m.map(|p| &raw mut (*p).tag)
                                    }
                                }
                            }
                                .write(wasmtime::ValRaw::u32(2u32));
                            unsafe {
                                wasmtime::component::__internal::lower_payload(
                                    {
                                        #[allow(unused_unsafe)]
                                        {
                                            unsafe {
                                                use ::wasmtime::component::__internal::MaybeUninitExt;
                                                let m: &mut std::mem::MaybeUninit<_> = dst;
                                                m.map(|p| &raw mut (*p).payload)
                                            }
                                        }
                                    },
                                    |payload| {
                                        #[allow(unused_unsafe)]
                                        {
                                            unsafe {
                                                use ::wasmtime::component::__internal::MaybeUninitExt;
                                                let m: &mut std::mem::MaybeUninit<_> = payload;
                                                m.map(|p| &raw mut (*p).BadParameter)
                                            }
                                        }
                                    },
                                    |dst| {
                                        value
                                            .lower(
                                                cx,
                                                ty
                                                    .cases[2usize]
                                                    .ty
                                                    .unwrap_or_else(
                                                        wasmtime::component::__internal::bad_type_info,
                                                    ),
                                                dst,
                                            )
                                    },
                                )
                            }
                        }
                        Self::QueryFailed(value) => {
                            {
                                #[allow(unused_unsafe)]
                                {
                                    unsafe {
                                        use ::wasmtime::component::__internal::MaybeUninitExt;
                                        let m: &mut std::mem::MaybeUninit<_> = dst;
                                        m.map(|p| &raw mut (*p).tag)
                                    }
                                }
                            }
                                .write(wasmtime::ValRaw::u32(3u32));
                            unsafe {
                                wasmtime::component::__internal::lower_payload(
                                    {
                                        #[allow(unused_unsafe)]
                                        {
                                            unsafe {
                                                use ::wasmtime::component::__internal::MaybeUninitExt;
                                                let m: &mut std::mem::MaybeUninit<_> = dst;
                                                m.map(|p| &raw mut (*p).payload)
                                            }
                                        }
                                    },
                                    |payload| {
                                        #[allow(unused_unsafe)]
                                        {
                                            unsafe {
                                                use ::wasmtime::component::__internal::MaybeUninitExt;
                                                let m: &mut std::mem::MaybeUninit<_> = payload;
                                                m.map(|p| &raw mut (*p).QueryFailed)
                                            }
                                        }
                                    },
                                    |dst| {
                                        value
                                            .lower(
                                                cx,
                                                ty
                                                    .cases[3usize]
                                                    .ty
                                                    .unwrap_or_else(
                                                        wasmtime::component::__internal::bad_type_info,
                                                    ),
                                                dst,
                                            )
                                    },
                                )
                            }
                        }
                        Self::ValueConversionFailed(value) => {
                            {
                                #[allow(unused_unsafe)]
                                {
                                    unsafe {
                                        use ::wasmtime::component::__internal::MaybeUninitExt;
                                        let m: &mut std::mem::MaybeUninit<_> = dst;
                                        m.map(|p| &raw mut (*p).tag)
                                    }
                                }
                            }
                                .write(wasmtime::ValRaw::u32(4u32));
                            unsafe {
                                wasmtime::component::__internal::lower_payload(
                                    {
                                        #[allow(unused_unsafe)]
                                        {
                                            unsafe {
                                                use ::wasmtime::component::__internal::MaybeUninitExt;
                                                let m: &mut std::mem::MaybeUninit<_> = dst;
                                                m.map(|p| &raw mut (*p).payload)
                                            }
                                        }
                                    },
                                    |payload| {
                                        #[allow(unused_unsafe)]
                                        {
                                            unsafe {
                                                use ::wasmtime::component::__internal::MaybeUninitExt;
                                                let m: &mut std::mem::MaybeUninit<_> = payload;
                                                m.map(|p| &raw mut (*p).ValueConversionFailed)
                                            }
                                        }
                                    },
                                    |dst| {
                                        value
                                            .lower(
                                                cx,
                                                ty
                                                    .cases[4usize]
                                                    .ty
                                                    .unwrap_or_else(
                                                        wasmtime::component::__internal::bad_type_info,
                                                    ),
                                                dst,
                                            )
                                    },
                                )
                            }
                        }
                        Self::OtherError(value) => {
                            {
                                #[allow(unused_unsafe)]
                                {
                                    unsafe {
                                        use ::wasmtime::component::__internal::MaybeUninitExt;
                                        let m: &mut std::mem::MaybeUninit<_> = dst;
                                        m.map(|p| &raw mut (*p).tag)
                                    }
                                }
                            }
                                .write(wasmtime::ValRaw::u32(5u32));
                            unsafe {
                                wasmtime::component::__internal::lower_payload(
                                    {
                                        #[allow(unused_unsafe)]
                                        {
                                            unsafe {
                                                use ::wasmtime::component::__internal::MaybeUninitExt;
                                                let m: &mut std::mem::MaybeUninit<_> = dst;
                                                m.map(|p| &raw mut (*p).payload)
                                            }
                                        }
                                    },
                                    |payload| {
                                        #[allow(unused_unsafe)]
                                        {
                                            unsafe {
                                                use ::wasmtime::component::__internal::MaybeUninitExt;
                                                let m: &mut std::mem::MaybeUninit<_> = payload;
                                                m.map(|p| &raw mut (*p).OtherError)
                                            }
                                        }
                                    },
                                    |dst| {
                                        value
                                            .lower(
                                                cx,
                                                ty
                                                    .cases[5usize]
                                                    .ty
                                                    .unwrap_or_else(
                                                        wasmtime::component::__internal::bad_type_info,
                                                    ),
                                                dst,
                                            )
                                    },
                                )
                            }
                        }
                    }
                }
                #[inline]
                fn store<T>(
                    &self,
                    cx: &mut wasmtime::component::__internal::LowerContext<'_, T>,
                    ty: wasmtime::component::__internal::InterfaceType,
                    mut offset: usize,
                ) -> wasmtime::component::__internal::anyhow::Result<()> {
                    let ty = match ty {
                        wasmtime::component::__internal::InterfaceType::Variant(i) => {
                            &cx.types[i]
                        }
                        _ => wasmtime::component::__internal::bad_type_info(),
                    };
                    if true {
                        if !(offset
                            % (<Self as wasmtime::component::ComponentType>::ALIGN32
                                as usize) == 0)
                        {
                            ::core::panicking::panic(
                                "assertion failed: offset % (<Self as wasmtime::component::ComponentType>::ALIGN32 as usize) == 0",
                            )
                        }
                    }
                    match self {
                        Self::Success => {
                            *cx.get::<1usize>(offset) = 0u8.to_le_bytes();
                            Ok(())
                        }
                        Self::ConnectionFailed(value) => {
                            *cx.get::<1usize>(offset) = 1u8.to_le_bytes();
                            value
                                .store(
                                    cx,
                                    ty
                                        .cases[1usize]
                                        .ty
                                        .unwrap_or_else(
                                            wasmtime::component::__internal::bad_type_info,
                                        ),
                                    offset
                                        + <Self as wasmtime::component::__internal::ComponentVariant>::PAYLOAD_OFFSET32,
                                )
                        }
                        Self::BadParameter(value) => {
                            *cx.get::<1usize>(offset) = 2u8.to_le_bytes();
                            value
                                .store(
                                    cx,
                                    ty
                                        .cases[2usize]
                                        .ty
                                        .unwrap_or_else(
                                            wasmtime::component::__internal::bad_type_info,
                                        ),
                                    offset
                                        + <Self as wasmtime::component::__internal::ComponentVariant>::PAYLOAD_OFFSET32,
                                )
                        }
                        Self::QueryFailed(value) => {
                            *cx.get::<1usize>(offset) = 3u8.to_le_bytes();
                            value
                                .store(
                                    cx,
                                    ty
                                        .cases[3usize]
                                        .ty
                                        .unwrap_or_else(
                                            wasmtime::component::__internal::bad_type_info,
                                        ),
                                    offset
                                        + <Self as wasmtime::component::__internal::ComponentVariant>::PAYLOAD_OFFSET32,
                                )
                        }
                        Self::ValueConversionFailed(value) => {
                            *cx.get::<1usize>(offset) = 4u8.to_le_bytes();
                            value
                                .store(
                                    cx,
                                    ty
                                        .cases[4usize]
                                        .ty
                                        .unwrap_or_else(
                                            wasmtime::component::__internal::bad_type_info,
                                        ),
                                    offset
                                        + <Self as wasmtime::component::__internal::ComponentVariant>::PAYLOAD_OFFSET32,
                                )
                        }
                        Self::OtherError(value) => {
                            *cx.get::<1usize>(offset) = 5u8.to_le_bytes();
                            value
                                .store(
                                    cx,
                                    ty
                                        .cases[5usize]
                                        .ty
                                        .unwrap_or_else(
                                            wasmtime::component::__internal::bad_type_info,
                                        ),
                                    offset
                                        + <Self as wasmtime::component::__internal::ComponentVariant>::PAYLOAD_OFFSET32,
                                )
                        }
                    }
                }
            }
            unsafe impl wasmtime::component::Lift for MysqlError {
                #[inline]
                fn lift(
                    cx: &mut wasmtime::component::__internal::LiftContext<'_>,
                    ty: wasmtime::component::__internal::InterfaceType,
                    src: &Self::Lower,
                ) -> wasmtime::component::__internal::anyhow::Result<Self> {
                    let ty = match ty {
                        wasmtime::component::__internal::InterfaceType::Variant(i) => {
                            &cx.types[i]
                        }
                        _ => wasmtime::component::__internal::bad_type_info(),
                    };
                    Ok(
                        match src.tag.get_u32() {
                            0u32 => Self::Success,
                            1u32 => {
                                Self::ConnectionFailed(
                                    <String as wasmtime::component::Lift>::lift(
                                        cx,
                                        ty
                                            .cases[1usize]
                                            .ty
                                            .unwrap_or_else(
                                                wasmtime::component::__internal::bad_type_info,
                                            ),
                                        unsafe { &src.payload.ConnectionFailed },
                                    )?,
                                )
                            }
                            2u32 => {
                                Self::BadParameter(
                                    <String as wasmtime::component::Lift>::lift(
                                        cx,
                                        ty
                                            .cases[2usize]
                                            .ty
                                            .unwrap_or_else(
                                                wasmtime::component::__internal::bad_type_info,
                                            ),
                                        unsafe { &src.payload.BadParameter },
                                    )?,
                                )
                            }
                            3u32 => {
                                Self::QueryFailed(
                                    <String as wasmtime::component::Lift>::lift(
                                        cx,
                                        ty
                                            .cases[3usize]
                                            .ty
                                            .unwrap_or_else(
                                                wasmtime::component::__internal::bad_type_info,
                                            ),
                                        unsafe { &src.payload.QueryFailed },
                                    )?,
                                )
                            }
                            4u32 => {
                                Self::ValueConversionFailed(
                                    <String as wasmtime::component::Lift>::lift(
                                        cx,
                                        ty
                                            .cases[4usize]
                                            .ty
                                            .unwrap_or_else(
                                                wasmtime::component::__internal::bad_type_info,
                                            ),
                                        unsafe { &src.payload.ValueConversionFailed },
                                    )?,
                                )
                            }
                            5u32 => {
                                Self::OtherError(
                                    <String as wasmtime::component::Lift>::lift(
                                        cx,
                                        ty
                                            .cases[5usize]
                                            .ty
                                            .unwrap_or_else(
                                                wasmtime::component::__internal::bad_type_info,
                                            ),
                                        unsafe { &src.payload.OtherError },
                                    )?,
                                )
                            }
                            discrim => {
                                return ::anyhow::__private::Err(
                                    ::anyhow::Error::msg({
                                        let res = ::alloc::fmt::format(
                                            format_args!("unexpected discriminant: {0}", discrim),
                                        );
                                        res
                                    }),
                                );
                            }
                        },
                    )
                }
                #[inline]
                fn load(
                    cx: &mut wasmtime::component::__internal::LiftContext<'_>,
                    ty: wasmtime::component::__internal::InterfaceType,
                    bytes: &[u8],
                ) -> wasmtime::component::__internal::anyhow::Result<Self> {
                    let align = <Self as wasmtime::component::ComponentType>::ALIGN32;
                    if true {
                        if !((bytes.as_ptr() as usize) % (align as usize) == 0) {
                            ::core::panicking::panic(
                                "assertion failed: (bytes.as_ptr() as usize) % (align as usize) == 0",
                            )
                        }
                    }
                    let discrim = bytes[0];
                    let payload_offset = <Self as wasmtime::component::__internal::ComponentVariant>::PAYLOAD_OFFSET32;
                    let payload = &bytes[payload_offset..];
                    let ty = match ty {
                        wasmtime::component::__internal::InterfaceType::Variant(i) => {
                            &cx.types[i]
                        }
                        _ => wasmtime::component::__internal::bad_type_info(),
                    };
                    Ok(
                        match discrim {
                            0u8 => Self::Success,
                            1u8 => {
                                Self::ConnectionFailed(
                                    <String as wasmtime::component::Lift>::load(
                                        cx,
                                        ty
                                            .cases[1usize]
                                            .ty
                                            .unwrap_or_else(
                                                wasmtime::component::__internal::bad_type_info,
                                            ),
                                        &payload[..<String as wasmtime::component::ComponentType>::SIZE32],
                                    )?,
                                )
                            }
                            2u8 => {
                                Self::BadParameter(
                                    <String as wasmtime::component::Lift>::load(
                                        cx,
                                        ty
                                            .cases[2usize]
                                            .ty
                                            .unwrap_or_else(
                                                wasmtime::component::__internal::bad_type_info,
                                            ),
                                        &payload[..<String as wasmtime::component::ComponentType>::SIZE32],
                                    )?,
                                )
                            }
                            3u8 => {
                                Self::QueryFailed(
                                    <String as wasmtime::component::Lift>::load(
                                        cx,
                                        ty
                                            .cases[3usize]
                                            .ty
                                            .unwrap_or_else(
                                                wasmtime::component::__internal::bad_type_info,
                                            ),
                                        &payload[..<String as wasmtime::component::ComponentType>::SIZE32],
                                    )?,
                                )
                            }
                            4u8 => {
                                Self::ValueConversionFailed(
                                    <String as wasmtime::component::Lift>::load(
                                        cx,
                                        ty
                                            .cases[4usize]
                                            .ty
                                            .unwrap_or_else(
                                                wasmtime::component::__internal::bad_type_info,
                                            ),
                                        &payload[..<String as wasmtime::component::ComponentType>::SIZE32],
                                    )?,
                                )
                            }
                            5u8 => {
                                Self::OtherError(
                                    <String as wasmtime::component::Lift>::load(
                                        cx,
                                        ty
                                            .cases[5usize]
                                            .ty
                                            .unwrap_or_else(
                                                wasmtime::component::__internal::bad_type_info,
                                            ),
                                        &payload[..<String as wasmtime::component::ComponentType>::SIZE32],
                                    )?,
                                )
                            }
                            discrim => {
                                return ::anyhow::__private::Err(
                                    ::anyhow::Error::msg({
                                        let res = ::alloc::fmt::format(
                                            format_args!("unexpected discriminant: {0}", discrim),
                                        );
                                        res
                                    }),
                                );
                            }
                        },
                    )
                }
            }
            const _: () = {
                #[doc(hidden)]
                #[repr(C)]
                pub struct LowerMysqlError<
                    T1: Copy,
                    T2: Copy,
                    T3: Copy,
                    T4: Copy,
                    T5: Copy,
                > {
                    tag: wasmtime::ValRaw,
                    payload: LowerPayloadMysqlError<T1, T2, T3, T4, T5>,
                }
                #[automatically_derived]
                impl<
                    T1: ::core::clone::Clone + Copy,
                    T2: ::core::clone::Clone + Copy,
                    T3: ::core::clone::Clone + Copy,
                    T4: ::core::clone::Clone + Copy,
                    T5: ::core::clone::Clone + Copy,
                > ::core::clone::Clone for LowerMysqlError<T1, T2, T3, T4, T5> {
                    #[inline]
                    fn clone(&self) -> LowerMysqlError<T1, T2, T3, T4, T5> {
                        LowerMysqlError {
                            tag: ::core::clone::Clone::clone(&self.tag),
                            payload: ::core::clone::Clone::clone(&self.payload),
                        }
                    }
                }
                #[automatically_derived]
                impl<
                    T1: ::core::marker::Copy + Copy,
                    T2: ::core::marker::Copy + Copy,
                    T3: ::core::marker::Copy + Copy,
                    T4: ::core::marker::Copy + Copy,
                    T5: ::core::marker::Copy + Copy,
                > ::core::marker::Copy for LowerMysqlError<T1, T2, T3, T4, T5> {}
                #[doc(hidden)]
                #[allow(non_snake_case)]
                #[repr(C)]
                union LowerPayloadMysqlError<
                    T1: Copy,
                    T2: Copy,
                    T3: Copy,
                    T4: Copy,
                    T5: Copy,
                > {
                    Success: [wasmtime::ValRaw; 0],
                    ConnectionFailed: T1,
                    BadParameter: T2,
                    QueryFailed: T3,
                    ValueConversionFailed: T4,
                    OtherError: T5,
                }
                #[automatically_derived]
                #[allow(non_snake_case)]
                impl<
                    T1: ::core::marker::Copy + ::core::clone::Clone + Copy,
                    T2: ::core::marker::Copy + ::core::clone::Clone + Copy,
                    T3: ::core::marker::Copy + ::core::clone::Clone + Copy,
                    T4: ::core::marker::Copy + ::core::clone::Clone + Copy,
                    T5: ::core::marker::Copy + ::core::clone::Clone + Copy,
                > ::core::clone::Clone for LowerPayloadMysqlError<T1, T2, T3, T4, T5> {
                    #[inline]
                    fn clone(&self) -> LowerPayloadMysqlError<T1, T2, T3, T4, T5> {
                        let _: ::core::clone::AssertParamIsCopy<Self>;
                        *self
                    }
                }
                #[automatically_derived]
                #[allow(non_snake_case)]
                impl<
                    T1: ::core::marker::Copy + Copy,
                    T2: ::core::marker::Copy + Copy,
                    T3: ::core::marker::Copy + Copy,
                    T4: ::core::marker::Copy + Copy,
                    T5: ::core::marker::Copy + Copy,
                > ::core::marker::Copy for LowerPayloadMysqlError<T1, T2, T3, T4, T5> {}
                unsafe impl wasmtime::component::ComponentType for MysqlError {
                    type Lower = LowerMysqlError<
                        <String as wasmtime::component::ComponentType>::Lower,
                        <String as wasmtime::component::ComponentType>::Lower,
                        <String as wasmtime::component::ComponentType>::Lower,
                        <String as wasmtime::component::ComponentType>::Lower,
                        <String as wasmtime::component::ComponentType>::Lower,
                    >;
                    #[inline]
                    fn typecheck(
                        ty: &wasmtime::component::__internal::InterfaceType,
                        types: &wasmtime::component::__internal::InstanceType<'_>,
                    ) -> wasmtime::component::__internal::anyhow::Result<()> {
                        wasmtime::component::__internal::typecheck_variant(
                            ty,
                            types,
                            &[
                                ("success", None),
                                (
                                    "connection-failed",
                                    Some(
                                        <String as wasmtime::component::ComponentType>::typecheck,
                                    ),
                                ),
                                (
                                    "bad-parameter",
                                    Some(
                                        <String as wasmtime::component::ComponentType>::typecheck,
                                    ),
                                ),
                                (
                                    "query-failed",
                                    Some(
                                        <String as wasmtime::component::ComponentType>::typecheck,
                                    ),
                                ),
                                (
                                    "value-conversion-failed",
                                    Some(
                                        <String as wasmtime::component::ComponentType>::typecheck,
                                    ),
                                ),
                                (
                                    "other-error",
                                    Some(
                                        <String as wasmtime::component::ComponentType>::typecheck,
                                    ),
                                ),
                            ],
                        )
                    }
                    const ABI: wasmtime::component::__internal::CanonicalAbiInfo = wasmtime::component::__internal::CanonicalAbiInfo::variant_static(
                        &[
                            None,
                            Some(<String as wasmtime::component::ComponentType>::ABI),
                            Some(<String as wasmtime::component::ComponentType>::ABI),
                            Some(<String as wasmtime::component::ComponentType>::ABI),
                            Some(<String as wasmtime::component::ComponentType>::ABI),
                            Some(<String as wasmtime::component::ComponentType>::ABI),
                        ],
                    );
                }
                unsafe impl wasmtime::component::__internal::ComponentVariant
                for MysqlError {
                    const CASES: &'static [Option<
                        wasmtime::component::__internal::CanonicalAbiInfo,
                    >] = &[
                        None,
                        Some(<String as wasmtime::component::ComponentType>::ABI),
                        Some(<String as wasmtime::component::ComponentType>::ABI),
                        Some(<String as wasmtime::component::ComponentType>::ABI),
                        Some(<String as wasmtime::component::ComponentType>::ABI),
                        Some(<String as wasmtime::component::ComponentType>::ABI),
                    ];
                }
            };
            impl core::fmt::Debug for MysqlError {
                fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
                    match self {
                        MysqlError::Success => {
                            f.debug_tuple("MysqlError::Success").finish()
                        }
                        MysqlError::ConnectionFailed(e) => {
                            f.debug_tuple("MysqlError::ConnectionFailed")
                                .field(e)
                                .finish()
                        }
                        MysqlError::BadParameter(e) => {
                            f.debug_tuple("MysqlError::BadParameter").field(e).finish()
                        }
                        MysqlError::QueryFailed(e) => {
                            f.debug_tuple("MysqlError::QueryFailed").field(e).finish()
                        }
                        MysqlError::ValueConversionFailed(e) => {
                            f.debug_tuple("MysqlError::ValueConversionFailed")
                                .field(e)
                                .finish()
                        }
                        MysqlError::OtherError(e) => {
                            f.debug_tuple("MysqlError::OtherError").field(e).finish()
                        }
                    }
                }
            }
            impl core::fmt::Display for MysqlError {
                fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
                    f.write_fmt(format_args!("{0:?}", self))
                }
            }
            impl std::error::Error for MysqlError {}
            const _: () = {
                if !(12 == <MysqlError as wasmtime::component::ComponentType>::SIZE32) {
                    ::core::panicking::panic(
                        "assertion failed: 12 == <MysqlError as wasmtime::component::ComponentType>::SIZE32",
                    )
                }
                if !(4 == <MysqlError as wasmtime::component::ComponentType>::ALIGN32) {
                    ::core::panicking::panic(
                        "assertion failed: 4 == <MysqlError as wasmtime::component::ComponentType>::ALIGN32",
                    )
                }
            };
            pub trait Host {
                #[must_use]
                #[allow(clippy::type_complexity, clippy::type_repetition_in_bounds)]
                fn query<'life0, 'async_trait>(
                    &'life0 mut self,
                    address: String,
                    statement: String,
                    params: Vec<ParameterValue>,
                ) -> ::core::pin::Pin<
                    Box<
                        dyn ::core::future::Future<
                            Output = wasmtime::Result<Result<RowSet, MysqlError>>,
                        > + ::core::marker::Send + 'async_trait,
                    >,
                >
                where
                    'life0: 'async_trait,
                    Self: 'async_trait;
                #[must_use]
                #[allow(clippy::type_complexity, clippy::type_repetition_in_bounds)]
                fn execute<'life0, 'async_trait>(
                    &'life0 mut self,
                    address: String,
                    statement: String,
                    params: Vec<ParameterValue>,
                ) -> ::core::pin::Pin<
                    Box<
                        dyn ::core::future::Future<
                            Output = wasmtime::Result<Result<(), MysqlError>>,
                        > + ::core::marker::Send + 'async_trait,
                    >,
                >
                where
                    'life0: 'async_trait,
                    Self: 'async_trait;
            }
            pub fn add_to_linker<T, U>(
                linker: &mut wasmtime::component::Linker<T>,
                get: impl Fn(&mut T) -> &mut U + Send + Sync + Copy + 'static,
            ) -> wasmtime::Result<()>
            where
                T: Send,
                U: Host + Send,
            {
                let mut inst = linker.instance("fermyon:spin/mysql")?;
                inst.func_wrap_async(
                    "query",
                    move |
                        mut caller: wasmtime::StoreContextMut<'_, T>,
                        (arg0, arg1, arg2): (String, String, Vec<ParameterValue>)|
                    Box::new(async move {
                        let host = get(caller.data_mut());
                        let r = Host::query(host, arg0, arg1, arg2).await;
                        Ok((r?,))
                    }),
                )?;
                inst.func_wrap_async(
                    "execute",
                    move |
                        mut caller: wasmtime::StoreContextMut<'_, T>,
                        (arg0, arg1, arg2): (String, String, Vec<ParameterValue>)|
                    Box::new(async move {
                        let host = get(caller.data_mut());
                        let r = Host::execute(host, arg0, arg1, arg2).await;
                        Ok((r?,))
                    }),
                )?;
                Ok(())
            }
        }
        #[allow(clippy::all)]
        pub mod sqlite {
            #[allow(unused_imports)]
            use wasmtime::component::__internal::anyhow;
            pub type Connection = u32;
            const _: () = {
                if !(4 == <Connection as wasmtime::component::ComponentType>::SIZE32) {
                    ::core::panicking::panic(
                        "assertion failed: 4 == <Connection as wasmtime::component::ComponentType>::SIZE32",
                    )
                }
                if !(4 == <Connection as wasmtime::component::ComponentType>::ALIGN32) {
                    ::core::panicking::panic(
                        "assertion failed: 4 == <Connection as wasmtime::component::ComponentType>::ALIGN32",
                    )
                }
            };
            #[component(variant)]
            pub enum Error {
                #[component(name = "no-such-database")]
                NoSuchDatabase,
                #[component(name = "access-denied")]
                AccessDenied,
                #[component(name = "invalid-connection")]
                InvalidConnection,
                #[component(name = "database-full")]
                DatabaseFull,
                #[component(name = "io")]
                Io(String),
            }
            #[automatically_derived]
            impl ::core::clone::Clone for Error {
                #[inline]
                fn clone(&self) -> Error {
                    match self {
                        Error::NoSuchDatabase => Error::NoSuchDatabase,
                        Error::AccessDenied => Error::AccessDenied,
                        Error::InvalidConnection => Error::InvalidConnection,
                        Error::DatabaseFull => Error::DatabaseFull,
                        Error::Io(__self_0) => {
                            Error::Io(::core::clone::Clone::clone(__self_0))
                        }
                    }
                }
            }
            unsafe impl wasmtime::component::Lower for Error {
                #[inline]
                fn lower<T>(
                    &self,
                    cx: &mut wasmtime::component::__internal::LowerContext<'_, T>,
                    ty: wasmtime::component::__internal::InterfaceType,
                    dst: &mut std::mem::MaybeUninit<Self::Lower>,
                ) -> wasmtime::component::__internal::anyhow::Result<()> {
                    let ty = match ty {
                        wasmtime::component::__internal::InterfaceType::Variant(i) => {
                            &cx.types[i]
                        }
                        _ => wasmtime::component::__internal::bad_type_info(),
                    };
                    match self {
                        Self::NoSuchDatabase => {
                            {
                                #[allow(unused_unsafe)]
                                {
                                    unsafe {
                                        use ::wasmtime::component::__internal::MaybeUninitExt;
                                        let m: &mut std::mem::MaybeUninit<_> = dst;
                                        m.map(|p| &raw mut (*p).tag)
                                    }
                                }
                            }
                                .write(wasmtime::ValRaw::u32(0u32));
                            unsafe {
                                wasmtime::component::__internal::lower_payload(
                                    {
                                        #[allow(unused_unsafe)]
                                        {
                                            unsafe {
                                                use ::wasmtime::component::__internal::MaybeUninitExt;
                                                let m: &mut std::mem::MaybeUninit<_> = dst;
                                                m.map(|p| &raw mut (*p).payload)
                                            }
                                        }
                                    },
                                    |payload| {
                                        #[allow(unused_unsafe)]
                                        {
                                            unsafe {
                                                use ::wasmtime::component::__internal::MaybeUninitExt;
                                                let m: &mut std::mem::MaybeUninit<_> = payload;
                                                m.map(|p| &raw mut (*p).NoSuchDatabase)
                                            }
                                        }
                                    },
                                    |dst| Ok(()),
                                )
                            }
                        }
                        Self::AccessDenied => {
                            {
                                #[allow(unused_unsafe)]
                                {
                                    unsafe {
                                        use ::wasmtime::component::__internal::MaybeUninitExt;
                                        let m: &mut std::mem::MaybeUninit<_> = dst;
                                        m.map(|p| &raw mut (*p).tag)
                                    }
                                }
                            }
                                .write(wasmtime::ValRaw::u32(1u32));
                            unsafe {
                                wasmtime::component::__internal::lower_payload(
                                    {
                                        #[allow(unused_unsafe)]
                                        {
                                            unsafe {
                                                use ::wasmtime::component::__internal::MaybeUninitExt;
                                                let m: &mut std::mem::MaybeUninit<_> = dst;
                                                m.map(|p| &raw mut (*p).payload)
                                            }
                                        }
                                    },
                                    |payload| {
                                        #[allow(unused_unsafe)]
                                        {
                                            unsafe {
                                                use ::wasmtime::component::__internal::MaybeUninitExt;
                                                let m: &mut std::mem::MaybeUninit<_> = payload;
                                                m.map(|p| &raw mut (*p).AccessDenied)
                                            }
                                        }
                                    },
                                    |dst| Ok(()),
                                )
                            }
                        }
                        Self::InvalidConnection => {
                            {
                                #[allow(unused_unsafe)]
                                {
                                    unsafe {
                                        use ::wasmtime::component::__internal::MaybeUninitExt;
                                        let m: &mut std::mem::MaybeUninit<_> = dst;
                                        m.map(|p| &raw mut (*p).tag)
                                    }
                                }
                            }
                                .write(wasmtime::ValRaw::u32(2u32));
                            unsafe {
                                wasmtime::component::__internal::lower_payload(
                                    {
                                        #[allow(unused_unsafe)]
                                        {
                                            unsafe {
                                                use ::wasmtime::component::__internal::MaybeUninitExt;
                                                let m: &mut std::mem::MaybeUninit<_> = dst;
                                                m.map(|p| &raw mut (*p).payload)
                                            }
                                        }
                                    },
                                    |payload| {
                                        #[allow(unused_unsafe)]
                                        {
                                            unsafe {
                                                use ::wasmtime::component::__internal::MaybeUninitExt;
                                                let m: &mut std::mem::MaybeUninit<_> = payload;
                                                m.map(|p| &raw mut (*p).InvalidConnection)
                                            }
                                        }
                                    },
                                    |dst| Ok(()),
                                )
                            }
                        }
                        Self::DatabaseFull => {
                            {
                                #[allow(unused_unsafe)]
                                {
                                    unsafe {
                                        use ::wasmtime::component::__internal::MaybeUninitExt;
                                        let m: &mut std::mem::MaybeUninit<_> = dst;
                                        m.map(|p| &raw mut (*p).tag)
                                    }
                                }
                            }
                                .write(wasmtime::ValRaw::u32(3u32));
                            unsafe {
                                wasmtime::component::__internal::lower_payload(
                                    {
                                        #[allow(unused_unsafe)]
                                        {
                                            unsafe {
                                                use ::wasmtime::component::__internal::MaybeUninitExt;
                                                let m: &mut std::mem::MaybeUninit<_> = dst;
                                                m.map(|p| &raw mut (*p).payload)
                                            }
                                        }
                                    },
                                    |payload| {
                                        #[allow(unused_unsafe)]
                                        {
                                            unsafe {
                                                use ::wasmtime::component::__internal::MaybeUninitExt;
                                                let m: &mut std::mem::MaybeUninit<_> = payload;
                                                m.map(|p| &raw mut (*p).DatabaseFull)
                                            }
                                        }
                                    },
                                    |dst| Ok(()),
                                )
                            }
                        }
                        Self::Io(value) => {
                            {
                                #[allow(unused_unsafe)]
                                {
                                    unsafe {
                                        use ::wasmtime::component::__internal::MaybeUninitExt;
                                        let m: &mut std::mem::MaybeUninit<_> = dst;
                                        m.map(|p| &raw mut (*p).tag)
                                    }
                                }
                            }
                                .write(wasmtime::ValRaw::u32(4u32));
                            unsafe {
                                wasmtime::component::__internal::lower_payload(
                                    {
                                        #[allow(unused_unsafe)]
                                        {
                                            unsafe {
                                                use ::wasmtime::component::__internal::MaybeUninitExt;
                                                let m: &mut std::mem::MaybeUninit<_> = dst;
                                                m.map(|p| &raw mut (*p).payload)
                                            }
                                        }
                                    },
                                    |payload| {
                                        #[allow(unused_unsafe)]
                                        {
                                            unsafe {
                                                use ::wasmtime::component::__internal::MaybeUninitExt;
                                                let m: &mut std::mem::MaybeUninit<_> = payload;
                                                m.map(|p| &raw mut (*p).Io)
                                            }
                                        }
                                    },
                                    |dst| {
                                        value
                                            .lower(
                                                cx,
                                                ty
                                                    .cases[4usize]
                                                    .ty
                                                    .unwrap_or_else(
                                                        wasmtime::component::__internal::bad_type_info,
                                                    ),
                                                dst,
                                            )
                                    },
                                )
                            }
                        }
                    }
                }
                #[inline]
                fn store<T>(
                    &self,
                    cx: &mut wasmtime::component::__internal::LowerContext<'_, T>,
                    ty: wasmtime::component::__internal::InterfaceType,
                    mut offset: usize,
                ) -> wasmtime::component::__internal::anyhow::Result<()> {
                    let ty = match ty {
                        wasmtime::component::__internal::InterfaceType::Variant(i) => {
                            &cx.types[i]
                        }
                        _ => wasmtime::component::__internal::bad_type_info(),
                    };
                    if true {
                        if !(offset
                            % (<Self as wasmtime::component::ComponentType>::ALIGN32
                                as usize) == 0)
                        {
                            ::core::panicking::panic(
                                "assertion failed: offset % (<Self as wasmtime::component::ComponentType>::ALIGN32 as usize) == 0",
                            )
                        }
                    }
                    match self {
                        Self::NoSuchDatabase => {
                            *cx.get::<1usize>(offset) = 0u8.to_le_bytes();
                            Ok(())
                        }
                        Self::AccessDenied => {
                            *cx.get::<1usize>(offset) = 1u8.to_le_bytes();
                            Ok(())
                        }
                        Self::InvalidConnection => {
                            *cx.get::<1usize>(offset) = 2u8.to_le_bytes();
                            Ok(())
                        }
                        Self::DatabaseFull => {
                            *cx.get::<1usize>(offset) = 3u8.to_le_bytes();
                            Ok(())
                        }
                        Self::Io(value) => {
                            *cx.get::<1usize>(offset) = 4u8.to_le_bytes();
                            value
                                .store(
                                    cx,
                                    ty
                                        .cases[4usize]
                                        .ty
                                        .unwrap_or_else(
                                            wasmtime::component::__internal::bad_type_info,
                                        ),
                                    offset
                                        + <Self as wasmtime::component::__internal::ComponentVariant>::PAYLOAD_OFFSET32,
                                )
                        }
                    }
                }
            }
            unsafe impl wasmtime::component::Lift for Error {
                #[inline]
                fn lift(
                    cx: &mut wasmtime::component::__internal::LiftContext<'_>,
                    ty: wasmtime::component::__internal::InterfaceType,
                    src: &Self::Lower,
                ) -> wasmtime::component::__internal::anyhow::Result<Self> {
                    let ty = match ty {
                        wasmtime::component::__internal::InterfaceType::Variant(i) => {
                            &cx.types[i]
                        }
                        _ => wasmtime::component::__internal::bad_type_info(),
                    };
                    Ok(
                        match src.tag.get_u32() {
                            0u32 => Self::NoSuchDatabase,
                            1u32 => Self::AccessDenied,
                            2u32 => Self::InvalidConnection,
                            3u32 => Self::DatabaseFull,
                            4u32 => {
                                Self::Io(
                                    <String as wasmtime::component::Lift>::lift(
                                        cx,
                                        ty
                                            .cases[4usize]
                                            .ty
                                            .unwrap_or_else(
                                                wasmtime::component::__internal::bad_type_info,
                                            ),
                                        unsafe { &src.payload.Io },
                                    )?,
                                )
                            }
                            discrim => {
                                return ::anyhow::__private::Err(
                                    ::anyhow::Error::msg({
                                        let res = ::alloc::fmt::format(
                                            format_args!("unexpected discriminant: {0}", discrim),
                                        );
                                        res
                                    }),
                                );
                            }
                        },
                    )
                }
                #[inline]
                fn load(
                    cx: &mut wasmtime::component::__internal::LiftContext<'_>,
                    ty: wasmtime::component::__internal::InterfaceType,
                    bytes: &[u8],
                ) -> wasmtime::component::__internal::anyhow::Result<Self> {
                    let align = <Self as wasmtime::component::ComponentType>::ALIGN32;
                    if true {
                        if !((bytes.as_ptr() as usize) % (align as usize) == 0) {
                            ::core::panicking::panic(
                                "assertion failed: (bytes.as_ptr() as usize) % (align as usize) == 0",
                            )
                        }
                    }
                    let discrim = bytes[0];
                    let payload_offset = <Self as wasmtime::component::__internal::ComponentVariant>::PAYLOAD_OFFSET32;
                    let payload = &bytes[payload_offset..];
                    let ty = match ty {
                        wasmtime::component::__internal::InterfaceType::Variant(i) => {
                            &cx.types[i]
                        }
                        _ => wasmtime::component::__internal::bad_type_info(),
                    };
                    Ok(
                        match discrim {
                            0u8 => Self::NoSuchDatabase,
                            1u8 => Self::AccessDenied,
                            2u8 => Self::InvalidConnection,
                            3u8 => Self::DatabaseFull,
                            4u8 => {
                                Self::Io(
                                    <String as wasmtime::component::Lift>::load(
                                        cx,
                                        ty
                                            .cases[4usize]
                                            .ty
                                            .unwrap_or_else(
                                                wasmtime::component::__internal::bad_type_info,
                                            ),
                                        &payload[..<String as wasmtime::component::ComponentType>::SIZE32],
                                    )?,
                                )
                            }
                            discrim => {
                                return ::anyhow::__private::Err(
                                    ::anyhow::Error::msg({
                                        let res = ::alloc::fmt::format(
                                            format_args!("unexpected discriminant: {0}", discrim),
                                        );
                                        res
                                    }),
                                );
                            }
                        },
                    )
                }
            }
            const _: () = {
                #[doc(hidden)]
                #[repr(C)]
                pub struct LowerError<T4: Copy> {
                    tag: wasmtime::ValRaw,
                    payload: LowerPayloadError<T4>,
                }
                #[automatically_derived]
                impl<T4: ::core::clone::Clone + Copy> ::core::clone::Clone
                for LowerError<T4> {
                    #[inline]
                    fn clone(&self) -> LowerError<T4> {
                        LowerError {
                            tag: ::core::clone::Clone::clone(&self.tag),
                            payload: ::core::clone::Clone::clone(&self.payload),
                        }
                    }
                }
                #[automatically_derived]
                impl<T4: ::core::marker::Copy + Copy> ::core::marker::Copy
                for LowerError<T4> {}
                #[doc(hidden)]
                #[allow(non_snake_case)]
                #[repr(C)]
                union LowerPayloadError<T4: Copy> {
                    NoSuchDatabase: [wasmtime::ValRaw; 0],
                    AccessDenied: [wasmtime::ValRaw; 0],
                    InvalidConnection: [wasmtime::ValRaw; 0],
                    DatabaseFull: [wasmtime::ValRaw; 0],
                    Io: T4,
                }
                #[automatically_derived]
                #[allow(non_snake_case)]
                impl<
                    T4: ::core::marker::Copy + ::core::clone::Clone + Copy,
                > ::core::clone::Clone for LowerPayloadError<T4> {
                    #[inline]
                    fn clone(&self) -> LowerPayloadError<T4> {
                        let _: ::core::clone::AssertParamIsCopy<Self>;
                        *self
                    }
                }
                #[automatically_derived]
                #[allow(non_snake_case)]
                impl<T4: ::core::marker::Copy + Copy> ::core::marker::Copy
                for LowerPayloadError<T4> {}
                unsafe impl wasmtime::component::ComponentType for Error {
                    type Lower = LowerError<
                        <String as wasmtime::component::ComponentType>::Lower,
                    >;
                    #[inline]
                    fn typecheck(
                        ty: &wasmtime::component::__internal::InterfaceType,
                        types: &wasmtime::component::__internal::InstanceType<'_>,
                    ) -> wasmtime::component::__internal::anyhow::Result<()> {
                        wasmtime::component::__internal::typecheck_variant(
                            ty,
                            types,
                            &[
                                ("no-such-database", None),
                                ("access-denied", None),
                                ("invalid-connection", None),
                                ("database-full", None),
                                (
                                    "io",
                                    Some(
                                        <String as wasmtime::component::ComponentType>::typecheck,
                                    ),
                                ),
                            ],
                        )
                    }
                    const ABI: wasmtime::component::__internal::CanonicalAbiInfo = wasmtime::component::__internal::CanonicalAbiInfo::variant_static(
                        &[
                            None,
                            None,
                            None,
                            None,
                            Some(<String as wasmtime::component::ComponentType>::ABI),
                        ],
                    );
                }
                unsafe impl wasmtime::component::__internal::ComponentVariant for Error {
                    const CASES: &'static [Option<
                        wasmtime::component::__internal::CanonicalAbiInfo,
                    >] = &[
                        None,
                        None,
                        None,
                        None,
                        Some(<String as wasmtime::component::ComponentType>::ABI),
                    ];
                }
            };
            impl core::fmt::Debug for Error {
                fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
                    match self {
                        Error::NoSuchDatabase => {
                            f.debug_tuple("Error::NoSuchDatabase").finish()
                        }
                        Error::AccessDenied => {
                            f.debug_tuple("Error::AccessDenied").finish()
                        }
                        Error::InvalidConnection => {
                            f.debug_tuple("Error::InvalidConnection").finish()
                        }
                        Error::DatabaseFull => {
                            f.debug_tuple("Error::DatabaseFull").finish()
                        }
                        Error::Io(e) => f.debug_tuple("Error::Io").field(e).finish(),
                    }
                }
            }
            impl core::fmt::Display for Error {
                fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
                    f.write_fmt(format_args!("{0:?}", self))
                }
            }
            impl std::error::Error for Error {}
            const _: () = {
                if !(12 == <Error as wasmtime::component::ComponentType>::SIZE32) {
                    ::core::panicking::panic(
                        "assertion failed: 12 == <Error as wasmtime::component::ComponentType>::SIZE32",
                    )
                }
                if !(4 == <Error as wasmtime::component::ComponentType>::ALIGN32) {
                    ::core::panicking::panic(
                        "assertion failed: 4 == <Error as wasmtime::component::ComponentType>::ALIGN32",
                    )
                }
            };
            #[component(variant)]
            pub enum Value {
                #[component(name = "integer")]
                Integer(i64),
                #[component(name = "real")]
                Real(f64),
                #[component(name = "text")]
                Text(String),
                #[component(name = "blob")]
                Blob(Vec<u8>),
                #[component(name = "null")]
                Null,
            }
            #[automatically_derived]
            impl ::core::clone::Clone for Value {
                #[inline]
                fn clone(&self) -> Value {
                    match self {
                        Value::Integer(__self_0) => {
                            Value::Integer(::core::clone::Clone::clone(__self_0))
                        }
                        Value::Real(__self_0) => {
                            Value::Real(::core::clone::Clone::clone(__self_0))
                        }
                        Value::Text(__self_0) => {
                            Value::Text(::core::clone::Clone::clone(__self_0))
                        }
                        Value::Blob(__self_0) => {
                            Value::Blob(::core::clone::Clone::clone(__self_0))
                        }
                        Value::Null => Value::Null,
                    }
                }
            }
            unsafe impl wasmtime::component::Lower for Value {
                #[inline]
                fn lower<T>(
                    &self,
                    cx: &mut wasmtime::component::__internal::LowerContext<'_, T>,
                    ty: wasmtime::component::__internal::InterfaceType,
                    dst: &mut std::mem::MaybeUninit<Self::Lower>,
                ) -> wasmtime::component::__internal::anyhow::Result<()> {
                    let ty = match ty {
                        wasmtime::component::__internal::InterfaceType::Variant(i) => {
                            &cx.types[i]
                        }
                        _ => wasmtime::component::__internal::bad_type_info(),
                    };
                    match self {
                        Self::Integer(value) => {
                            {
                                #[allow(unused_unsafe)]
                                {
                                    unsafe {
                                        use ::wasmtime::component::__internal::MaybeUninitExt;
                                        let m: &mut std::mem::MaybeUninit<_> = dst;
                                        m.map(|p| &raw mut (*p).tag)
                                    }
                                }
                            }
                                .write(wasmtime::ValRaw::u32(0u32));
                            unsafe {
                                wasmtime::component::__internal::lower_payload(
                                    {
                                        #[allow(unused_unsafe)]
                                        {
                                            unsafe {
                                                use ::wasmtime::component::__internal::MaybeUninitExt;
                                                let m: &mut std::mem::MaybeUninit<_> = dst;
                                                m.map(|p| &raw mut (*p).payload)
                                            }
                                        }
                                    },
                                    |payload| {
                                        #[allow(unused_unsafe)]
                                        {
                                            unsafe {
                                                use ::wasmtime::component::__internal::MaybeUninitExt;
                                                let m: &mut std::mem::MaybeUninit<_> = payload;
                                                m.map(|p| &raw mut (*p).Integer)
                                            }
                                        }
                                    },
                                    |dst| {
                                        value
                                            .lower(
                                                cx,
                                                ty
                                                    .cases[0usize]
                                                    .ty
                                                    .unwrap_or_else(
                                                        wasmtime::component::__internal::bad_type_info,
                                                    ),
                                                dst,
                                            )
                                    },
                                )
                            }
                        }
                        Self::Real(value) => {
                            {
                                #[allow(unused_unsafe)]
                                {
                                    unsafe {
                                        use ::wasmtime::component::__internal::MaybeUninitExt;
                                        let m: &mut std::mem::MaybeUninit<_> = dst;
                                        m.map(|p| &raw mut (*p).tag)
                                    }
                                }
                            }
                                .write(wasmtime::ValRaw::u32(1u32));
                            unsafe {
                                wasmtime::component::__internal::lower_payload(
                                    {
                                        #[allow(unused_unsafe)]
                                        {
                                            unsafe {
                                                use ::wasmtime::component::__internal::MaybeUninitExt;
                                                let m: &mut std::mem::MaybeUninit<_> = dst;
                                                m.map(|p| &raw mut (*p).payload)
                                            }
                                        }
                                    },
                                    |payload| {
                                        #[allow(unused_unsafe)]
                                        {
                                            unsafe {
                                                use ::wasmtime::component::__internal::MaybeUninitExt;
                                                let m: &mut std::mem::MaybeUninit<_> = payload;
                                                m.map(|p| &raw mut (*p).Real)
                                            }
                                        }
                                    },
                                    |dst| {
                                        value
                                            .lower(
                                                cx,
                                                ty
                                                    .cases[1usize]
                                                    .ty
                                                    .unwrap_or_else(
                                                        wasmtime::component::__internal::bad_type_info,
                                                    ),
                                                dst,
                                            )
                                    },
                                )
                            }
                        }
                        Self::Text(value) => {
                            {
                                #[allow(unused_unsafe)]
                                {
                                    unsafe {
                                        use ::wasmtime::component::__internal::MaybeUninitExt;
                                        let m: &mut std::mem::MaybeUninit<_> = dst;
                                        m.map(|p| &raw mut (*p).tag)
                                    }
                                }
                            }
                                .write(wasmtime::ValRaw::u32(2u32));
                            unsafe {
                                wasmtime::component::__internal::lower_payload(
                                    {
                                        #[allow(unused_unsafe)]
                                        {
                                            unsafe {
                                                use ::wasmtime::component::__internal::MaybeUninitExt;
                                                let m: &mut std::mem::MaybeUninit<_> = dst;
                                                m.map(|p| &raw mut (*p).payload)
                                            }
                                        }
                                    },
                                    |payload| {
                                        #[allow(unused_unsafe)]
                                        {
                                            unsafe {
                                                use ::wasmtime::component::__internal::MaybeUninitExt;
                                                let m: &mut std::mem::MaybeUninit<_> = payload;
                                                m.map(|p| &raw mut (*p).Text)
                                            }
                                        }
                                    },
                                    |dst| {
                                        value
                                            .lower(
                                                cx,
                                                ty
                                                    .cases[2usize]
                                                    .ty
                                                    .unwrap_or_else(
                                                        wasmtime::component::__internal::bad_type_info,
                                                    ),
                                                dst,
                                            )
                                    },
                                )
                            }
                        }
                        Self::Blob(value) => {
                            {
                                #[allow(unused_unsafe)]
                                {
                                    unsafe {
                                        use ::wasmtime::component::__internal::MaybeUninitExt;
                                        let m: &mut std::mem::MaybeUninit<_> = dst;
                                        m.map(|p| &raw mut (*p).tag)
                                    }
                                }
                            }
                                .write(wasmtime::ValRaw::u32(3u32));
                            unsafe {
                                wasmtime::component::__internal::lower_payload(
                                    {
                                        #[allow(unused_unsafe)]
                                        {
                                            unsafe {
                                                use ::wasmtime::component::__internal::MaybeUninitExt;
                                                let m: &mut std::mem::MaybeUninit<_> = dst;
                                                m.map(|p| &raw mut (*p).payload)
                                            }
                                        }
                                    },
                                    |payload| {
                                        #[allow(unused_unsafe)]
                                        {
                                            unsafe {
                                                use ::wasmtime::component::__internal::MaybeUninitExt;
                                                let m: &mut std::mem::MaybeUninit<_> = payload;
                                                m.map(|p| &raw mut (*p).Blob)
                                            }
                                        }
                                    },
                                    |dst| {
                                        value
                                            .lower(
                                                cx,
                                                ty
                                                    .cases[3usize]
                                                    .ty
                                                    .unwrap_or_else(
                                                        wasmtime::component::__internal::bad_type_info,
                                                    ),
                                                dst,
                                            )
                                    },
                                )
                            }
                        }
                        Self::Null => {
                            {
                                #[allow(unused_unsafe)]
                                {
                                    unsafe {
                                        use ::wasmtime::component::__internal::MaybeUninitExt;
                                        let m: &mut std::mem::MaybeUninit<_> = dst;
                                        m.map(|p| &raw mut (*p).tag)
                                    }
                                }
                            }
                                .write(wasmtime::ValRaw::u32(4u32));
                            unsafe {
                                wasmtime::component::__internal::lower_payload(
                                    {
                                        #[allow(unused_unsafe)]
                                        {
                                            unsafe {
                                                use ::wasmtime::component::__internal::MaybeUninitExt;
                                                let m: &mut std::mem::MaybeUninit<_> = dst;
                                                m.map(|p| &raw mut (*p).payload)
                                            }
                                        }
                                    },
                                    |payload| {
                                        #[allow(unused_unsafe)]
                                        {
                                            unsafe {
                                                use ::wasmtime::component::__internal::MaybeUninitExt;
                                                let m: &mut std::mem::MaybeUninit<_> = payload;
                                                m.map(|p| &raw mut (*p).Null)
                                            }
                                        }
                                    },
                                    |dst| Ok(()),
                                )
                            }
                        }
                    }
                }
                #[inline]
                fn store<T>(
                    &self,
                    cx: &mut wasmtime::component::__internal::LowerContext<'_, T>,
                    ty: wasmtime::component::__internal::InterfaceType,
                    mut offset: usize,
                ) -> wasmtime::component::__internal::anyhow::Result<()> {
                    let ty = match ty {
                        wasmtime::component::__internal::InterfaceType::Variant(i) => {
                            &cx.types[i]
                        }
                        _ => wasmtime::component::__internal::bad_type_info(),
                    };
                    if true {
                        if !(offset
                            % (<Self as wasmtime::component::ComponentType>::ALIGN32
                                as usize) == 0)
                        {
                            ::core::panicking::panic(
                                "assertion failed: offset % (<Self as wasmtime::component::ComponentType>::ALIGN32 as usize) == 0",
                            )
                        }
                    }
                    match self {
                        Self::Integer(value) => {
                            *cx.get::<1usize>(offset) = 0u8.to_le_bytes();
                            value
                                .store(
                                    cx,
                                    ty
                                        .cases[0usize]
                                        .ty
                                        .unwrap_or_else(
                                            wasmtime::component::__internal::bad_type_info,
                                        ),
                                    offset
                                        + <Self as wasmtime::component::__internal::ComponentVariant>::PAYLOAD_OFFSET32,
                                )
                        }
                        Self::Real(value) => {
                            *cx.get::<1usize>(offset) = 1u8.to_le_bytes();
                            value
                                .store(
                                    cx,
                                    ty
                                        .cases[1usize]
                                        .ty
                                        .unwrap_or_else(
                                            wasmtime::component::__internal::bad_type_info,
                                        ),
                                    offset
                                        + <Self as wasmtime::component::__internal::ComponentVariant>::PAYLOAD_OFFSET32,
                                )
                        }
                        Self::Text(value) => {
                            *cx.get::<1usize>(offset) = 2u8.to_le_bytes();
                            value
                                .store(
                                    cx,
                                    ty
                                        .cases[2usize]
                                        .ty
                                        .unwrap_or_else(
                                            wasmtime::component::__internal::bad_type_info,
                                        ),
                                    offset
                                        + <Self as wasmtime::component::__internal::ComponentVariant>::PAYLOAD_OFFSET32,
                                )
                        }
                        Self::Blob(value) => {
                            *cx.get::<1usize>(offset) = 3u8.to_le_bytes();
                            value
                                .store(
                                    cx,
                                    ty
                                        .cases[3usize]
                                        .ty
                                        .unwrap_or_else(
                                            wasmtime::component::__internal::bad_type_info,
                                        ),
                                    offset
                                        + <Self as wasmtime::component::__internal::ComponentVariant>::PAYLOAD_OFFSET32,
                                )
                        }
                        Self::Null => {
                            *cx.get::<1usize>(offset) = 4u8.to_le_bytes();
                            Ok(())
                        }
                    }
                }
            }
            unsafe impl wasmtime::component::Lift for Value {
                #[inline]
                fn lift(
                    cx: &mut wasmtime::component::__internal::LiftContext<'_>,
                    ty: wasmtime::component::__internal::InterfaceType,
                    src: &Self::Lower,
                ) -> wasmtime::component::__internal::anyhow::Result<Self> {
                    let ty = match ty {
                        wasmtime::component::__internal::InterfaceType::Variant(i) => {
                            &cx.types[i]
                        }
                        _ => wasmtime::component::__internal::bad_type_info(),
                    };
                    Ok(
                        match src.tag.get_u32() {
                            0u32 => {
                                Self::Integer(
                                    <i64 as wasmtime::component::Lift>::lift(
                                        cx,
                                        ty
                                            .cases[0usize]
                                            .ty
                                            .unwrap_or_else(
                                                wasmtime::component::__internal::bad_type_info,
                                            ),
                                        unsafe { &src.payload.Integer },
                                    )?,
                                )
                            }
                            1u32 => {
                                Self::Real(
                                    <f64 as wasmtime::component::Lift>::lift(
                                        cx,
                                        ty
                                            .cases[1usize]
                                            .ty
                                            .unwrap_or_else(
                                                wasmtime::component::__internal::bad_type_info,
                                            ),
                                        unsafe { &src.payload.Real },
                                    )?,
                                )
                            }
                            2u32 => {
                                Self::Text(
                                    <String as wasmtime::component::Lift>::lift(
                                        cx,
                                        ty
                                            .cases[2usize]
                                            .ty
                                            .unwrap_or_else(
                                                wasmtime::component::__internal::bad_type_info,
                                            ),
                                        unsafe { &src.payload.Text },
                                    )?,
                                )
                            }
                            3u32 => {
                                Self::Blob(
                                    <Vec<
                                        u8,
                                    > as wasmtime::component::Lift>::lift(
                                        cx,
                                        ty
                                            .cases[3usize]
                                            .ty
                                            .unwrap_or_else(
                                                wasmtime::component::__internal::bad_type_info,
                                            ),
                                        unsafe { &src.payload.Blob },
                                    )?,
                                )
                            }
                            4u32 => Self::Null,
                            discrim => {
                                return ::anyhow::__private::Err(
                                    ::anyhow::Error::msg({
                                        let res = ::alloc::fmt::format(
                                            format_args!("unexpected discriminant: {0}", discrim),
                                        );
                                        res
                                    }),
                                );
                            }
                        },
                    )
                }
                #[inline]
                fn load(
                    cx: &mut wasmtime::component::__internal::LiftContext<'_>,
                    ty: wasmtime::component::__internal::InterfaceType,
                    bytes: &[u8],
                ) -> wasmtime::component::__internal::anyhow::Result<Self> {
                    let align = <Self as wasmtime::component::ComponentType>::ALIGN32;
                    if true {
                        if !((bytes.as_ptr() as usize) % (align as usize) == 0) {
                            ::core::panicking::panic(
                                "assertion failed: (bytes.as_ptr() as usize) % (align as usize) == 0",
                            )
                        }
                    }
                    let discrim = bytes[0];
                    let payload_offset = <Self as wasmtime::component::__internal::ComponentVariant>::PAYLOAD_OFFSET32;
                    let payload = &bytes[payload_offset..];
                    let ty = match ty {
                        wasmtime::component::__internal::InterfaceType::Variant(i) => {
                            &cx.types[i]
                        }
                        _ => wasmtime::component::__internal::bad_type_info(),
                    };
                    Ok(
                        match discrim {
                            0u8 => {
                                Self::Integer(
                                    <i64 as wasmtime::component::Lift>::load(
                                        cx,
                                        ty
                                            .cases[0usize]
                                            .ty
                                            .unwrap_or_else(
                                                wasmtime::component::__internal::bad_type_info,
                                            ),
                                        &payload[..<i64 as wasmtime::component::ComponentType>::SIZE32],
                                    )?,
                                )
                            }
                            1u8 => {
                                Self::Real(
                                    <f64 as wasmtime::component::Lift>::load(
                                        cx,
                                        ty
                                            .cases[1usize]
                                            .ty
                                            .unwrap_or_else(
                                                wasmtime::component::__internal::bad_type_info,
                                            ),
                                        &payload[..<f64 as wasmtime::component::ComponentType>::SIZE32],
                                    )?,
                                )
                            }
                            2u8 => {
                                Self::Text(
                                    <String as wasmtime::component::Lift>::load(
                                        cx,
                                        ty
                                            .cases[2usize]
                                            .ty
                                            .unwrap_or_else(
                                                wasmtime::component::__internal::bad_type_info,
                                            ),
                                        &payload[..<String as wasmtime::component::ComponentType>::SIZE32],
                                    )?,
                                )
                            }
                            3u8 => {
                                Self::Blob(
                                    <Vec<
                                        u8,
                                    > as wasmtime::component::Lift>::load(
                                        cx,
                                        ty
                                            .cases[3usize]
                                            .ty
                                            .unwrap_or_else(
                                                wasmtime::component::__internal::bad_type_info,
                                            ),
                                        &payload[..<Vec<
                                            u8,
                                        > as wasmtime::component::ComponentType>::SIZE32],
                                    )?,
                                )
                            }
                            4u8 => Self::Null,
                            discrim => {
                                return ::anyhow::__private::Err(
                                    ::anyhow::Error::msg({
                                        let res = ::alloc::fmt::format(
                                            format_args!("unexpected discriminant: {0}", discrim),
                                        );
                                        res
                                    }),
                                );
                            }
                        },
                    )
                }
            }
            const _: () = {
                #[doc(hidden)]
                #[repr(C)]
                pub struct LowerValue<T0: Copy, T1: Copy, T2: Copy, T3: Copy> {
                    tag: wasmtime::ValRaw,
                    payload: LowerPayloadValue<T0, T1, T2, T3>,
                }
                #[automatically_derived]
                impl<
                    T0: ::core::clone::Clone + Copy,
                    T1: ::core::clone::Clone + Copy,
                    T2: ::core::clone::Clone + Copy,
                    T3: ::core::clone::Clone + Copy,
                > ::core::clone::Clone for LowerValue<T0, T1, T2, T3> {
                    #[inline]
                    fn clone(&self) -> LowerValue<T0, T1, T2, T3> {
                        LowerValue {
                            tag: ::core::clone::Clone::clone(&self.tag),
                            payload: ::core::clone::Clone::clone(&self.payload),
                        }
                    }
                }
                #[automatically_derived]
                impl<
                    T0: ::core::marker::Copy + Copy,
                    T1: ::core::marker::Copy + Copy,
                    T2: ::core::marker::Copy + Copy,
                    T3: ::core::marker::Copy + Copy,
                > ::core::marker::Copy for LowerValue<T0, T1, T2, T3> {}
                #[doc(hidden)]
                #[allow(non_snake_case)]
                #[repr(C)]
                union LowerPayloadValue<T0: Copy, T1: Copy, T2: Copy, T3: Copy> {
                    Integer: T0,
                    Real: T1,
                    Text: T2,
                    Blob: T3,
                    Null: [wasmtime::ValRaw; 0],
                }
                #[automatically_derived]
                #[allow(non_snake_case)]
                impl<
                    T0: ::core::marker::Copy + ::core::clone::Clone + Copy,
                    T1: ::core::marker::Copy + ::core::clone::Clone + Copy,
                    T2: ::core::marker::Copy + ::core::clone::Clone + Copy,
                    T3: ::core::marker::Copy + ::core::clone::Clone + Copy,
                > ::core::clone::Clone for LowerPayloadValue<T0, T1, T2, T3> {
                    #[inline]
                    fn clone(&self) -> LowerPayloadValue<T0, T1, T2, T3> {
                        let _: ::core::clone::AssertParamIsCopy<Self>;
                        *self
                    }
                }
                #[automatically_derived]
                #[allow(non_snake_case)]
                impl<
                    T0: ::core::marker::Copy + Copy,
                    T1: ::core::marker::Copy + Copy,
                    T2: ::core::marker::Copy + Copy,
                    T3: ::core::marker::Copy + Copy,
                > ::core::marker::Copy for LowerPayloadValue<T0, T1, T2, T3> {}
                unsafe impl wasmtime::component::ComponentType for Value {
                    type Lower = LowerValue<
                        <i64 as wasmtime::component::ComponentType>::Lower,
                        <f64 as wasmtime::component::ComponentType>::Lower,
                        <String as wasmtime::component::ComponentType>::Lower,
                        <Vec<u8> as wasmtime::component::ComponentType>::Lower,
                    >;
                    #[inline]
                    fn typecheck(
                        ty: &wasmtime::component::__internal::InterfaceType,
                        types: &wasmtime::component::__internal::InstanceType<'_>,
                    ) -> wasmtime::component::__internal::anyhow::Result<()> {
                        wasmtime::component::__internal::typecheck_variant(
                            ty,
                            types,
                            &[
                                (
                                    "integer",
                                    Some(<i64 as wasmtime::component::ComponentType>::typecheck),
                                ),
                                (
                                    "real",
                                    Some(<f64 as wasmtime::component::ComponentType>::typecheck),
                                ),
                                (
                                    "text",
                                    Some(
                                        <String as wasmtime::component::ComponentType>::typecheck,
                                    ),
                                ),
                                (
                                    "blob",
                                    Some(
                                        <Vec<u8> as wasmtime::component::ComponentType>::typecheck,
                                    ),
                                ),
                                ("null", None),
                            ],
                        )
                    }
                    const ABI: wasmtime::component::__internal::CanonicalAbiInfo = wasmtime::component::__internal::CanonicalAbiInfo::variant_static(
                        &[
                            Some(<i64 as wasmtime::component::ComponentType>::ABI),
                            Some(<f64 as wasmtime::component::ComponentType>::ABI),
                            Some(<String as wasmtime::component::ComponentType>::ABI),
                            Some(<Vec<u8> as wasmtime::component::ComponentType>::ABI),
                            None,
                        ],
                    );
                }
                unsafe impl wasmtime::component::__internal::ComponentVariant for Value {
                    const CASES: &'static [Option<
                        wasmtime::component::__internal::CanonicalAbiInfo,
                    >] = &[
                        Some(<i64 as wasmtime::component::ComponentType>::ABI),
                        Some(<f64 as wasmtime::component::ComponentType>::ABI),
                        Some(<String as wasmtime::component::ComponentType>::ABI),
                        Some(<Vec<u8> as wasmtime::component::ComponentType>::ABI),
                        None,
                    ];
                }
            };
            impl core::fmt::Debug for Value {
                fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
                    match self {
                        Value::Integer(e) => {
                            f.debug_tuple("Value::Integer").field(e).finish()
                        }
                        Value::Real(e) => f.debug_tuple("Value::Real").field(e).finish(),
                        Value::Text(e) => f.debug_tuple("Value::Text").field(e).finish(),
                        Value::Blob(e) => f.debug_tuple("Value::Blob").field(e).finish(),
                        Value::Null => f.debug_tuple("Value::Null").finish(),
                    }
                }
            }
            const _: () = {
                if !(16 == <Value as wasmtime::component::ComponentType>::SIZE32) {
                    ::core::panicking::panic(
                        "assertion failed: 16 == <Value as wasmtime::component::ComponentType>::SIZE32",
                    )
                }
                if !(8 == <Value as wasmtime::component::ComponentType>::ALIGN32) {
                    ::core::panicking::panic(
                        "assertion failed: 8 == <Value as wasmtime::component::ComponentType>::ALIGN32",
                    )
                }
            };
            #[component(record)]
            pub struct RowResult {
                #[component(name = "values")]
                pub values: Vec<Value>,
            }
            #[automatically_derived]
            impl ::core::clone::Clone for RowResult {
                #[inline]
                fn clone(&self) -> RowResult {
                    RowResult {
                        values: ::core::clone::Clone::clone(&self.values),
                    }
                }
            }
            unsafe impl wasmtime::component::Lower for RowResult {
                #[inline]
                fn lower<T>(
                    &self,
                    cx: &mut wasmtime::component::__internal::LowerContext<'_, T>,
                    ty: wasmtime::component::__internal::InterfaceType,
                    dst: &mut std::mem::MaybeUninit<Self::Lower>,
                ) -> wasmtime::component::__internal::anyhow::Result<()> {
                    let ty = match ty {
                        wasmtime::component::__internal::InterfaceType::Record(i) => {
                            &cx.types[i]
                        }
                        _ => wasmtime::component::__internal::bad_type_info(),
                    };
                    wasmtime::component::Lower::lower(
                        &self.values,
                        cx,
                        ty.fields[0usize].ty,
                        {
                            #[allow(unused_unsafe)]
                            {
                                unsafe {
                                    use ::wasmtime::component::__internal::MaybeUninitExt;
                                    let m: &mut std::mem::MaybeUninit<_> = dst;
                                    m.map(|p| &raw mut (*p).values)
                                }
                            }
                        },
                    )?;
                    Ok(())
                }
                #[inline]
                fn store<T>(
                    &self,
                    cx: &mut wasmtime::component::__internal::LowerContext<'_, T>,
                    ty: wasmtime::component::__internal::InterfaceType,
                    mut offset: usize,
                ) -> wasmtime::component::__internal::anyhow::Result<()> {
                    if true {
                        if !(offset
                            % (<Self as wasmtime::component::ComponentType>::ALIGN32
                                as usize) == 0)
                        {
                            ::core::panicking::panic(
                                "assertion failed: offset % (<Self as wasmtime::component::ComponentType>::ALIGN32 as usize) == 0",
                            )
                        }
                    }
                    let ty = match ty {
                        wasmtime::component::__internal::InterfaceType::Record(i) => {
                            &cx.types[i]
                        }
                        _ => wasmtime::component::__internal::bad_type_info(),
                    };
                    wasmtime::component::Lower::store(
                        &self.values,
                        cx,
                        ty.fields[0usize].ty,
                        <Vec<Value> as wasmtime::component::ComponentType>::ABI
                            .next_field32_size(&mut offset),
                    )?;
                    Ok(())
                }
            }
            unsafe impl wasmtime::component::Lift for RowResult {
                #[inline]
                fn lift(
                    cx: &mut wasmtime::component::__internal::LiftContext<'_>,
                    ty: wasmtime::component::__internal::InterfaceType,
                    src: &Self::Lower,
                ) -> wasmtime::component::__internal::anyhow::Result<Self> {
                    let ty = match ty {
                        wasmtime::component::__internal::InterfaceType::Record(i) => {
                            &cx.types[i]
                        }
                        _ => wasmtime::component::__internal::bad_type_info(),
                    };
                    Ok(Self {
                        values: <Vec<
                            Value,
                        > as wasmtime::component::Lift>::lift(
                            cx,
                            ty.fields[0usize].ty,
                            &src.values,
                        )?,
                    })
                }
                #[inline]
                fn load(
                    cx: &mut wasmtime::component::__internal::LiftContext<'_>,
                    ty: wasmtime::component::__internal::InterfaceType,
                    bytes: &[u8],
                ) -> wasmtime::component::__internal::anyhow::Result<Self> {
                    let ty = match ty {
                        wasmtime::component::__internal::InterfaceType::Record(i) => {
                            &cx.types[i]
                        }
                        _ => wasmtime::component::__internal::bad_type_info(),
                    };
                    if true {
                        if !((bytes.as_ptr() as usize)
                            % (<Self as wasmtime::component::ComponentType>::ALIGN32
                                as usize) == 0)
                        {
                            ::core::panicking::panic(
                                "assertion failed: (bytes.as_ptr() as usize) %\\n        (<Self as wasmtime::component::ComponentType>::ALIGN32 as usize) == 0",
                            )
                        }
                    }
                    let mut offset = 0;
                    Ok(Self {
                        values: <Vec<
                            Value,
                        > as wasmtime::component::Lift>::load(
                            cx,
                            ty.fields[0usize].ty,
                            &bytes[<Vec<
                                Value,
                            > as wasmtime::component::ComponentType>::ABI
                                .next_field32_size(
                                    &mut offset,
                                )..][..<Vec<
                                Value,
                            > as wasmtime::component::ComponentType>::SIZE32],
                        )?,
                    })
                }
            }
            const _: () = {
                #[doc(hidden)]
                #[repr(C)]
                pub struct LowerRowResult<T0: Copy> {
                    values: T0,
                    _align: [wasmtime::ValRaw; 0],
                }
                #[automatically_derived]
                impl<T0: ::core::clone::Clone + Copy> ::core::clone::Clone
                for LowerRowResult<T0> {
                    #[inline]
                    fn clone(&self) -> LowerRowResult<T0> {
                        LowerRowResult {
                            values: ::core::clone::Clone::clone(&self.values),
                            _align: ::core::clone::Clone::clone(&self._align),
                        }
                    }
                }
                #[automatically_derived]
                impl<T0: ::core::marker::Copy + Copy> ::core::marker::Copy
                for LowerRowResult<T0> {}
                unsafe impl wasmtime::component::ComponentType for RowResult {
                    type Lower = LowerRowResult<
                        <Vec<Value> as wasmtime::component::ComponentType>::Lower,
                    >;
                    const ABI: wasmtime::component::__internal::CanonicalAbiInfo = wasmtime::component::__internal::CanonicalAbiInfo::record_static(
                        &[<Vec<Value> as wasmtime::component::ComponentType>::ABI],
                    );
                    #[inline]
                    fn typecheck(
                        ty: &wasmtime::component::__internal::InterfaceType,
                        types: &wasmtime::component::__internal::InstanceType<'_>,
                    ) -> wasmtime::component::__internal::anyhow::Result<()> {
                        wasmtime::component::__internal::typecheck_record(
                            ty,
                            types,
                            &[
                                (
                                    "values",
                                    <Vec<
                                        Value,
                                    > as wasmtime::component::ComponentType>::typecheck,
                                ),
                            ],
                        )
                    }
                }
            };
            impl core::fmt::Debug for RowResult {
                fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
                    f.debug_struct("RowResult").field("values", &self.values).finish()
                }
            }
            const _: () = {
                if !(8 == <RowResult as wasmtime::component::ComponentType>::SIZE32) {
                    ::core::panicking::panic(
                        "assertion failed: 8 == <RowResult as wasmtime::component::ComponentType>::SIZE32",
                    )
                }
                if !(4 == <RowResult as wasmtime::component::ComponentType>::ALIGN32) {
                    ::core::panicking::panic(
                        "assertion failed: 4 == <RowResult as wasmtime::component::ComponentType>::ALIGN32",
                    )
                }
            };
            #[component(record)]
            pub struct QueryResult {
                #[component(name = "columns")]
                pub columns: Vec<String>,
                #[component(name = "rows")]
                pub rows: Vec<RowResult>,
            }
            #[automatically_derived]
            impl ::core::clone::Clone for QueryResult {
                #[inline]
                fn clone(&self) -> QueryResult {
                    QueryResult {
                        columns: ::core::clone::Clone::clone(&self.columns),
                        rows: ::core::clone::Clone::clone(&self.rows),
                    }
                }
            }
            unsafe impl wasmtime::component::Lower for QueryResult {
                #[inline]
                fn lower<T>(
                    &self,
                    cx: &mut wasmtime::component::__internal::LowerContext<'_, T>,
                    ty: wasmtime::component::__internal::InterfaceType,
                    dst: &mut std::mem::MaybeUninit<Self::Lower>,
                ) -> wasmtime::component::__internal::anyhow::Result<()> {
                    let ty = match ty {
                        wasmtime::component::__internal::InterfaceType::Record(i) => {
                            &cx.types[i]
                        }
                        _ => wasmtime::component::__internal::bad_type_info(),
                    };
                    wasmtime::component::Lower::lower(
                        &self.columns,
                        cx,
                        ty.fields[0usize].ty,
                        {
                            #[allow(unused_unsafe)]
                            {
                                unsafe {
                                    use ::wasmtime::component::__internal::MaybeUninitExt;
                                    let m: &mut std::mem::MaybeUninit<_> = dst;
                                    m.map(|p| &raw mut (*p).columns)
                                }
                            }
                        },
                    )?;
                    wasmtime::component::Lower::lower(
                        &self.rows,
                        cx,
                        ty.fields[1usize].ty,
                        {
                            #[allow(unused_unsafe)]
                            {
                                unsafe {
                                    use ::wasmtime::component::__internal::MaybeUninitExt;
                                    let m: &mut std::mem::MaybeUninit<_> = dst;
                                    m.map(|p| &raw mut (*p).rows)
                                }
                            }
                        },
                    )?;
                    Ok(())
                }
                #[inline]
                fn store<T>(
                    &self,
                    cx: &mut wasmtime::component::__internal::LowerContext<'_, T>,
                    ty: wasmtime::component::__internal::InterfaceType,
                    mut offset: usize,
                ) -> wasmtime::component::__internal::anyhow::Result<()> {
                    if true {
                        if !(offset
                            % (<Self as wasmtime::component::ComponentType>::ALIGN32
                                as usize) == 0)
                        {
                            ::core::panicking::panic(
                                "assertion failed: offset % (<Self as wasmtime::component::ComponentType>::ALIGN32 as usize) == 0",
                            )
                        }
                    }
                    let ty = match ty {
                        wasmtime::component::__internal::InterfaceType::Record(i) => {
                            &cx.types[i]
                        }
                        _ => wasmtime::component::__internal::bad_type_info(),
                    };
                    wasmtime::component::Lower::store(
                        &self.columns,
                        cx,
                        ty.fields[0usize].ty,
                        <Vec<String> as wasmtime::component::ComponentType>::ABI
                            .next_field32_size(&mut offset),
                    )?;
                    wasmtime::component::Lower::store(
                        &self.rows,
                        cx,
                        ty.fields[1usize].ty,
                        <Vec<RowResult> as wasmtime::component::ComponentType>::ABI
                            .next_field32_size(&mut offset),
                    )?;
                    Ok(())
                }
            }
            unsafe impl wasmtime::component::Lift for QueryResult {
                #[inline]
                fn lift(
                    cx: &mut wasmtime::component::__internal::LiftContext<'_>,
                    ty: wasmtime::component::__internal::InterfaceType,
                    src: &Self::Lower,
                ) -> wasmtime::component::__internal::anyhow::Result<Self> {
                    let ty = match ty {
                        wasmtime::component::__internal::InterfaceType::Record(i) => {
                            &cx.types[i]
                        }
                        _ => wasmtime::component::__internal::bad_type_info(),
                    };
                    Ok(Self {
                        columns: <Vec<
                            String,
                        > as wasmtime::component::Lift>::lift(
                            cx,
                            ty.fields[0usize].ty,
                            &src.columns,
                        )?,
                        rows: <Vec<
                            RowResult,
                        > as wasmtime::component::Lift>::lift(
                            cx,
                            ty.fields[1usize].ty,
                            &src.rows,
                        )?,
                    })
                }
                #[inline]
                fn load(
                    cx: &mut wasmtime::component::__internal::LiftContext<'_>,
                    ty: wasmtime::component::__internal::InterfaceType,
                    bytes: &[u8],
                ) -> wasmtime::component::__internal::anyhow::Result<Self> {
                    let ty = match ty {
                        wasmtime::component::__internal::InterfaceType::Record(i) => {
                            &cx.types[i]
                        }
                        _ => wasmtime::component::__internal::bad_type_info(),
                    };
                    if true {
                        if !((bytes.as_ptr() as usize)
                            % (<Self as wasmtime::component::ComponentType>::ALIGN32
                                as usize) == 0)
                        {
                            ::core::panicking::panic(
                                "assertion failed: (bytes.as_ptr() as usize) %\\n        (<Self as wasmtime::component::ComponentType>::ALIGN32 as usize) == 0",
                            )
                        }
                    }
                    let mut offset = 0;
                    Ok(Self {
                        columns: <Vec<
                            String,
                        > as wasmtime::component::Lift>::load(
                            cx,
                            ty.fields[0usize].ty,
                            &bytes[<Vec<
                                String,
                            > as wasmtime::component::ComponentType>::ABI
                                .next_field32_size(
                                    &mut offset,
                                )..][..<Vec<
                                String,
                            > as wasmtime::component::ComponentType>::SIZE32],
                        )?,
                        rows: <Vec<
                            RowResult,
                        > as wasmtime::component::Lift>::load(
                            cx,
                            ty.fields[1usize].ty,
                            &bytes[<Vec<
                                RowResult,
                            > as wasmtime::component::ComponentType>::ABI
                                .next_field32_size(
                                    &mut offset,
                                )..][..<Vec<
                                RowResult,
                            > as wasmtime::component::ComponentType>::SIZE32],
                        )?,
                    })
                }
            }
            const _: () = {
                #[doc(hidden)]
                #[repr(C)]
                pub struct LowerQueryResult<T0: Copy, T1: Copy> {
                    columns: T0,
                    rows: T1,
                    _align: [wasmtime::ValRaw; 0],
                }
                #[automatically_derived]
                impl<
                    T0: ::core::clone::Clone + Copy,
                    T1: ::core::clone::Clone + Copy,
                > ::core::clone::Clone for LowerQueryResult<T0, T1> {
                    #[inline]
                    fn clone(&self) -> LowerQueryResult<T0, T1> {
                        LowerQueryResult {
                            columns: ::core::clone::Clone::clone(&self.columns),
                            rows: ::core::clone::Clone::clone(&self.rows),
                            _align: ::core::clone::Clone::clone(&self._align),
                        }
                    }
                }
                #[automatically_derived]
                impl<
                    T0: ::core::marker::Copy + Copy,
                    T1: ::core::marker::Copy + Copy,
                > ::core::marker::Copy for LowerQueryResult<T0, T1> {}
                unsafe impl wasmtime::component::ComponentType for QueryResult {
                    type Lower = LowerQueryResult<
                        <Vec<String> as wasmtime::component::ComponentType>::Lower,
                        <Vec<RowResult> as wasmtime::component::ComponentType>::Lower,
                    >;
                    const ABI: wasmtime::component::__internal::CanonicalAbiInfo = wasmtime::component::__internal::CanonicalAbiInfo::record_static(
                        &[
                            <Vec<String> as wasmtime::component::ComponentType>::ABI,
                            <Vec<RowResult> as wasmtime::component::ComponentType>::ABI,
                        ],
                    );
                    #[inline]
                    fn typecheck(
                        ty: &wasmtime::component::__internal::InterfaceType,
                        types: &wasmtime::component::__internal::InstanceType<'_>,
                    ) -> wasmtime::component::__internal::anyhow::Result<()> {
                        wasmtime::component::__internal::typecheck_record(
                            ty,
                            types,
                            &[
                                (
                                    "columns",
                                    <Vec<
                                        String,
                                    > as wasmtime::component::ComponentType>::typecheck,
                                ),
                                (
                                    "rows",
                                    <Vec<
                                        RowResult,
                                    > as wasmtime::component::ComponentType>::typecheck,
                                ),
                            ],
                        )
                    }
                }
            };
            impl core::fmt::Debug for QueryResult {
                fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
                    f.debug_struct("QueryResult")
                        .field("columns", &self.columns)
                        .field("rows", &self.rows)
                        .finish()
                }
            }
            const _: () = {
                if !(16 == <QueryResult as wasmtime::component::ComponentType>::SIZE32) {
                    ::core::panicking::panic(
                        "assertion failed: 16 == <QueryResult as wasmtime::component::ComponentType>::SIZE32",
                    )
                }
                if !(4 == <QueryResult as wasmtime::component::ComponentType>::ALIGN32) {
                    ::core::panicking::panic(
                        "assertion failed: 4 == <QueryResult as wasmtime::component::ComponentType>::ALIGN32",
                    )
                }
            };
            pub trait Host {
                #[must_use]
                #[allow(clippy::type_complexity, clippy::type_repetition_in_bounds)]
                fn open<'life0, 'async_trait>(
                    &'life0 mut self,
                    database: String,
                ) -> ::core::pin::Pin<
                    Box<
                        dyn ::core::future::Future<
                            Output = wasmtime::Result<Result<Connection, Error>>,
                        > + ::core::marker::Send + 'async_trait,
                    >,
                >
                where
                    'life0: 'async_trait,
                    Self: 'async_trait;
                #[must_use]
                #[allow(clippy::type_complexity, clippy::type_repetition_in_bounds)]
                fn execute<'life0, 'async_trait>(
                    &'life0 mut self,
                    conn: Connection,
                    statement: String,
                    parameters: Vec<Value>,
                ) -> ::core::pin::Pin<
                    Box<
                        dyn ::core::future::Future<
                            Output = wasmtime::Result<Result<QueryResult, Error>>,
                        > + ::core::marker::Send + 'async_trait,
                    >,
                >
                where
                    'life0: 'async_trait,
                    Self: 'async_trait;
                #[must_use]
                #[allow(clippy::type_complexity, clippy::type_repetition_in_bounds)]
                fn close<'life0, 'async_trait>(
                    &'life0 mut self,
                    conn: Connection,
                ) -> ::core::pin::Pin<
                    Box<
                        dyn ::core::future::Future<
                            Output = wasmtime::Result<()>,
                        > + ::core::marker::Send + 'async_trait,
                    >,
                >
                where
                    'life0: 'async_trait,
                    Self: 'async_trait;
            }
            pub fn add_to_linker<T, U>(
                linker: &mut wasmtime::component::Linker<T>,
                get: impl Fn(&mut T) -> &mut U + Send + Sync + Copy + 'static,
            ) -> wasmtime::Result<()>
            where
                T: Send,
                U: Host + Send,
            {
                let mut inst = linker.instance("fermyon:spin/sqlite")?;
                inst.func_wrap_async(
                    "open",
                    move |
                        mut caller: wasmtime::StoreContextMut<'_, T>,
                        (arg0,): (String,)|
                    Box::new(async move {
                        let host = get(caller.data_mut());
                        let r = Host::open(host, arg0).await;
                        Ok((r?,))
                    }),
                )?;
                inst.func_wrap_async(
                    "execute",
                    move |
                        mut caller: wasmtime::StoreContextMut<'_, T>,
                        (arg0, arg1, arg2): (Connection, String, Vec<Value>)|
                    Box::new(async move {
                        let host = get(caller.data_mut());
                        let r = Host::execute(host, arg0, arg1, arg2).await;
                        Ok((r?,))
                    }),
                )?;
                inst.func_wrap_async(
                    "close",
                    move |
                        mut caller: wasmtime::StoreContextMut<'_, T>,
                        (arg0,): (Connection,)|
                    Box::new(async move {
                        let host = get(caller.data_mut());
                        let r = Host::close(host, arg0).await;
                        r
                    }),
                )?;
                Ok(())
            }
        }
        #[allow(clippy::all)]
        pub mod redis {
            #[allow(unused_imports)]
            use wasmtime::component::__internal::anyhow;
            pub type Payload = super::super::super::fermyon::spin::redis_types::Payload;
            const _: () = {
                if !(8 == <Payload as wasmtime::component::ComponentType>::SIZE32) {
                    ::core::panicking::panic(
                        "assertion failed: 8 == <Payload as wasmtime::component::ComponentType>::SIZE32",
                    )
                }
                if !(4 == <Payload as wasmtime::component::ComponentType>::ALIGN32) {
                    ::core::panicking::panic(
                        "assertion failed: 4 == <Payload as wasmtime::component::ComponentType>::ALIGN32",
                    )
                }
            };
            pub type RedisParameter = super::super::super::fermyon::spin::redis_types::RedisParameter;
            const _: () = {
                if !(16
                    == <RedisParameter as wasmtime::component::ComponentType>::SIZE32)
                {
                    ::core::panicking::panic(
                        "assertion failed: 16 == <RedisParameter as wasmtime::component::ComponentType>::SIZE32",
                    )
                }
                if !(8
                    == <RedisParameter as wasmtime::component::ComponentType>::ALIGN32)
                {
                    ::core::panicking::panic(
                        "assertion failed: 8 == <RedisParameter as wasmtime::component::ComponentType>::ALIGN32",
                    )
                }
            };
            pub type RedisResult = super::super::super::fermyon::spin::redis_types::RedisResult;
            const _: () = {
                if !(16 == <RedisResult as wasmtime::component::ComponentType>::SIZE32) {
                    ::core::panicking::panic(
                        "assertion failed: 16 == <RedisResult as wasmtime::component::ComponentType>::SIZE32",
                    )
                }
                if !(8 == <RedisResult as wasmtime::component::ComponentType>::ALIGN32) {
                    ::core::panicking::panic(
                        "assertion failed: 8 == <RedisResult as wasmtime::component::ComponentType>::ALIGN32",
                    )
                }
            };
            pub type Error = super::super::super::fermyon::spin::redis_types::Error;
            const _: () = {
                if !(1 == <Error as wasmtime::component::ComponentType>::SIZE32) {
                    ::core::panicking::panic(
                        "assertion failed: 1 == <Error as wasmtime::component::ComponentType>::SIZE32",
                    )
                }
                if !(1 == <Error as wasmtime::component::ComponentType>::ALIGN32) {
                    ::core::panicking::panic(
                        "assertion failed: 1 == <Error as wasmtime::component::ComponentType>::ALIGN32",
                    )
                }
            };
            pub trait Host {
                #[must_use]
                #[allow(clippy::type_complexity, clippy::type_repetition_in_bounds)]
                fn publish<'life0, 'async_trait>(
                    &'life0 mut self,
                    address: String,
                    channel: String,
                    payload: Payload,
                ) -> ::core::pin::Pin<
                    Box<
                        dyn ::core::future::Future<
                            Output = wasmtime::Result<Result<(), Error>>,
                        > + ::core::marker::Send + 'async_trait,
                    >,
                >
                where
                    'life0: 'async_trait,
                    Self: 'async_trait;
                #[must_use]
                #[allow(clippy::type_complexity, clippy::type_repetition_in_bounds)]
                fn get<'life0, 'async_trait>(
                    &'life0 mut self,
                    address: String,
                    key: String,
                ) -> ::core::pin::Pin<
                    Box<
                        dyn ::core::future::Future<
                            Output = wasmtime::Result<Result<Payload, Error>>,
                        > + ::core::marker::Send + 'async_trait,
                    >,
                >
                where
                    'life0: 'async_trait,
                    Self: 'async_trait;
                #[must_use]
                #[allow(clippy::type_complexity, clippy::type_repetition_in_bounds)]
                fn set<'life0, 'async_trait>(
                    &'life0 mut self,
                    address: String,
                    key: String,
                    value: Payload,
                ) -> ::core::pin::Pin<
                    Box<
                        dyn ::core::future::Future<
                            Output = wasmtime::Result<Result<(), Error>>,
                        > + ::core::marker::Send + 'async_trait,
                    >,
                >
                where
                    'life0: 'async_trait,
                    Self: 'async_trait;
                #[must_use]
                #[allow(clippy::type_complexity, clippy::type_repetition_in_bounds)]
                fn incr<'life0, 'async_trait>(
                    &'life0 mut self,
                    address: String,
                    key: String,
                ) -> ::core::pin::Pin<
                    Box<
                        dyn ::core::future::Future<
                            Output = wasmtime::Result<Result<i64, Error>>,
                        > + ::core::marker::Send + 'async_trait,
                    >,
                >
                where
                    'life0: 'async_trait,
                    Self: 'async_trait;
                #[must_use]
                #[allow(clippy::type_complexity, clippy::type_repetition_in_bounds)]
                fn del<'life0, 'async_trait>(
                    &'life0 mut self,
                    address: String,
                    keys: Vec<String>,
                ) -> ::core::pin::Pin<
                    Box<
                        dyn ::core::future::Future<
                            Output = wasmtime::Result<Result<i64, Error>>,
                        > + ::core::marker::Send + 'async_trait,
                    >,
                >
                where
                    'life0: 'async_trait,
                    Self: 'async_trait;
                #[must_use]
                #[allow(clippy::type_complexity, clippy::type_repetition_in_bounds)]
                fn sadd<'life0, 'async_trait>(
                    &'life0 mut self,
                    address: String,
                    key: String,
                    values: Vec<String>,
                ) -> ::core::pin::Pin<
                    Box<
                        dyn ::core::future::Future<
                            Output = wasmtime::Result<Result<i64, Error>>,
                        > + ::core::marker::Send + 'async_trait,
                    >,
                >
                where
                    'life0: 'async_trait,
                    Self: 'async_trait;
                #[must_use]
                #[allow(clippy::type_complexity, clippy::type_repetition_in_bounds)]
                fn smembers<'life0, 'async_trait>(
                    &'life0 mut self,
                    address: String,
                    key: String,
                ) -> ::core::pin::Pin<
                    Box<
                        dyn ::core::future::Future<
                            Output = wasmtime::Result<Result<Vec<String>, Error>>,
                        > + ::core::marker::Send + 'async_trait,
                    >,
                >
                where
                    'life0: 'async_trait,
                    Self: 'async_trait;
                #[must_use]
                #[allow(clippy::type_complexity, clippy::type_repetition_in_bounds)]
                fn srem<'life0, 'async_trait>(
                    &'life0 mut self,
                    address: String,
                    key: String,
                    values: Vec<String>,
                ) -> ::core::pin::Pin<
                    Box<
                        dyn ::core::future::Future<
                            Output = wasmtime::Result<Result<i64, Error>>,
                        > + ::core::marker::Send + 'async_trait,
                    >,
                >
                where
                    'life0: 'async_trait,
                    Self: 'async_trait;
                #[must_use]
                #[allow(clippy::type_complexity, clippy::type_repetition_in_bounds)]
                fn execute<'life0, 'async_trait>(
                    &'life0 mut self,
                    address: String,
                    command: String,
                    arguments: Vec<RedisParameter>,
                ) -> ::core::pin::Pin<
                    Box<
                        dyn ::core::future::Future<
                            Output = wasmtime::Result<Result<Vec<RedisResult>, Error>>,
                        > + ::core::marker::Send + 'async_trait,
                    >,
                >
                where
                    'life0: 'async_trait,
                    Self: 'async_trait;
            }
            pub fn add_to_linker<T, U>(
                linker: &mut wasmtime::component::Linker<T>,
                get: impl Fn(&mut T) -> &mut U + Send + Sync + Copy + 'static,
            ) -> wasmtime::Result<()>
            where
                T: Send,
                U: Host + Send,
            {
                let mut inst = linker.instance("fermyon:spin/redis")?;
                inst.func_wrap_async(
                    "publish",
                    move |
                        mut caller: wasmtime::StoreContextMut<'_, T>,
                        (arg0, arg1, arg2): (String, String, Payload)|
                    Box::new(async move {
                        let host = get(caller.data_mut());
                        let r = Host::publish(host, arg0, arg1, arg2).await;
                        Ok((r?,))
                    }),
                )?;
                inst.func_wrap_async(
                    "get",
                    move |
                        mut caller: wasmtime::StoreContextMut<'_, T>,
                        (arg0, arg1): (String, String)|
                    Box::new(async move {
                        let host = get(caller.data_mut());
                        let r = Host::get(host, arg0, arg1).await;
                        Ok((r?,))
                    }),
                )?;
                inst.func_wrap_async(
                    "set",
                    move |
                        mut caller: wasmtime::StoreContextMut<'_, T>,
                        (arg0, arg1, arg2): (String, String, Payload)|
                    Box::new(async move {
                        let host = get(caller.data_mut());
                        let r = Host::set(host, arg0, arg1, arg2).await;
                        Ok((r?,))
                    }),
                )?;
                inst.func_wrap_async(
                    "incr",
                    move |
                        mut caller: wasmtime::StoreContextMut<'_, T>,
                        (arg0, arg1): (String, String)|
                    Box::new(async move {
                        let host = get(caller.data_mut());
                        let r = Host::incr(host, arg0, arg1).await;
                        Ok((r?,))
                    }),
                )?;
                inst.func_wrap_async(
                    "del",
                    move |
                        mut caller: wasmtime::StoreContextMut<'_, T>,
                        (arg0, arg1): (String, Vec<String>)|
                    Box::new(async move {
                        let host = get(caller.data_mut());
                        let r = Host::del(host, arg0, arg1).await;
                        Ok((r?,))
                    }),
                )?;
                inst.func_wrap_async(
                    "sadd",
                    move |
                        mut caller: wasmtime::StoreContextMut<'_, T>,
                        (arg0, arg1, arg2): (String, String, Vec<String>)|
                    Box::new(async move {
                        let host = get(caller.data_mut());
                        let r = Host::sadd(host, arg0, arg1, arg2).await;
                        Ok((r?,))
                    }),
                )?;
                inst.func_wrap_async(
                    "smembers",
                    move |
                        mut caller: wasmtime::StoreContextMut<'_, T>,
                        (arg0, arg1): (String, String)|
                    Box::new(async move {
                        let host = get(caller.data_mut());
                        let r = Host::smembers(host, arg0, arg1).await;
                        Ok((r?,))
                    }),
                )?;
                inst.func_wrap_async(
                    "srem",
                    move |
                        mut caller: wasmtime::StoreContextMut<'_, T>,
                        (arg0, arg1, arg2): (String, String, Vec<String>)|
                    Box::new(async move {
                        let host = get(caller.data_mut());
                        let r = Host::srem(host, arg0, arg1, arg2).await;
                        Ok((r?,))
                    }),
                )?;
                inst.func_wrap_async(
                    "execute",
                    move |
                        mut caller: wasmtime::StoreContextMut<'_, T>,
                        (arg0, arg1, arg2): (String, String, Vec<RedisParameter>)|
                    Box::new(async move {
                        let host = get(caller.data_mut());
                        let r = Host::execute(host, arg0, arg1, arg2).await;
                        Ok((r?,))
                    }),
                )?;
                Ok(())
            }
        }
        #[allow(clippy::all)]
        pub mod key_value {
            #[allow(unused_imports)]
            use wasmtime::component::__internal::anyhow;
            pub type Store = u32;
            const _: () = {
                if !(4 == <Store as wasmtime::component::ComponentType>::SIZE32) {
                    ::core::panicking::panic(
                        "assertion failed: 4 == <Store as wasmtime::component::ComponentType>::SIZE32",
                    )
                }
                if !(4 == <Store as wasmtime::component::ComponentType>::ALIGN32) {
                    ::core::panicking::panic(
                        "assertion failed: 4 == <Store as wasmtime::component::ComponentType>::ALIGN32",
                    )
                }
            };
            #[component(variant)]
            pub enum Error {
                #[component(name = "store-table-full")]
                StoreTableFull,
                #[component(name = "no-such-store")]
                NoSuchStore,
                #[component(name = "access-denied")]
                AccessDenied,
                #[component(name = "invalid-store")]
                InvalidStore,
                #[component(name = "no-such-key")]
                NoSuchKey,
                #[component(name = "io")]
                Io(String),
            }
            #[automatically_derived]
            impl ::core::clone::Clone for Error {
                #[inline]
                fn clone(&self) -> Error {
                    match self {
                        Error::StoreTableFull => Error::StoreTableFull,
                        Error::NoSuchStore => Error::NoSuchStore,
                        Error::AccessDenied => Error::AccessDenied,
                        Error::InvalidStore => Error::InvalidStore,
                        Error::NoSuchKey => Error::NoSuchKey,
                        Error::Io(__self_0) => {
                            Error::Io(::core::clone::Clone::clone(__self_0))
                        }
                    }
                }
            }
            unsafe impl wasmtime::component::Lower for Error {
                #[inline]
                fn lower<T>(
                    &self,
                    cx: &mut wasmtime::component::__internal::LowerContext<'_, T>,
                    ty: wasmtime::component::__internal::InterfaceType,
                    dst: &mut std::mem::MaybeUninit<Self::Lower>,
                ) -> wasmtime::component::__internal::anyhow::Result<()> {
                    let ty = match ty {
                        wasmtime::component::__internal::InterfaceType::Variant(i) => {
                            &cx.types[i]
                        }
                        _ => wasmtime::component::__internal::bad_type_info(),
                    };
                    match self {
                        Self::StoreTableFull => {
                            {
                                #[allow(unused_unsafe)]
                                {
                                    unsafe {
                                        use ::wasmtime::component::__internal::MaybeUninitExt;
                                        let m: &mut std::mem::MaybeUninit<_> = dst;
                                        m.map(|p| &raw mut (*p).tag)
                                    }
                                }
                            }
                                .write(wasmtime::ValRaw::u32(0u32));
                            unsafe {
                                wasmtime::component::__internal::lower_payload(
                                    {
                                        #[allow(unused_unsafe)]
                                        {
                                            unsafe {
                                                use ::wasmtime::component::__internal::MaybeUninitExt;
                                                let m: &mut std::mem::MaybeUninit<_> = dst;
                                                m.map(|p| &raw mut (*p).payload)
                                            }
                                        }
                                    },
                                    |payload| {
                                        #[allow(unused_unsafe)]
                                        {
                                            unsafe {
                                                use ::wasmtime::component::__internal::MaybeUninitExt;
                                                let m: &mut std::mem::MaybeUninit<_> = payload;
                                                m.map(|p| &raw mut (*p).StoreTableFull)
                                            }
                                        }
                                    },
                                    |dst| Ok(()),
                                )
                            }
                        }
                        Self::NoSuchStore => {
                            {
                                #[allow(unused_unsafe)]
                                {
                                    unsafe {
                                        use ::wasmtime::component::__internal::MaybeUninitExt;
                                        let m: &mut std::mem::MaybeUninit<_> = dst;
                                        m.map(|p| &raw mut (*p).tag)
                                    }
                                }
                            }
                                .write(wasmtime::ValRaw::u32(1u32));
                            unsafe {
                                wasmtime::component::__internal::lower_payload(
                                    {
                                        #[allow(unused_unsafe)]
                                        {
                                            unsafe {
                                                use ::wasmtime::component::__internal::MaybeUninitExt;
                                                let m: &mut std::mem::MaybeUninit<_> = dst;
                                                m.map(|p| &raw mut (*p).payload)
                                            }
                                        }
                                    },
                                    |payload| {
                                        #[allow(unused_unsafe)]
                                        {
                                            unsafe {
                                                use ::wasmtime::component::__internal::MaybeUninitExt;
                                                let m: &mut std::mem::MaybeUninit<_> = payload;
                                                m.map(|p| &raw mut (*p).NoSuchStore)
                                            }
                                        }
                                    },
                                    |dst| Ok(()),
                                )
                            }
                        }
                        Self::AccessDenied => {
                            {
                                #[allow(unused_unsafe)]
                                {
                                    unsafe {
                                        use ::wasmtime::component::__internal::MaybeUninitExt;
                                        let m: &mut std::mem::MaybeUninit<_> = dst;
                                        m.map(|p| &raw mut (*p).tag)
                                    }
                                }
                            }
                                .write(wasmtime::ValRaw::u32(2u32));
                            unsafe {
                                wasmtime::component::__internal::lower_payload(
                                    {
                                        #[allow(unused_unsafe)]
                                        {
                                            unsafe {
                                                use ::wasmtime::component::__internal::MaybeUninitExt;
                                                let m: &mut std::mem::MaybeUninit<_> = dst;
                                                m.map(|p| &raw mut (*p).payload)
                                            }
                                        }
                                    },
                                    |payload| {
                                        #[allow(unused_unsafe)]
                                        {
                                            unsafe {
                                                use ::wasmtime::component::__internal::MaybeUninitExt;
                                                let m: &mut std::mem::MaybeUninit<_> = payload;
                                                m.map(|p| &raw mut (*p).AccessDenied)
                                            }
                                        }
                                    },
                                    |dst| Ok(()),
                                )
                            }
                        }
                        Self::InvalidStore => {
                            {
                                #[allow(unused_unsafe)]
                                {
                                    unsafe {
                                        use ::wasmtime::component::__internal::MaybeUninitExt;
                                        let m: &mut std::mem::MaybeUninit<_> = dst;
                                        m.map(|p| &raw mut (*p).tag)
                                    }
                                }
                            }
                                .write(wasmtime::ValRaw::u32(3u32));
                            unsafe {
                                wasmtime::component::__internal::lower_payload(
                                    {
                                        #[allow(unused_unsafe)]
                                        {
                                            unsafe {
                                                use ::wasmtime::component::__internal::MaybeUninitExt;
                                                let m: &mut std::mem::MaybeUninit<_> = dst;
                                                m.map(|p| &raw mut (*p).payload)
                                            }
                                        }
                                    },
                                    |payload| {
                                        #[allow(unused_unsafe)]
                                        {
                                            unsafe {
                                                use ::wasmtime::component::__internal::MaybeUninitExt;
                                                let m: &mut std::mem::MaybeUninit<_> = payload;
                                                m.map(|p| &raw mut (*p).InvalidStore)
                                            }
                                        }
                                    },
                                    |dst| Ok(()),
                                )
                            }
                        }
                        Self::NoSuchKey => {
                            {
                                #[allow(unused_unsafe)]
                                {
                                    unsafe {
                                        use ::wasmtime::component::__internal::MaybeUninitExt;
                                        let m: &mut std::mem::MaybeUninit<_> = dst;
                                        m.map(|p| &raw mut (*p).tag)
                                    }
                                }
                            }
                                .write(wasmtime::ValRaw::u32(4u32));
                            unsafe {
                                wasmtime::component::__internal::lower_payload(
                                    {
                                        #[allow(unused_unsafe)]
                                        {
                                            unsafe {
                                                use ::wasmtime::component::__internal::MaybeUninitExt;
                                                let m: &mut std::mem::MaybeUninit<_> = dst;
                                                m.map(|p| &raw mut (*p).payload)
                                            }
                                        }
                                    },
                                    |payload| {
                                        #[allow(unused_unsafe)]
                                        {
                                            unsafe {
                                                use ::wasmtime::component::__internal::MaybeUninitExt;
                                                let m: &mut std::mem::MaybeUninit<_> = payload;
                                                m.map(|p| &raw mut (*p).NoSuchKey)
                                            }
                                        }
                                    },
                                    |dst| Ok(()),
                                )
                            }
                        }
                        Self::Io(value) => {
                            {
                                #[allow(unused_unsafe)]
                                {
                                    unsafe {
                                        use ::wasmtime::component::__internal::MaybeUninitExt;
                                        let m: &mut std::mem::MaybeUninit<_> = dst;
                                        m.map(|p| &raw mut (*p).tag)
                                    }
                                }
                            }
                                .write(wasmtime::ValRaw::u32(5u32));
                            unsafe {
                                wasmtime::component::__internal::lower_payload(
                                    {
                                        #[allow(unused_unsafe)]
                                        {
                                            unsafe {
                                                use ::wasmtime::component::__internal::MaybeUninitExt;
                                                let m: &mut std::mem::MaybeUninit<_> = dst;
                                                m.map(|p| &raw mut (*p).payload)
                                            }
                                        }
                                    },
                                    |payload| {
                                        #[allow(unused_unsafe)]
                                        {
                                            unsafe {
                                                use ::wasmtime::component::__internal::MaybeUninitExt;
                                                let m: &mut std::mem::MaybeUninit<_> = payload;
                                                m.map(|p| &raw mut (*p).Io)
                                            }
                                        }
                                    },
                                    |dst| {
                                        value
                                            .lower(
                                                cx,
                                                ty
                                                    .cases[5usize]
                                                    .ty
                                                    .unwrap_or_else(
                                                        wasmtime::component::__internal::bad_type_info,
                                                    ),
                                                dst,
                                            )
                                    },
                                )
                            }
                        }
                    }
                }
                #[inline]
                fn store<T>(
                    &self,
                    cx: &mut wasmtime::component::__internal::LowerContext<'_, T>,
                    ty: wasmtime::component::__internal::InterfaceType,
                    mut offset: usize,
                ) -> wasmtime::component::__internal::anyhow::Result<()> {
                    let ty = match ty {
                        wasmtime::component::__internal::InterfaceType::Variant(i) => {
                            &cx.types[i]
                        }
                        _ => wasmtime::component::__internal::bad_type_info(),
                    };
                    if true {
                        if !(offset
                            % (<Self as wasmtime::component::ComponentType>::ALIGN32
                                as usize) == 0)
                        {
                            ::core::panicking::panic(
                                "assertion failed: offset % (<Self as wasmtime::component::ComponentType>::ALIGN32 as usize) == 0",
                            )
                        }
                    }
                    match self {
                        Self::StoreTableFull => {
                            *cx.get::<1usize>(offset) = 0u8.to_le_bytes();
                            Ok(())
                        }
                        Self::NoSuchStore => {
                            *cx.get::<1usize>(offset) = 1u8.to_le_bytes();
                            Ok(())
                        }
                        Self::AccessDenied => {
                            *cx.get::<1usize>(offset) = 2u8.to_le_bytes();
                            Ok(())
                        }
                        Self::InvalidStore => {
                            *cx.get::<1usize>(offset) = 3u8.to_le_bytes();
                            Ok(())
                        }
                        Self::NoSuchKey => {
                            *cx.get::<1usize>(offset) = 4u8.to_le_bytes();
                            Ok(())
                        }
                        Self::Io(value) => {
                            *cx.get::<1usize>(offset) = 5u8.to_le_bytes();
                            value
                                .store(
                                    cx,
                                    ty
                                        .cases[5usize]
                                        .ty
                                        .unwrap_or_else(
                                            wasmtime::component::__internal::bad_type_info,
                                        ),
                                    offset
                                        + <Self as wasmtime::component::__internal::ComponentVariant>::PAYLOAD_OFFSET32,
                                )
                        }
                    }
                }
            }
            unsafe impl wasmtime::component::Lift for Error {
                #[inline]
                fn lift(
                    cx: &mut wasmtime::component::__internal::LiftContext<'_>,
                    ty: wasmtime::component::__internal::InterfaceType,
                    src: &Self::Lower,
                ) -> wasmtime::component::__internal::anyhow::Result<Self> {
                    let ty = match ty {
                        wasmtime::component::__internal::InterfaceType::Variant(i) => {
                            &cx.types[i]
                        }
                        _ => wasmtime::component::__internal::bad_type_info(),
                    };
                    Ok(
                        match src.tag.get_u32() {
                            0u32 => Self::StoreTableFull,
                            1u32 => Self::NoSuchStore,
                            2u32 => Self::AccessDenied,
                            3u32 => Self::InvalidStore,
                            4u32 => Self::NoSuchKey,
                            5u32 => {
                                Self::Io(
                                    <String as wasmtime::component::Lift>::lift(
                                        cx,
                                        ty
                                            .cases[5usize]
                                            .ty
                                            .unwrap_or_else(
                                                wasmtime::component::__internal::bad_type_info,
                                            ),
                                        unsafe { &src.payload.Io },
                                    )?,
                                )
                            }
                            discrim => {
                                return ::anyhow::__private::Err(
                                    ::anyhow::Error::msg({
                                        let res = ::alloc::fmt::format(
                                            format_args!("unexpected discriminant: {0}", discrim),
                                        );
                                        res
                                    }),
                                );
                            }
                        },
                    )
                }
                #[inline]
                fn load(
                    cx: &mut wasmtime::component::__internal::LiftContext<'_>,
                    ty: wasmtime::component::__internal::InterfaceType,
                    bytes: &[u8],
                ) -> wasmtime::component::__internal::anyhow::Result<Self> {
                    let align = <Self as wasmtime::component::ComponentType>::ALIGN32;
                    if true {
                        if !((bytes.as_ptr() as usize) % (align as usize) == 0) {
                            ::core::panicking::panic(
                                "assertion failed: (bytes.as_ptr() as usize) % (align as usize) == 0",
                            )
                        }
                    }
                    let discrim = bytes[0];
                    let payload_offset = <Self as wasmtime::component::__internal::ComponentVariant>::PAYLOAD_OFFSET32;
                    let payload = &bytes[payload_offset..];
                    let ty = match ty {
                        wasmtime::component::__internal::InterfaceType::Variant(i) => {
                            &cx.types[i]
                        }
                        _ => wasmtime::component::__internal::bad_type_info(),
                    };
                    Ok(
                        match discrim {
                            0u8 => Self::StoreTableFull,
                            1u8 => Self::NoSuchStore,
                            2u8 => Self::AccessDenied,
                            3u8 => Self::InvalidStore,
                            4u8 => Self::NoSuchKey,
                            5u8 => {
                                Self::Io(
                                    <String as wasmtime::component::Lift>::load(
                                        cx,
                                        ty
                                            .cases[5usize]
                                            .ty
                                            .unwrap_or_else(
                                                wasmtime::component::__internal::bad_type_info,
                                            ),
                                        &payload[..<String as wasmtime::component::ComponentType>::SIZE32],
                                    )?,
                                )
                            }
                            discrim => {
                                return ::anyhow::__private::Err(
                                    ::anyhow::Error::msg({
                                        let res = ::alloc::fmt::format(
                                            format_args!("unexpected discriminant: {0}", discrim),
                                        );
                                        res
                                    }),
                                );
                            }
                        },
                    )
                }
            }
            const _: () = {
                #[doc(hidden)]
                #[repr(C)]
                pub struct LowerError<T5: Copy> {
                    tag: wasmtime::ValRaw,
                    payload: LowerPayloadError<T5>,
                }
                #[automatically_derived]
                impl<T5: ::core::clone::Clone + Copy> ::core::clone::Clone
                for LowerError<T5> {
                    #[inline]
                    fn clone(&self) -> LowerError<T5> {
                        LowerError {
                            tag: ::core::clone::Clone::clone(&self.tag),
                            payload: ::core::clone::Clone::clone(&self.payload),
                        }
                    }
                }
                #[automatically_derived]
                impl<T5: ::core::marker::Copy + Copy> ::core::marker::Copy
                for LowerError<T5> {}
                #[doc(hidden)]
                #[allow(non_snake_case)]
                #[repr(C)]
                union LowerPayloadError<T5: Copy> {
                    StoreTableFull: [wasmtime::ValRaw; 0],
                    NoSuchStore: [wasmtime::ValRaw; 0],
                    AccessDenied: [wasmtime::ValRaw; 0],
                    InvalidStore: [wasmtime::ValRaw; 0],
                    NoSuchKey: [wasmtime::ValRaw; 0],
                    Io: T5,
                }
                #[automatically_derived]
                #[allow(non_snake_case)]
                impl<
                    T5: ::core::marker::Copy + ::core::clone::Clone + Copy,
                > ::core::clone::Clone for LowerPayloadError<T5> {
                    #[inline]
                    fn clone(&self) -> LowerPayloadError<T5> {
                        let _: ::core::clone::AssertParamIsCopy<Self>;
                        *self
                    }
                }
                #[automatically_derived]
                #[allow(non_snake_case)]
                impl<T5: ::core::marker::Copy + Copy> ::core::marker::Copy
                for LowerPayloadError<T5> {}
                unsafe impl wasmtime::component::ComponentType for Error {
                    type Lower = LowerError<
                        <String as wasmtime::component::ComponentType>::Lower,
                    >;
                    #[inline]
                    fn typecheck(
                        ty: &wasmtime::component::__internal::InterfaceType,
                        types: &wasmtime::component::__internal::InstanceType<'_>,
                    ) -> wasmtime::component::__internal::anyhow::Result<()> {
                        wasmtime::component::__internal::typecheck_variant(
                            ty,
                            types,
                            &[
                                ("store-table-full", None),
                                ("no-such-store", None),
                                ("access-denied", None),
                                ("invalid-store", None),
                                ("no-such-key", None),
                                (
                                    "io",
                                    Some(
                                        <String as wasmtime::component::ComponentType>::typecheck,
                                    ),
                                ),
                            ],
                        )
                    }
                    const ABI: wasmtime::component::__internal::CanonicalAbiInfo = wasmtime::component::__internal::CanonicalAbiInfo::variant_static(
                        &[
                            None,
                            None,
                            None,
                            None,
                            None,
                            Some(<String as wasmtime::component::ComponentType>::ABI),
                        ],
                    );
                }
                unsafe impl wasmtime::component::__internal::ComponentVariant for Error {
                    const CASES: &'static [Option<
                        wasmtime::component::__internal::CanonicalAbiInfo,
                    >] = &[
                        None,
                        None,
                        None,
                        None,
                        None,
                        Some(<String as wasmtime::component::ComponentType>::ABI),
                    ];
                }
            };
            impl core::fmt::Debug for Error {
                fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
                    match self {
                        Error::StoreTableFull => {
                            f.debug_tuple("Error::StoreTableFull").finish()
                        }
                        Error::NoSuchStore => {
                            f.debug_tuple("Error::NoSuchStore").finish()
                        }
                        Error::AccessDenied => {
                            f.debug_tuple("Error::AccessDenied").finish()
                        }
                        Error::InvalidStore => {
                            f.debug_tuple("Error::InvalidStore").finish()
                        }
                        Error::NoSuchKey => f.debug_tuple("Error::NoSuchKey").finish(),
                        Error::Io(e) => f.debug_tuple("Error::Io").field(e).finish(),
                    }
                }
            }
            impl core::fmt::Display for Error {
                fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
                    f.write_fmt(format_args!("{0:?}", self))
                }
            }
            impl std::error::Error for Error {}
            const _: () = {
                if !(12 == <Error as wasmtime::component::ComponentType>::SIZE32) {
                    ::core::panicking::panic(
                        "assertion failed: 12 == <Error as wasmtime::component::ComponentType>::SIZE32",
                    )
                }
                if !(4 == <Error as wasmtime::component::ComponentType>::ALIGN32) {
                    ::core::panicking::panic(
                        "assertion failed: 4 == <Error as wasmtime::component::ComponentType>::ALIGN32",
                    )
                }
            };
            pub trait Host {
                #[must_use]
                #[allow(clippy::type_complexity, clippy::type_repetition_in_bounds)]
                fn open<'life0, 'async_trait>(
                    &'life0 mut self,
                    name: String,
                ) -> ::core::pin::Pin<
                    Box<
                        dyn ::core::future::Future<
                            Output = wasmtime::Result<Result<Store, Error>>,
                        > + ::core::marker::Send + 'async_trait,
                    >,
                >
                where
                    'life0: 'async_trait,
                    Self: 'async_trait;
                #[must_use]
                #[allow(clippy::type_complexity, clippy::type_repetition_in_bounds)]
                fn get<'life0, 'async_trait>(
                    &'life0 mut self,
                    store: Store,
                    key: String,
                ) -> ::core::pin::Pin<
                    Box<
                        dyn ::core::future::Future<
                            Output = wasmtime::Result<Result<Vec<u8>, Error>>,
                        > + ::core::marker::Send + 'async_trait,
                    >,
                >
                where
                    'life0: 'async_trait,
                    Self: 'async_trait;
                #[must_use]
                #[allow(clippy::type_complexity, clippy::type_repetition_in_bounds)]
                fn set<'life0, 'async_trait>(
                    &'life0 mut self,
                    store: Store,
                    key: String,
                    value: Vec<u8>,
                ) -> ::core::pin::Pin<
                    Box<
                        dyn ::core::future::Future<
                            Output = wasmtime::Result<Result<(), Error>>,
                        > + ::core::marker::Send + 'async_trait,
                    >,
                >
                where
                    'life0: 'async_trait,
                    Self: 'async_trait;
                #[must_use]
                #[allow(clippy::type_complexity, clippy::type_repetition_in_bounds)]
                fn delete<'life0, 'async_trait>(
                    &'life0 mut self,
                    store: Store,
                    key: String,
                ) -> ::core::pin::Pin<
                    Box<
                        dyn ::core::future::Future<
                            Output = wasmtime::Result<Result<(), Error>>,
                        > + ::core::marker::Send + 'async_trait,
                    >,
                >
                where
                    'life0: 'async_trait,
                    Self: 'async_trait;
                #[must_use]
                #[allow(clippy::type_complexity, clippy::type_repetition_in_bounds)]
                fn exists<'life0, 'async_trait>(
                    &'life0 mut self,
                    store: Store,
                    key: String,
                ) -> ::core::pin::Pin<
                    Box<
                        dyn ::core::future::Future<
                            Output = wasmtime::Result<Result<bool, Error>>,
                        > + ::core::marker::Send + 'async_trait,
                    >,
                >
                where
                    'life0: 'async_trait,
                    Self: 'async_trait;
                #[must_use]
                #[allow(clippy::type_complexity, clippy::type_repetition_in_bounds)]
                fn get_keys<'life0, 'async_trait>(
                    &'life0 mut self,
                    store: Store,
                ) -> ::core::pin::Pin<
                    Box<
                        dyn ::core::future::Future<
                            Output = wasmtime::Result<Result<Vec<String>, Error>>,
                        > + ::core::marker::Send + 'async_trait,
                    >,
                >
                where
                    'life0: 'async_trait,
                    Self: 'async_trait;
                #[must_use]
                #[allow(clippy::type_complexity, clippy::type_repetition_in_bounds)]
                fn close<'life0, 'async_trait>(
                    &'life0 mut self,
                    store: Store,
                ) -> ::core::pin::Pin<
                    Box<
                        dyn ::core::future::Future<
                            Output = wasmtime::Result<()>,
                        > + ::core::marker::Send + 'async_trait,
                    >,
                >
                where
                    'life0: 'async_trait,
                    Self: 'async_trait;
            }
            pub fn add_to_linker<T, U>(
                linker: &mut wasmtime::component::Linker<T>,
                get: impl Fn(&mut T) -> &mut U + Send + Sync + Copy + 'static,
            ) -> wasmtime::Result<()>
            where
                T: Send,
                U: Host + Send,
            {
                let mut inst = linker.instance("fermyon:spin/key-value")?;
                inst.func_wrap_async(
                    "open",
                    move |
                        mut caller: wasmtime::StoreContextMut<'_, T>,
                        (arg0,): (String,)|
                    Box::new(async move {
                        let host = get(caller.data_mut());
                        let r = Host::open(host, arg0).await;
                        Ok((r?,))
                    }),
                )?;
                inst.func_wrap_async(
                    "get",
                    move |
                        mut caller: wasmtime::StoreContextMut<'_, T>,
                        (arg0, arg1): (Store, String)|
                    Box::new(async move {
                        let host = get(caller.data_mut());
                        let r = Host::get(host, arg0, arg1).await;
                        Ok((r?,))
                    }),
                )?;
                inst.func_wrap_async(
                    "set",
                    move |
                        mut caller: wasmtime::StoreContextMut<'_, T>,
                        (arg0, arg1, arg2): (Store, String, Vec<u8>)|
                    Box::new(async move {
                        let host = get(caller.data_mut());
                        let r = Host::set(host, arg0, arg1, arg2).await;
                        Ok((r?,))
                    }),
                )?;
                inst.func_wrap_async(
                    "delete",
                    move |
                        mut caller: wasmtime::StoreContextMut<'_, T>,
                        (arg0, arg1): (Store, String)|
                    Box::new(async move {
                        let host = get(caller.data_mut());
                        let r = Host::delete(host, arg0, arg1).await;
                        Ok((r?,))
                    }),
                )?;
                inst.func_wrap_async(
                    "exists",
                    move |
                        mut caller: wasmtime::StoreContextMut<'_, T>,
                        (arg0, arg1): (Store, String)|
                    Box::new(async move {
                        let host = get(caller.data_mut());
                        let r = Host::exists(host, arg0, arg1).await;
                        Ok((r?,))
                    }),
                )?;
                inst.func_wrap_async(
                    "get-keys",
                    move |
                        mut caller: wasmtime::StoreContextMut<'_, T>,
                        (arg0,): (Store,)|
                    Box::new(async move {
                        let host = get(caller.data_mut());
                        let r = Host::get_keys(host, arg0).await;
                        Ok((r?,))
                    }),
                )?;
                inst.func_wrap_async(
                    "close",
                    move |
                        mut caller: wasmtime::StoreContextMut<'_, T>,
                        (arg0,): (Store,)|
                    Box::new(async move {
                        let host = get(caller.data_mut());
                        let r = Host::close(host, arg0).await;
                        r
                    }),
                )?;
                Ok(())
            }
        }
        #[allow(clippy::all)]
        pub mod llm {
            #[allow(unused_imports)]
            use wasmtime::component::__internal::anyhow;
            /// A Large Language Model.
            pub type InferencingModel = String;
            const _: () = {
                if !(8
                    == <InferencingModel as wasmtime::component::ComponentType>::SIZE32)
                {
                    ::core::panicking::panic(
                        "assertion failed: 8 == <InferencingModel as wasmtime::component::ComponentType>::SIZE32",
                    )
                }
                if !(4
                    == <InferencingModel as wasmtime::component::ComponentType>::ALIGN32)
                {
                    ::core::panicking::panic(
                        "assertion failed: 4 == <InferencingModel as wasmtime::component::ComponentType>::ALIGN32",
                    )
                }
            };
            /// Inference request parameters
            #[component(record)]
            pub struct InferencingParams {
                /// The maximum tokens that should be inferred.
                ///
                /// Note: the backing implementation may return less tokens.
                #[component(name = "max-tokens")]
                pub max_tokens: u32,
                /// The amount the model should avoid repeating tokens.
                #[component(name = "repeat-penalty")]
                pub repeat_penalty: f32,
                /// The number of tokens the model should apply the repeat penalty to.
                #[component(name = "repeat-penalty-last-n-token-count")]
                pub repeat_penalty_last_n_token_count: u32,
                /// The randomness with which the next token is selected.
                #[component(name = "temperature")]
                pub temperature: f32,
                /// The number of possible next tokens the model will choose from.
                #[component(name = "top-k")]
                pub top_k: u32,
                /// The probability total of next tokens the model will choose from.
                #[component(name = "top-p")]
                pub top_p: f32,
            }
            #[automatically_derived]
            impl ::core::marker::Copy for InferencingParams {}
            #[automatically_derived]
            impl ::core::clone::Clone for InferencingParams {
                #[inline]
                fn clone(&self) -> InferencingParams {
                    let _: ::core::clone::AssertParamIsClone<u32>;
                    let _: ::core::clone::AssertParamIsClone<f32>;
                    *self
                }
            }
            unsafe impl wasmtime::component::Lower for InferencingParams {
                #[inline]
                fn lower<T>(
                    &self,
                    cx: &mut wasmtime::component::__internal::LowerContext<'_, T>,
                    ty: wasmtime::component::__internal::InterfaceType,
                    dst: &mut std::mem::MaybeUninit<Self::Lower>,
                ) -> wasmtime::component::__internal::anyhow::Result<()> {
                    let ty = match ty {
                        wasmtime::component::__internal::InterfaceType::Record(i) => {
                            &cx.types[i]
                        }
                        _ => wasmtime::component::__internal::bad_type_info(),
                    };
                    wasmtime::component::Lower::lower(
                        &self.max_tokens,
                        cx,
                        ty.fields[0usize].ty,
                        {
                            #[allow(unused_unsafe)]
                            {
                                unsafe {
                                    use ::wasmtime::component::__internal::MaybeUninitExt;
                                    let m: &mut std::mem::MaybeUninit<_> = dst;
                                    m.map(|p| &raw mut (*p).max_tokens)
                                }
                            }
                        },
                    )?;
                    wasmtime::component::Lower::lower(
                        &self.repeat_penalty,
                        cx,
                        ty.fields[1usize].ty,
                        {
                            #[allow(unused_unsafe)]
                            {
                                unsafe {
                                    use ::wasmtime::component::__internal::MaybeUninitExt;
                                    let m: &mut std::mem::MaybeUninit<_> = dst;
                                    m.map(|p| &raw mut (*p).repeat_penalty)
                                }
                            }
                        },
                    )?;
                    wasmtime::component::Lower::lower(
                        &self.repeat_penalty_last_n_token_count,
                        cx,
                        ty.fields[2usize].ty,
                        {
                            #[allow(unused_unsafe)]
                            {
                                unsafe {
                                    use ::wasmtime::component::__internal::MaybeUninitExt;
                                    let m: &mut std::mem::MaybeUninit<_> = dst;
                                    m.map(|p| &raw mut (*p).repeat_penalty_last_n_token_count)
                                }
                            }
                        },
                    )?;
                    wasmtime::component::Lower::lower(
                        &self.temperature,
                        cx,
                        ty.fields[3usize].ty,
                        {
                            #[allow(unused_unsafe)]
                            {
                                unsafe {
                                    use ::wasmtime::component::__internal::MaybeUninitExt;
                                    let m: &mut std::mem::MaybeUninit<_> = dst;
                                    m.map(|p| &raw mut (*p).temperature)
                                }
                            }
                        },
                    )?;
                    wasmtime::component::Lower::lower(
                        &self.top_k,
                        cx,
                        ty.fields[4usize].ty,
                        {
                            #[allow(unused_unsafe)]
                            {
                                unsafe {
                                    use ::wasmtime::component::__internal::MaybeUninitExt;
                                    let m: &mut std::mem::MaybeUninit<_> = dst;
                                    m.map(|p| &raw mut (*p).top_k)
                                }
                            }
                        },
                    )?;
                    wasmtime::component::Lower::lower(
                        &self.top_p,
                        cx,
                        ty.fields[5usize].ty,
                        {
                            #[allow(unused_unsafe)]
                            {
                                unsafe {
                                    use ::wasmtime::component::__internal::MaybeUninitExt;
                                    let m: &mut std::mem::MaybeUninit<_> = dst;
                                    m.map(|p| &raw mut (*p).top_p)
                                }
                            }
                        },
                    )?;
                    Ok(())
                }
                #[inline]
                fn store<T>(
                    &self,
                    cx: &mut wasmtime::component::__internal::LowerContext<'_, T>,
                    ty: wasmtime::component::__internal::InterfaceType,
                    mut offset: usize,
                ) -> wasmtime::component::__internal::anyhow::Result<()> {
                    if true {
                        if !(offset
                            % (<Self as wasmtime::component::ComponentType>::ALIGN32
                                as usize) == 0)
                        {
                            ::core::panicking::panic(
                                "assertion failed: offset % (<Self as wasmtime::component::ComponentType>::ALIGN32 as usize) == 0",
                            )
                        }
                    }
                    let ty = match ty {
                        wasmtime::component::__internal::InterfaceType::Record(i) => {
                            &cx.types[i]
                        }
                        _ => wasmtime::component::__internal::bad_type_info(),
                    };
                    wasmtime::component::Lower::store(
                        &self.max_tokens,
                        cx,
                        ty.fields[0usize].ty,
                        <u32 as wasmtime::component::ComponentType>::ABI
                            .next_field32_size(&mut offset),
                    )?;
                    wasmtime::component::Lower::store(
                        &self.repeat_penalty,
                        cx,
                        ty.fields[1usize].ty,
                        <f32 as wasmtime::component::ComponentType>::ABI
                            .next_field32_size(&mut offset),
                    )?;
                    wasmtime::component::Lower::store(
                        &self.repeat_penalty_last_n_token_count,
                        cx,
                        ty.fields[2usize].ty,
                        <u32 as wasmtime::component::ComponentType>::ABI
                            .next_field32_size(&mut offset),
                    )?;
                    wasmtime::component::Lower::store(
                        &self.temperature,
                        cx,
                        ty.fields[3usize].ty,
                        <f32 as wasmtime::component::ComponentType>::ABI
                            .next_field32_size(&mut offset),
                    )?;
                    wasmtime::component::Lower::store(
                        &self.top_k,
                        cx,
                        ty.fields[4usize].ty,
                        <u32 as wasmtime::component::ComponentType>::ABI
                            .next_field32_size(&mut offset),
                    )?;
                    wasmtime::component::Lower::store(
                        &self.top_p,
                        cx,
                        ty.fields[5usize].ty,
                        <f32 as wasmtime::component::ComponentType>::ABI
                            .next_field32_size(&mut offset),
                    )?;
                    Ok(())
                }
            }
            unsafe impl wasmtime::component::Lift for InferencingParams {
                #[inline]
                fn lift(
                    cx: &mut wasmtime::component::__internal::LiftContext<'_>,
                    ty: wasmtime::component::__internal::InterfaceType,
                    src: &Self::Lower,
                ) -> wasmtime::component::__internal::anyhow::Result<Self> {
                    let ty = match ty {
                        wasmtime::component::__internal::InterfaceType::Record(i) => {
                            &cx.types[i]
                        }
                        _ => wasmtime::component::__internal::bad_type_info(),
                    };
                    Ok(Self {
                        max_tokens: <u32 as wasmtime::component::Lift>::lift(
                            cx,
                            ty.fields[0usize].ty,
                            &src.max_tokens,
                        )?,
                        repeat_penalty: <f32 as wasmtime::component::Lift>::lift(
                            cx,
                            ty.fields[1usize].ty,
                            &src.repeat_penalty,
                        )?,
                        repeat_penalty_last_n_token_count: <u32 as wasmtime::component::Lift>::lift(
                            cx,
                            ty.fields[2usize].ty,
                            &src.repeat_penalty_last_n_token_count,
                        )?,
                        temperature: <f32 as wasmtime::component::Lift>::lift(
                            cx,
                            ty.fields[3usize].ty,
                            &src.temperature,
                        )?,
                        top_k: <u32 as wasmtime::component::Lift>::lift(
                            cx,
                            ty.fields[4usize].ty,
                            &src.top_k,
                        )?,
                        top_p: <f32 as wasmtime::component::Lift>::lift(
                            cx,
                            ty.fields[5usize].ty,
                            &src.top_p,
                        )?,
                    })
                }
                #[inline]
                fn load(
                    cx: &mut wasmtime::component::__internal::LiftContext<'_>,
                    ty: wasmtime::component::__internal::InterfaceType,
                    bytes: &[u8],
                ) -> wasmtime::component::__internal::anyhow::Result<Self> {
                    let ty = match ty {
                        wasmtime::component::__internal::InterfaceType::Record(i) => {
                            &cx.types[i]
                        }
                        _ => wasmtime::component::__internal::bad_type_info(),
                    };
                    if true {
                        if !((bytes.as_ptr() as usize)
                            % (<Self as wasmtime::component::ComponentType>::ALIGN32
                                as usize) == 0)
                        {
                            ::core::panicking::panic(
                                "assertion failed: (bytes.as_ptr() as usize) %\\n        (<Self as wasmtime::component::ComponentType>::ALIGN32 as usize) == 0",
                            )
                        }
                    }
                    let mut offset = 0;
                    Ok(Self {
                        max_tokens: <u32 as wasmtime::component::Lift>::load(
                            cx,
                            ty.fields[0usize].ty,
                            &bytes[<u32 as wasmtime::component::ComponentType>::ABI
                                .next_field32_size(
                                    &mut offset,
                                )..][..<u32 as wasmtime::component::ComponentType>::SIZE32],
                        )?,
                        repeat_penalty: <f32 as wasmtime::component::Lift>::load(
                            cx,
                            ty.fields[1usize].ty,
                            &bytes[<f32 as wasmtime::component::ComponentType>::ABI
                                .next_field32_size(
                                    &mut offset,
                                )..][..<f32 as wasmtime::component::ComponentType>::SIZE32],
                        )?,
                        repeat_penalty_last_n_token_count: <u32 as wasmtime::component::Lift>::load(
                            cx,
                            ty.fields[2usize].ty,
                            &bytes[<u32 as wasmtime::component::ComponentType>::ABI
                                .next_field32_size(
                                    &mut offset,
                                )..][..<u32 as wasmtime::component::ComponentType>::SIZE32],
                        )?,
                        temperature: <f32 as wasmtime::component::Lift>::load(
                            cx,
                            ty.fields[3usize].ty,
                            &bytes[<f32 as wasmtime::component::ComponentType>::ABI
                                .next_field32_size(
                                    &mut offset,
                                )..][..<f32 as wasmtime::component::ComponentType>::SIZE32],
                        )?,
                        top_k: <u32 as wasmtime::component::Lift>::load(
                            cx,
                            ty.fields[4usize].ty,
                            &bytes[<u32 as wasmtime::component::ComponentType>::ABI
                                .next_field32_size(
                                    &mut offset,
                                )..][..<u32 as wasmtime::component::ComponentType>::SIZE32],
                        )?,
                        top_p: <f32 as wasmtime::component::Lift>::load(
                            cx,
                            ty.fields[5usize].ty,
                            &bytes[<f32 as wasmtime::component::ComponentType>::ABI
                                .next_field32_size(
                                    &mut offset,
                                )..][..<f32 as wasmtime::component::ComponentType>::SIZE32],
                        )?,
                    })
                }
            }
            const _: () = {
                #[doc(hidden)]
                #[repr(C)]
                pub struct LowerInferencingParams<
                    T0: Copy,
                    T1: Copy,
                    T2: Copy,
                    T3: Copy,
                    T4: Copy,
                    T5: Copy,
                > {
                    max_tokens: T0,
                    repeat_penalty: T1,
                    repeat_penalty_last_n_token_count: T2,
                    temperature: T3,
                    top_k: T4,
                    top_p: T5,
                    _align: [wasmtime::ValRaw; 0],
                }
                #[automatically_derived]
                impl<
                    T0: ::core::clone::Clone + Copy,
                    T1: ::core::clone::Clone + Copy,
                    T2: ::core::clone::Clone + Copy,
                    T3: ::core::clone::Clone + Copy,
                    T4: ::core::clone::Clone + Copy,
                    T5: ::core::clone::Clone + Copy,
                > ::core::clone::Clone
                for LowerInferencingParams<T0, T1, T2, T3, T4, T5> {
                    #[inline]
                    fn clone(&self) -> LowerInferencingParams<T0, T1, T2, T3, T4, T5> {
                        LowerInferencingParams {
                            max_tokens: ::core::clone::Clone::clone(&self.max_tokens),
                            repeat_penalty: ::core::clone::Clone::clone(
                                &self.repeat_penalty,
                            ),
                            repeat_penalty_last_n_token_count: ::core::clone::Clone::clone(
                                &self.repeat_penalty_last_n_token_count,
                            ),
                            temperature: ::core::clone::Clone::clone(&self.temperature),
                            top_k: ::core::clone::Clone::clone(&self.top_k),
                            top_p: ::core::clone::Clone::clone(&self.top_p),
                            _align: ::core::clone::Clone::clone(&self._align),
                        }
                    }
                }
                #[automatically_derived]
                impl<
                    T0: ::core::marker::Copy + Copy,
                    T1: ::core::marker::Copy + Copy,
                    T2: ::core::marker::Copy + Copy,
                    T3: ::core::marker::Copy + Copy,
                    T4: ::core::marker::Copy + Copy,
                    T5: ::core::marker::Copy + Copy,
                > ::core::marker::Copy
                for LowerInferencingParams<T0, T1, T2, T3, T4, T5> {}
                unsafe impl wasmtime::component::ComponentType for InferencingParams {
                    type Lower = LowerInferencingParams<
                        <u32 as wasmtime::component::ComponentType>::Lower,
                        <f32 as wasmtime::component::ComponentType>::Lower,
                        <u32 as wasmtime::component::ComponentType>::Lower,
                        <f32 as wasmtime::component::ComponentType>::Lower,
                        <u32 as wasmtime::component::ComponentType>::Lower,
                        <f32 as wasmtime::component::ComponentType>::Lower,
                    >;
                    const ABI: wasmtime::component::__internal::CanonicalAbiInfo = wasmtime::component::__internal::CanonicalAbiInfo::record_static(
                        &[
                            <u32 as wasmtime::component::ComponentType>::ABI,
                            <f32 as wasmtime::component::ComponentType>::ABI,
                            <u32 as wasmtime::component::ComponentType>::ABI,
                            <f32 as wasmtime::component::ComponentType>::ABI,
                            <u32 as wasmtime::component::ComponentType>::ABI,
                            <f32 as wasmtime::component::ComponentType>::ABI,
                        ],
                    );
                    #[inline]
                    fn typecheck(
                        ty: &wasmtime::component::__internal::InterfaceType,
                        types: &wasmtime::component::__internal::InstanceType<'_>,
                    ) -> wasmtime::component::__internal::anyhow::Result<()> {
                        wasmtime::component::__internal::typecheck_record(
                            ty,
                            types,
                            &[
                                (
                                    "max-tokens",
                                    <u32 as wasmtime::component::ComponentType>::typecheck,
                                ),
                                (
                                    "repeat-penalty",
                                    <f32 as wasmtime::component::ComponentType>::typecheck,
                                ),
                                (
                                    "repeat-penalty-last-n-token-count",
                                    <u32 as wasmtime::component::ComponentType>::typecheck,
                                ),
                                (
                                    "temperature",
                                    <f32 as wasmtime::component::ComponentType>::typecheck,
                                ),
                                (
                                    "top-k",
                                    <u32 as wasmtime::component::ComponentType>::typecheck,
                                ),
                                (
                                    "top-p",
                                    <f32 as wasmtime::component::ComponentType>::typecheck,
                                ),
                            ],
                        )
                    }
                }
            };
            impl core::fmt::Debug for InferencingParams {
                fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
                    f.debug_struct("InferencingParams")
                        .field("max-tokens", &self.max_tokens)
                        .field("repeat-penalty", &self.repeat_penalty)
                        .field(
                            "repeat-penalty-last-n-token-count",
                            &self.repeat_penalty_last_n_token_count,
                        )
                        .field("temperature", &self.temperature)
                        .field("top-k", &self.top_k)
                        .field("top-p", &self.top_p)
                        .finish()
                }
            }
            const _: () = {
                if !(24
                    == <InferencingParams as wasmtime::component::ComponentType>::SIZE32)
                {
                    ::core::panicking::panic(
                        "assertion failed: 24 == <InferencingParams as wasmtime::component::ComponentType>::SIZE32",
                    )
                }
                if !(4
                    == <InferencingParams as wasmtime::component::ComponentType>::ALIGN32)
                {
                    ::core::panicking::panic(
                        "assertion failed: 4 == <InferencingParams as wasmtime::component::ComponentType>::ALIGN32",
                    )
                }
            };
            /// The set of errors which may be raised by functions in this interface
            #[component(variant)]
            pub enum Error {
                #[component(name = "model-not-supported")]
                ModelNotSupported,
                #[component(name = "runtime-error")]
                RuntimeError(String),
                #[component(name = "invalid-input")]
                InvalidInput(String),
            }
            #[automatically_derived]
            impl ::core::clone::Clone for Error {
                #[inline]
                fn clone(&self) -> Error {
                    match self {
                        Error::ModelNotSupported => Error::ModelNotSupported,
                        Error::RuntimeError(__self_0) => {
                            Error::RuntimeError(::core::clone::Clone::clone(__self_0))
                        }
                        Error::InvalidInput(__self_0) => {
                            Error::InvalidInput(::core::clone::Clone::clone(__self_0))
                        }
                    }
                }
            }
            unsafe impl wasmtime::component::Lower for Error {
                #[inline]
                fn lower<T>(
                    &self,
                    cx: &mut wasmtime::component::__internal::LowerContext<'_, T>,
                    ty: wasmtime::component::__internal::InterfaceType,
                    dst: &mut std::mem::MaybeUninit<Self::Lower>,
                ) -> wasmtime::component::__internal::anyhow::Result<()> {
                    let ty = match ty {
                        wasmtime::component::__internal::InterfaceType::Variant(i) => {
                            &cx.types[i]
                        }
                        _ => wasmtime::component::__internal::bad_type_info(),
                    };
                    match self {
                        Self::ModelNotSupported => {
                            {
                                #[allow(unused_unsafe)]
                                {
                                    unsafe {
                                        use ::wasmtime::component::__internal::MaybeUninitExt;
                                        let m: &mut std::mem::MaybeUninit<_> = dst;
                                        m.map(|p| &raw mut (*p).tag)
                                    }
                                }
                            }
                                .write(wasmtime::ValRaw::u32(0u32));
                            unsafe {
                                wasmtime::component::__internal::lower_payload(
                                    {
                                        #[allow(unused_unsafe)]
                                        {
                                            unsafe {
                                                use ::wasmtime::component::__internal::MaybeUninitExt;
                                                let m: &mut std::mem::MaybeUninit<_> = dst;
                                                m.map(|p| &raw mut (*p).payload)
                                            }
                                        }
                                    },
                                    |payload| {
                                        #[allow(unused_unsafe)]
                                        {
                                            unsafe {
                                                use ::wasmtime::component::__internal::MaybeUninitExt;
                                                let m: &mut std::mem::MaybeUninit<_> = payload;
                                                m.map(|p| &raw mut (*p).ModelNotSupported)
                                            }
                                        }
                                    },
                                    |dst| Ok(()),
                                )
                            }
                        }
                        Self::RuntimeError(value) => {
                            {
                                #[allow(unused_unsafe)]
                                {
                                    unsafe {
                                        use ::wasmtime::component::__internal::MaybeUninitExt;
                                        let m: &mut std::mem::MaybeUninit<_> = dst;
                                        m.map(|p| &raw mut (*p).tag)
                                    }
                                }
                            }
                                .write(wasmtime::ValRaw::u32(1u32));
                            unsafe {
                                wasmtime::component::__internal::lower_payload(
                                    {
                                        #[allow(unused_unsafe)]
                                        {
                                            unsafe {
                                                use ::wasmtime::component::__internal::MaybeUninitExt;
                                                let m: &mut std::mem::MaybeUninit<_> = dst;
                                                m.map(|p| &raw mut (*p).payload)
                                            }
                                        }
                                    },
                                    |payload| {
                                        #[allow(unused_unsafe)]
                                        {
                                            unsafe {
                                                use ::wasmtime::component::__internal::MaybeUninitExt;
                                                let m: &mut std::mem::MaybeUninit<_> = payload;
                                                m.map(|p| &raw mut (*p).RuntimeError)
                                            }
                                        }
                                    },
                                    |dst| {
                                        value
                                            .lower(
                                                cx,
                                                ty
                                                    .cases[1usize]
                                                    .ty
                                                    .unwrap_or_else(
                                                        wasmtime::component::__internal::bad_type_info,
                                                    ),
                                                dst,
                                            )
                                    },
                                )
                            }
                        }
                        Self::InvalidInput(value) => {
                            {
                                #[allow(unused_unsafe)]
                                {
                                    unsafe {
                                        use ::wasmtime::component::__internal::MaybeUninitExt;
                                        let m: &mut std::mem::MaybeUninit<_> = dst;
                                        m.map(|p| &raw mut (*p).tag)
                                    }
                                }
                            }
                                .write(wasmtime::ValRaw::u32(2u32));
                            unsafe {
                                wasmtime::component::__internal::lower_payload(
                                    {
                                        #[allow(unused_unsafe)]
                                        {
                                            unsafe {
                                                use ::wasmtime::component::__internal::MaybeUninitExt;
                                                let m: &mut std::mem::MaybeUninit<_> = dst;
                                                m.map(|p| &raw mut (*p).payload)
                                            }
                                        }
                                    },
                                    |payload| {
                                        #[allow(unused_unsafe)]
                                        {
                                            unsafe {
                                                use ::wasmtime::component::__internal::MaybeUninitExt;
                                                let m: &mut std::mem::MaybeUninit<_> = payload;
                                                m.map(|p| &raw mut (*p).InvalidInput)
                                            }
                                        }
                                    },
                                    |dst| {
                                        value
                                            .lower(
                                                cx,
                                                ty
                                                    .cases[2usize]
                                                    .ty
                                                    .unwrap_or_else(
                                                        wasmtime::component::__internal::bad_type_info,
                                                    ),
                                                dst,
                                            )
                                    },
                                )
                            }
                        }
                    }
                }
                #[inline]
                fn store<T>(
                    &self,
                    cx: &mut wasmtime::component::__internal::LowerContext<'_, T>,
                    ty: wasmtime::component::__internal::InterfaceType,
                    mut offset: usize,
                ) -> wasmtime::component::__internal::anyhow::Result<()> {
                    let ty = match ty {
                        wasmtime::component::__internal::InterfaceType::Variant(i) => {
                            &cx.types[i]
                        }
                        _ => wasmtime::component::__internal::bad_type_info(),
                    };
                    if true {
                        if !(offset
                            % (<Self as wasmtime::component::ComponentType>::ALIGN32
                                as usize) == 0)
                        {
                            ::core::panicking::panic(
                                "assertion failed: offset % (<Self as wasmtime::component::ComponentType>::ALIGN32 as usize) == 0",
                            )
                        }
                    }
                    match self {
                        Self::ModelNotSupported => {
                            *cx.get::<1usize>(offset) = 0u8.to_le_bytes();
                            Ok(())
                        }
                        Self::RuntimeError(value) => {
                            *cx.get::<1usize>(offset) = 1u8.to_le_bytes();
                            value
                                .store(
                                    cx,
                                    ty
                                        .cases[1usize]
                                        .ty
                                        .unwrap_or_else(
                                            wasmtime::component::__internal::bad_type_info,
                                        ),
                                    offset
                                        + <Self as wasmtime::component::__internal::ComponentVariant>::PAYLOAD_OFFSET32,
                                )
                        }
                        Self::InvalidInput(value) => {
                            *cx.get::<1usize>(offset) = 2u8.to_le_bytes();
                            value
                                .store(
                                    cx,
                                    ty
                                        .cases[2usize]
                                        .ty
                                        .unwrap_or_else(
                                            wasmtime::component::__internal::bad_type_info,
                                        ),
                                    offset
                                        + <Self as wasmtime::component::__internal::ComponentVariant>::PAYLOAD_OFFSET32,
                                )
                        }
                    }
                }
            }
            unsafe impl wasmtime::component::Lift for Error {
                #[inline]
                fn lift(
                    cx: &mut wasmtime::component::__internal::LiftContext<'_>,
                    ty: wasmtime::component::__internal::InterfaceType,
                    src: &Self::Lower,
                ) -> wasmtime::component::__internal::anyhow::Result<Self> {
                    let ty = match ty {
                        wasmtime::component::__internal::InterfaceType::Variant(i) => {
                            &cx.types[i]
                        }
                        _ => wasmtime::component::__internal::bad_type_info(),
                    };
                    Ok(
                        match src.tag.get_u32() {
                            0u32 => Self::ModelNotSupported,
                            1u32 => {
                                Self::RuntimeError(
                                    <String as wasmtime::component::Lift>::lift(
                                        cx,
                                        ty
                                            .cases[1usize]
                                            .ty
                                            .unwrap_or_else(
                                                wasmtime::component::__internal::bad_type_info,
                                            ),
                                        unsafe { &src.payload.RuntimeError },
                                    )?,
                                )
                            }
                            2u32 => {
                                Self::InvalidInput(
                                    <String as wasmtime::component::Lift>::lift(
                                        cx,
                                        ty
                                            .cases[2usize]
                                            .ty
                                            .unwrap_or_else(
                                                wasmtime::component::__internal::bad_type_info,
                                            ),
                                        unsafe { &src.payload.InvalidInput },
                                    )?,
                                )
                            }
                            discrim => {
                                return ::anyhow::__private::Err(
                                    ::anyhow::Error::msg({
                                        let res = ::alloc::fmt::format(
                                            format_args!("unexpected discriminant: {0}", discrim),
                                        );
                                        res
                                    }),
                                );
                            }
                        },
                    )
                }
                #[inline]
                fn load(
                    cx: &mut wasmtime::component::__internal::LiftContext<'_>,
                    ty: wasmtime::component::__internal::InterfaceType,
                    bytes: &[u8],
                ) -> wasmtime::component::__internal::anyhow::Result<Self> {
                    let align = <Self as wasmtime::component::ComponentType>::ALIGN32;
                    if true {
                        if !((bytes.as_ptr() as usize) % (align as usize) == 0) {
                            ::core::panicking::panic(
                                "assertion failed: (bytes.as_ptr() as usize) % (align as usize) == 0",
                            )
                        }
                    }
                    let discrim = bytes[0];
                    let payload_offset = <Self as wasmtime::component::__internal::ComponentVariant>::PAYLOAD_OFFSET32;
                    let payload = &bytes[payload_offset..];
                    let ty = match ty {
                        wasmtime::component::__internal::InterfaceType::Variant(i) => {
                            &cx.types[i]
                        }
                        _ => wasmtime::component::__internal::bad_type_info(),
                    };
                    Ok(
                        match discrim {
                            0u8 => Self::ModelNotSupported,
                            1u8 => {
                                Self::RuntimeError(
                                    <String as wasmtime::component::Lift>::load(
                                        cx,
                                        ty
                                            .cases[1usize]
                                            .ty
                                            .unwrap_or_else(
                                                wasmtime::component::__internal::bad_type_info,
                                            ),
                                        &payload[..<String as wasmtime::component::ComponentType>::SIZE32],
                                    )?,
                                )
                            }
                            2u8 => {
                                Self::InvalidInput(
                                    <String as wasmtime::component::Lift>::load(
                                        cx,
                                        ty
                                            .cases[2usize]
                                            .ty
                                            .unwrap_or_else(
                                                wasmtime::component::__internal::bad_type_info,
                                            ),
                                        &payload[..<String as wasmtime::component::ComponentType>::SIZE32],
                                    )?,
                                )
                            }
                            discrim => {
                                return ::anyhow::__private::Err(
                                    ::anyhow::Error::msg({
                                        let res = ::alloc::fmt::format(
                                            format_args!("unexpected discriminant: {0}", discrim),
                                        );
                                        res
                                    }),
                                );
                            }
                        },
                    )
                }
            }
            const _: () = {
                #[doc(hidden)]
                #[repr(C)]
                pub struct LowerError<T1: Copy, T2: Copy> {
                    tag: wasmtime::ValRaw,
                    payload: LowerPayloadError<T1, T2>,
                }
                #[automatically_derived]
                impl<
                    T1: ::core::clone::Clone + Copy,
                    T2: ::core::clone::Clone + Copy,
                > ::core::clone::Clone for LowerError<T1, T2> {
                    #[inline]
                    fn clone(&self) -> LowerError<T1, T2> {
                        LowerError {
                            tag: ::core::clone::Clone::clone(&self.tag),
                            payload: ::core::clone::Clone::clone(&self.payload),
                        }
                    }
                }
                #[automatically_derived]
                impl<
                    T1: ::core::marker::Copy + Copy,
                    T2: ::core::marker::Copy + Copy,
                > ::core::marker::Copy for LowerError<T1, T2> {}
                #[doc(hidden)]
                #[allow(non_snake_case)]
                #[repr(C)]
                union LowerPayloadError<T1: Copy, T2: Copy> {
                    ModelNotSupported: [wasmtime::ValRaw; 0],
                    RuntimeError: T1,
                    InvalidInput: T2,
                }
                #[automatically_derived]
                #[allow(non_snake_case)]
                impl<
                    T1: ::core::marker::Copy + ::core::clone::Clone + Copy,
                    T2: ::core::marker::Copy + ::core::clone::Clone + Copy,
                > ::core::clone::Clone for LowerPayloadError<T1, T2> {
                    #[inline]
                    fn clone(&self) -> LowerPayloadError<T1, T2> {
                        let _: ::core::clone::AssertParamIsCopy<Self>;
                        *self
                    }
                }
                #[automatically_derived]
                #[allow(non_snake_case)]
                impl<
                    T1: ::core::marker::Copy + Copy,
                    T2: ::core::marker::Copy + Copy,
                > ::core::marker::Copy for LowerPayloadError<T1, T2> {}
                unsafe impl wasmtime::component::ComponentType for Error {
                    type Lower = LowerError<
                        <String as wasmtime::component::ComponentType>::Lower,
                        <String as wasmtime::component::ComponentType>::Lower,
                    >;
                    #[inline]
                    fn typecheck(
                        ty: &wasmtime::component::__internal::InterfaceType,
                        types: &wasmtime::component::__internal::InstanceType<'_>,
                    ) -> wasmtime::component::__internal::anyhow::Result<()> {
                        wasmtime::component::__internal::typecheck_variant(
                            ty,
                            types,
                            &[
                                ("model-not-supported", None),
                                (
                                    "runtime-error",
                                    Some(
                                        <String as wasmtime::component::ComponentType>::typecheck,
                                    ),
                                ),
                                (
                                    "invalid-input",
                                    Some(
                                        <String as wasmtime::component::ComponentType>::typecheck,
                                    ),
                                ),
                            ],
                        )
                    }
                    const ABI: wasmtime::component::__internal::CanonicalAbiInfo = wasmtime::component::__internal::CanonicalAbiInfo::variant_static(
                        &[
                            None,
                            Some(<String as wasmtime::component::ComponentType>::ABI),
                            Some(<String as wasmtime::component::ComponentType>::ABI),
                        ],
                    );
                }
                unsafe impl wasmtime::component::__internal::ComponentVariant for Error {
                    const CASES: &'static [Option<
                        wasmtime::component::__internal::CanonicalAbiInfo,
                    >] = &[
                        None,
                        Some(<String as wasmtime::component::ComponentType>::ABI),
                        Some(<String as wasmtime::component::ComponentType>::ABI),
                    ];
                }
            };
            impl core::fmt::Debug for Error {
                fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
                    match self {
                        Error::ModelNotSupported => {
                            f.debug_tuple("Error::ModelNotSupported").finish()
                        }
                        Error::RuntimeError(e) => {
                            f.debug_tuple("Error::RuntimeError").field(e).finish()
                        }
                        Error::InvalidInput(e) => {
                            f.debug_tuple("Error::InvalidInput").field(e).finish()
                        }
                    }
                }
            }
            impl core::fmt::Display for Error {
                fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
                    f.write_fmt(format_args!("{0:?}", self))
                }
            }
            impl std::error::Error for Error {}
            const _: () = {
                if !(12 == <Error as wasmtime::component::ComponentType>::SIZE32) {
                    ::core::panicking::panic(
                        "assertion failed: 12 == <Error as wasmtime::component::ComponentType>::SIZE32",
                    )
                }
                if !(4 == <Error as wasmtime::component::ComponentType>::ALIGN32) {
                    ::core::panicking::panic(
                        "assertion failed: 4 == <Error as wasmtime::component::ComponentType>::ALIGN32",
                    )
                }
            };
            /// Usage information related to the inferencing result
            #[component(record)]
            pub struct InferencingUsage {
                /// Number of tokens in the prompt
                #[component(name = "prompt-token-count")]
                pub prompt_token_count: u32,
                /// Number of tokens generated by the inferencing operation
                #[component(name = "generated-token-count")]
                pub generated_token_count: u32,
            }
            #[automatically_derived]
            impl ::core::marker::Copy for InferencingUsage {}
            #[automatically_derived]
            impl ::core::clone::Clone for InferencingUsage {
                #[inline]
                fn clone(&self) -> InferencingUsage {
                    let _: ::core::clone::AssertParamIsClone<u32>;
                    *self
                }
            }
            unsafe impl wasmtime::component::Lower for InferencingUsage {
                #[inline]
                fn lower<T>(
                    &self,
                    cx: &mut wasmtime::component::__internal::LowerContext<'_, T>,
                    ty: wasmtime::component::__internal::InterfaceType,
                    dst: &mut std::mem::MaybeUninit<Self::Lower>,
                ) -> wasmtime::component::__internal::anyhow::Result<()> {
                    let ty = match ty {
                        wasmtime::component::__internal::InterfaceType::Record(i) => {
                            &cx.types[i]
                        }
                        _ => wasmtime::component::__internal::bad_type_info(),
                    };
                    wasmtime::component::Lower::lower(
                        &self.prompt_token_count,
                        cx,
                        ty.fields[0usize].ty,
                        {
                            #[allow(unused_unsafe)]
                            {
                                unsafe {
                                    use ::wasmtime::component::__internal::MaybeUninitExt;
                                    let m: &mut std::mem::MaybeUninit<_> = dst;
                                    m.map(|p| &raw mut (*p).prompt_token_count)
                                }
                            }
                        },
                    )?;
                    wasmtime::component::Lower::lower(
                        &self.generated_token_count,
                        cx,
                        ty.fields[1usize].ty,
                        {
                            #[allow(unused_unsafe)]
                            {
                                unsafe {
                                    use ::wasmtime::component::__internal::MaybeUninitExt;
                                    let m: &mut std::mem::MaybeUninit<_> = dst;
                                    m.map(|p| &raw mut (*p).generated_token_count)
                                }
                            }
                        },
                    )?;
                    Ok(())
                }
                #[inline]
                fn store<T>(
                    &self,
                    cx: &mut wasmtime::component::__internal::LowerContext<'_, T>,
                    ty: wasmtime::component::__internal::InterfaceType,
                    mut offset: usize,
                ) -> wasmtime::component::__internal::anyhow::Result<()> {
                    if true {
                        if !(offset
                            % (<Self as wasmtime::component::ComponentType>::ALIGN32
                                as usize) == 0)
                        {
                            ::core::panicking::panic(
                                "assertion failed: offset % (<Self as wasmtime::component::ComponentType>::ALIGN32 as usize) == 0",
                            )
                        }
                    }
                    let ty = match ty {
                        wasmtime::component::__internal::InterfaceType::Record(i) => {
                            &cx.types[i]
                        }
                        _ => wasmtime::component::__internal::bad_type_info(),
                    };
                    wasmtime::component::Lower::store(
                        &self.prompt_token_count,
                        cx,
                        ty.fields[0usize].ty,
                        <u32 as wasmtime::component::ComponentType>::ABI
                            .next_field32_size(&mut offset),
                    )?;
                    wasmtime::component::Lower::store(
                        &self.generated_token_count,
                        cx,
                        ty.fields[1usize].ty,
                        <u32 as wasmtime::component::ComponentType>::ABI
                            .next_field32_size(&mut offset),
                    )?;
                    Ok(())
                }
            }
            unsafe impl wasmtime::component::Lift for InferencingUsage {
                #[inline]
                fn lift(
                    cx: &mut wasmtime::component::__internal::LiftContext<'_>,
                    ty: wasmtime::component::__internal::InterfaceType,
                    src: &Self::Lower,
                ) -> wasmtime::component::__internal::anyhow::Result<Self> {
                    let ty = match ty {
                        wasmtime::component::__internal::InterfaceType::Record(i) => {
                            &cx.types[i]
                        }
                        _ => wasmtime::component::__internal::bad_type_info(),
                    };
                    Ok(Self {
                        prompt_token_count: <u32 as wasmtime::component::Lift>::lift(
                            cx,
                            ty.fields[0usize].ty,
                            &src.prompt_token_count,
                        )?,
                        generated_token_count: <u32 as wasmtime::component::Lift>::lift(
                            cx,
                            ty.fields[1usize].ty,
                            &src.generated_token_count,
                        )?,
                    })
                }
                #[inline]
                fn load(
                    cx: &mut wasmtime::component::__internal::LiftContext<'_>,
                    ty: wasmtime::component::__internal::InterfaceType,
                    bytes: &[u8],
                ) -> wasmtime::component::__internal::anyhow::Result<Self> {
                    let ty = match ty {
                        wasmtime::component::__internal::InterfaceType::Record(i) => {
                            &cx.types[i]
                        }
                        _ => wasmtime::component::__internal::bad_type_info(),
                    };
                    if true {
                        if !((bytes.as_ptr() as usize)
                            % (<Self as wasmtime::component::ComponentType>::ALIGN32
                                as usize) == 0)
                        {
                            ::core::panicking::panic(
                                "assertion failed: (bytes.as_ptr() as usize) %\\n        (<Self as wasmtime::component::ComponentType>::ALIGN32 as usize) == 0",
                            )
                        }
                    }
                    let mut offset = 0;
                    Ok(Self {
                        prompt_token_count: <u32 as wasmtime::component::Lift>::load(
                            cx,
                            ty.fields[0usize].ty,
                            &bytes[<u32 as wasmtime::component::ComponentType>::ABI
                                .next_field32_size(
                                    &mut offset,
                                )..][..<u32 as wasmtime::component::ComponentType>::SIZE32],
                        )?,
                        generated_token_count: <u32 as wasmtime::component::Lift>::load(
                            cx,
                            ty.fields[1usize].ty,
                            &bytes[<u32 as wasmtime::component::ComponentType>::ABI
                                .next_field32_size(
                                    &mut offset,
                                )..][..<u32 as wasmtime::component::ComponentType>::SIZE32],
                        )?,
                    })
                }
            }
            const _: () = {
                #[doc(hidden)]
                #[repr(C)]
                pub struct LowerInferencingUsage<T0: Copy, T1: Copy> {
                    prompt_token_count: T0,
                    generated_token_count: T1,
                    _align: [wasmtime::ValRaw; 0],
                }
                #[automatically_derived]
                impl<
                    T0: ::core::clone::Clone + Copy,
                    T1: ::core::clone::Clone + Copy,
                > ::core::clone::Clone for LowerInferencingUsage<T0, T1> {
                    #[inline]
                    fn clone(&self) -> LowerInferencingUsage<T0, T1> {
                        LowerInferencingUsage {
                            prompt_token_count: ::core::clone::Clone::clone(
                                &self.prompt_token_count,
                            ),
                            generated_token_count: ::core::clone::Clone::clone(
                                &self.generated_token_count,
                            ),
                            _align: ::core::clone::Clone::clone(&self._align),
                        }
                    }
                }
                #[automatically_derived]
                impl<
                    T0: ::core::marker::Copy + Copy,
                    T1: ::core::marker::Copy + Copy,
                > ::core::marker::Copy for LowerInferencingUsage<T0, T1> {}
                unsafe impl wasmtime::component::ComponentType for InferencingUsage {
                    type Lower = LowerInferencingUsage<
                        <u32 as wasmtime::component::ComponentType>::Lower,
                        <u32 as wasmtime::component::ComponentType>::Lower,
                    >;
                    const ABI: wasmtime::component::__internal::CanonicalAbiInfo = wasmtime::component::__internal::CanonicalAbiInfo::record_static(
                        &[
                            <u32 as wasmtime::component::ComponentType>::ABI,
                            <u32 as wasmtime::component::ComponentType>::ABI,
                        ],
                    );
                    #[inline]
                    fn typecheck(
                        ty: &wasmtime::component::__internal::InterfaceType,
                        types: &wasmtime::component::__internal::InstanceType<'_>,
                    ) -> wasmtime::component::__internal::anyhow::Result<()> {
                        wasmtime::component::__internal::typecheck_record(
                            ty,
                            types,
                            &[
                                (
                                    "prompt-token-count",
                                    <u32 as wasmtime::component::ComponentType>::typecheck,
                                ),
                                (
                                    "generated-token-count",
                                    <u32 as wasmtime::component::ComponentType>::typecheck,
                                ),
                            ],
                        )
                    }
                }
            };
            impl core::fmt::Debug for InferencingUsage {
                fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
                    f.debug_struct("InferencingUsage")
                        .field("prompt-token-count", &self.prompt_token_count)
                        .field("generated-token-count", &self.generated_token_count)
                        .finish()
                }
            }
            const _: () = {
                if !(8
                    == <InferencingUsage as wasmtime::component::ComponentType>::SIZE32)
                {
                    ::core::panicking::panic(
                        "assertion failed: 8 == <InferencingUsage as wasmtime::component::ComponentType>::SIZE32",
                    )
                }
                if !(4
                    == <InferencingUsage as wasmtime::component::ComponentType>::ALIGN32)
                {
                    ::core::panicking::panic(
                        "assertion failed: 4 == <InferencingUsage as wasmtime::component::ComponentType>::ALIGN32",
                    )
                }
            };
            /// An inferencing result
            #[component(record)]
            pub struct InferencingResult {
                /// The text generated by the model
                #[component(name = "text")]
                pub text: String,
                /// Usage information about the inferencing request
                #[component(name = "usage")]
                pub usage: InferencingUsage,
            }
            #[automatically_derived]
            impl ::core::clone::Clone for InferencingResult {
                #[inline]
                fn clone(&self) -> InferencingResult {
                    InferencingResult {
                        text: ::core::clone::Clone::clone(&self.text),
                        usage: ::core::clone::Clone::clone(&self.usage),
                    }
                }
            }
            unsafe impl wasmtime::component::Lower for InferencingResult {
                #[inline]
                fn lower<T>(
                    &self,
                    cx: &mut wasmtime::component::__internal::LowerContext<'_, T>,
                    ty: wasmtime::component::__internal::InterfaceType,
                    dst: &mut std::mem::MaybeUninit<Self::Lower>,
                ) -> wasmtime::component::__internal::anyhow::Result<()> {
                    let ty = match ty {
                        wasmtime::component::__internal::InterfaceType::Record(i) => {
                            &cx.types[i]
                        }
                        _ => wasmtime::component::__internal::bad_type_info(),
                    };
                    wasmtime::component::Lower::lower(
                        &self.text,
                        cx,
                        ty.fields[0usize].ty,
                        {
                            #[allow(unused_unsafe)]
                            {
                                unsafe {
                                    use ::wasmtime::component::__internal::MaybeUninitExt;
                                    let m: &mut std::mem::MaybeUninit<_> = dst;
                                    m.map(|p| &raw mut (*p).text)
                                }
                            }
                        },
                    )?;
                    wasmtime::component::Lower::lower(
                        &self.usage,
                        cx,
                        ty.fields[1usize].ty,
                        {
                            #[allow(unused_unsafe)]
                            {
                                unsafe {
                                    use ::wasmtime::component::__internal::MaybeUninitExt;
                                    let m: &mut std::mem::MaybeUninit<_> = dst;
                                    m.map(|p| &raw mut (*p).usage)
                                }
                            }
                        },
                    )?;
                    Ok(())
                }
                #[inline]
                fn store<T>(
                    &self,
                    cx: &mut wasmtime::component::__internal::LowerContext<'_, T>,
                    ty: wasmtime::component::__internal::InterfaceType,
                    mut offset: usize,
                ) -> wasmtime::component::__internal::anyhow::Result<()> {
                    if true {
                        if !(offset
                            % (<Self as wasmtime::component::ComponentType>::ALIGN32
                                as usize) == 0)
                        {
                            ::core::panicking::panic(
                                "assertion failed: offset % (<Self as wasmtime::component::ComponentType>::ALIGN32 as usize) == 0",
                            )
                        }
                    }
                    let ty = match ty {
                        wasmtime::component::__internal::InterfaceType::Record(i) => {
                            &cx.types[i]
                        }
                        _ => wasmtime::component::__internal::bad_type_info(),
                    };
                    wasmtime::component::Lower::store(
                        &self.text,
                        cx,
                        ty.fields[0usize].ty,
                        <String as wasmtime::component::ComponentType>::ABI
                            .next_field32_size(&mut offset),
                    )?;
                    wasmtime::component::Lower::store(
                        &self.usage,
                        cx,
                        ty.fields[1usize].ty,
                        <InferencingUsage as wasmtime::component::ComponentType>::ABI
                            .next_field32_size(&mut offset),
                    )?;
                    Ok(())
                }
            }
            unsafe impl wasmtime::component::Lift for InferencingResult {
                #[inline]
                fn lift(
                    cx: &mut wasmtime::component::__internal::LiftContext<'_>,
                    ty: wasmtime::component::__internal::InterfaceType,
                    src: &Self::Lower,
                ) -> wasmtime::component::__internal::anyhow::Result<Self> {
                    let ty = match ty {
                        wasmtime::component::__internal::InterfaceType::Record(i) => {
                            &cx.types[i]
                        }
                        _ => wasmtime::component::__internal::bad_type_info(),
                    };
                    Ok(Self {
                        text: <String as wasmtime::component::Lift>::lift(
                            cx,
                            ty.fields[0usize].ty,
                            &src.text,
                        )?,
                        usage: <InferencingUsage as wasmtime::component::Lift>::lift(
                            cx,
                            ty.fields[1usize].ty,
                            &src.usage,
                        )?,
                    })
                }
                #[inline]
                fn load(
                    cx: &mut wasmtime::component::__internal::LiftContext<'_>,
                    ty: wasmtime::component::__internal::InterfaceType,
                    bytes: &[u8],
                ) -> wasmtime::component::__internal::anyhow::Result<Self> {
                    let ty = match ty {
                        wasmtime::component::__internal::InterfaceType::Record(i) => {
                            &cx.types[i]
                        }
                        _ => wasmtime::component::__internal::bad_type_info(),
                    };
                    if true {
                        if !((bytes.as_ptr() as usize)
                            % (<Self as wasmtime::component::ComponentType>::ALIGN32
                                as usize) == 0)
                        {
                            ::core::panicking::panic(
                                "assertion failed: (bytes.as_ptr() as usize) %\\n        (<Self as wasmtime::component::ComponentType>::ALIGN32 as usize) == 0",
                            )
                        }
                    }
                    let mut offset = 0;
                    Ok(Self {
                        text: <String as wasmtime::component::Lift>::load(
                            cx,
                            ty.fields[0usize].ty,
                            &bytes[<String as wasmtime::component::ComponentType>::ABI
                                .next_field32_size(
                                    &mut offset,
                                )..][..<String as wasmtime::component::ComponentType>::SIZE32],
                        )?,
                        usage: <InferencingUsage as wasmtime::component::Lift>::load(
                            cx,
                            ty.fields[1usize].ty,
                            &bytes[<InferencingUsage as wasmtime::component::ComponentType>::ABI
                                .next_field32_size(
                                    &mut offset,
                                )..][..<InferencingUsage as wasmtime::component::ComponentType>::SIZE32],
                        )?,
                    })
                }
            }
            const _: () = {
                #[doc(hidden)]
                #[repr(C)]
                pub struct LowerInferencingResult<T0: Copy, T1: Copy> {
                    text: T0,
                    usage: T1,
                    _align: [wasmtime::ValRaw; 0],
                }
                #[automatically_derived]
                impl<
                    T0: ::core::clone::Clone + Copy,
                    T1: ::core::clone::Clone + Copy,
                > ::core::clone::Clone for LowerInferencingResult<T0, T1> {
                    #[inline]
                    fn clone(&self) -> LowerInferencingResult<T0, T1> {
                        LowerInferencingResult {
                            text: ::core::clone::Clone::clone(&self.text),
                            usage: ::core::clone::Clone::clone(&self.usage),
                            _align: ::core::clone::Clone::clone(&self._align),
                        }
                    }
                }
                #[automatically_derived]
                impl<
                    T0: ::core::marker::Copy + Copy,
                    T1: ::core::marker::Copy + Copy,
                > ::core::marker::Copy for LowerInferencingResult<T0, T1> {}
                unsafe impl wasmtime::component::ComponentType for InferencingResult {
                    type Lower = LowerInferencingResult<
                        <String as wasmtime::component::ComponentType>::Lower,
                        <InferencingUsage as wasmtime::component::ComponentType>::Lower,
                    >;
                    const ABI: wasmtime::component::__internal::CanonicalAbiInfo = wasmtime::component::__internal::CanonicalAbiInfo::record_static(
                        &[
                            <String as wasmtime::component::ComponentType>::ABI,
                            <InferencingUsage as wasmtime::component::ComponentType>::ABI,
                        ],
                    );
                    #[inline]
                    fn typecheck(
                        ty: &wasmtime::component::__internal::InterfaceType,
                        types: &wasmtime::component::__internal::InstanceType<'_>,
                    ) -> wasmtime::component::__internal::anyhow::Result<()> {
                        wasmtime::component::__internal::typecheck_record(
                            ty,
                            types,
                            &[
                                (
                                    "text",
                                    <String as wasmtime::component::ComponentType>::typecheck,
                                ),
                                (
                                    "usage",
                                    <InferencingUsage as wasmtime::component::ComponentType>::typecheck,
                                ),
                            ],
                        )
                    }
                }
            };
            impl core::fmt::Debug for InferencingResult {
                fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
                    f.debug_struct("InferencingResult")
                        .field("text", &self.text)
                        .field("usage", &self.usage)
                        .finish()
                }
            }
            const _: () = {
                if !(16
                    == <InferencingResult as wasmtime::component::ComponentType>::SIZE32)
                {
                    ::core::panicking::panic(
                        "assertion failed: 16 == <InferencingResult as wasmtime::component::ComponentType>::SIZE32",
                    )
                }
                if !(4
                    == <InferencingResult as wasmtime::component::ComponentType>::ALIGN32)
                {
                    ::core::panicking::panic(
                        "assertion failed: 4 == <InferencingResult as wasmtime::component::ComponentType>::ALIGN32",
                    )
                }
            };
            /// The model used for generating embeddings
            pub type EmbeddingModel = String;
            const _: () = {
                if !(8 == <EmbeddingModel as wasmtime::component::ComponentType>::SIZE32)
                {
                    ::core::panicking::panic(
                        "assertion failed: 8 == <EmbeddingModel as wasmtime::component::ComponentType>::SIZE32",
                    )
                }
                if !(4
                    == <EmbeddingModel as wasmtime::component::ComponentType>::ALIGN32)
                {
                    ::core::panicking::panic(
                        "assertion failed: 4 == <EmbeddingModel as wasmtime::component::ComponentType>::ALIGN32",
                    )
                }
            };
            /// Usage related to an embeddings generation request
            #[component(record)]
            pub struct EmbeddingsUsage {
                /// Number of tokens in the prompt
                #[component(name = "prompt-token-count")]
                pub prompt_token_count: u32,
            }
            #[automatically_derived]
            impl ::core::marker::Copy for EmbeddingsUsage {}
            #[automatically_derived]
            impl ::core::clone::Clone for EmbeddingsUsage {
                #[inline]
                fn clone(&self) -> EmbeddingsUsage {
                    let _: ::core::clone::AssertParamIsClone<u32>;
                    *self
                }
            }
            unsafe impl wasmtime::component::Lower for EmbeddingsUsage {
                #[inline]
                fn lower<T>(
                    &self,
                    cx: &mut wasmtime::component::__internal::LowerContext<'_, T>,
                    ty: wasmtime::component::__internal::InterfaceType,
                    dst: &mut std::mem::MaybeUninit<Self::Lower>,
                ) -> wasmtime::component::__internal::anyhow::Result<()> {
                    let ty = match ty {
                        wasmtime::component::__internal::InterfaceType::Record(i) => {
                            &cx.types[i]
                        }
                        _ => wasmtime::component::__internal::bad_type_info(),
                    };
                    wasmtime::component::Lower::lower(
                        &self.prompt_token_count,
                        cx,
                        ty.fields[0usize].ty,
                        {
                            #[allow(unused_unsafe)]
                            {
                                unsafe {
                                    use ::wasmtime::component::__internal::MaybeUninitExt;
                                    let m: &mut std::mem::MaybeUninit<_> = dst;
                                    m.map(|p| &raw mut (*p).prompt_token_count)
                                }
                            }
                        },
                    )?;
                    Ok(())
                }
                #[inline]
                fn store<T>(
                    &self,
                    cx: &mut wasmtime::component::__internal::LowerContext<'_, T>,
                    ty: wasmtime::component::__internal::InterfaceType,
                    mut offset: usize,
                ) -> wasmtime::component::__internal::anyhow::Result<()> {
                    if true {
                        if !(offset
                            % (<Self as wasmtime::component::ComponentType>::ALIGN32
                                as usize) == 0)
                        {
                            ::core::panicking::panic(
                                "assertion failed: offset % (<Self as wasmtime::component::ComponentType>::ALIGN32 as usize) == 0",
                            )
                        }
                    }
                    let ty = match ty {
                        wasmtime::component::__internal::InterfaceType::Record(i) => {
                            &cx.types[i]
                        }
                        _ => wasmtime::component::__internal::bad_type_info(),
                    };
                    wasmtime::component::Lower::store(
                        &self.prompt_token_count,
                        cx,
                        ty.fields[0usize].ty,
                        <u32 as wasmtime::component::ComponentType>::ABI
                            .next_field32_size(&mut offset),
                    )?;
                    Ok(())
                }
            }
            unsafe impl wasmtime::component::Lift for EmbeddingsUsage {
                #[inline]
                fn lift(
                    cx: &mut wasmtime::component::__internal::LiftContext<'_>,
                    ty: wasmtime::component::__internal::InterfaceType,
                    src: &Self::Lower,
                ) -> wasmtime::component::__internal::anyhow::Result<Self> {
                    let ty = match ty {
                        wasmtime::component::__internal::InterfaceType::Record(i) => {
                            &cx.types[i]
                        }
                        _ => wasmtime::component::__internal::bad_type_info(),
                    };
                    Ok(Self {
                        prompt_token_count: <u32 as wasmtime::component::Lift>::lift(
                            cx,
                            ty.fields[0usize].ty,
                            &src.prompt_token_count,
                        )?,
                    })
                }
                #[inline]
                fn load(
                    cx: &mut wasmtime::component::__internal::LiftContext<'_>,
                    ty: wasmtime::component::__internal::InterfaceType,
                    bytes: &[u8],
                ) -> wasmtime::component::__internal::anyhow::Result<Self> {
                    let ty = match ty {
                        wasmtime::component::__internal::InterfaceType::Record(i) => {
                            &cx.types[i]
                        }
                        _ => wasmtime::component::__internal::bad_type_info(),
                    };
                    if true {
                        if !((bytes.as_ptr() as usize)
                            % (<Self as wasmtime::component::ComponentType>::ALIGN32
                                as usize) == 0)
                        {
                            ::core::panicking::panic(
                                "assertion failed: (bytes.as_ptr() as usize) %\\n        (<Self as wasmtime::component::ComponentType>::ALIGN32 as usize) == 0",
                            )
                        }
                    }
                    let mut offset = 0;
                    Ok(Self {
                        prompt_token_count: <u32 as wasmtime::component::Lift>::load(
                            cx,
                            ty.fields[0usize].ty,
                            &bytes[<u32 as wasmtime::component::ComponentType>::ABI
                                .next_field32_size(
                                    &mut offset,
                                )..][..<u32 as wasmtime::component::ComponentType>::SIZE32],
                        )?,
                    })
                }
            }
            const _: () = {
                #[doc(hidden)]
                #[repr(C)]
                pub struct LowerEmbeddingsUsage<T0: Copy> {
                    prompt_token_count: T0,
                    _align: [wasmtime::ValRaw; 0],
                }
                #[automatically_derived]
                impl<T0: ::core::clone::Clone + Copy> ::core::clone::Clone
                for LowerEmbeddingsUsage<T0> {
                    #[inline]
                    fn clone(&self) -> LowerEmbeddingsUsage<T0> {
                        LowerEmbeddingsUsage {
                            prompt_token_count: ::core::clone::Clone::clone(
                                &self.prompt_token_count,
                            ),
                            _align: ::core::clone::Clone::clone(&self._align),
                        }
                    }
                }
                #[automatically_derived]
                impl<T0: ::core::marker::Copy + Copy> ::core::marker::Copy
                for LowerEmbeddingsUsage<T0> {}
                unsafe impl wasmtime::component::ComponentType for EmbeddingsUsage {
                    type Lower = LowerEmbeddingsUsage<
                        <u32 as wasmtime::component::ComponentType>::Lower,
                    >;
                    const ABI: wasmtime::component::__internal::CanonicalAbiInfo = wasmtime::component::__internal::CanonicalAbiInfo::record_static(
                        &[<u32 as wasmtime::component::ComponentType>::ABI],
                    );
                    #[inline]
                    fn typecheck(
                        ty: &wasmtime::component::__internal::InterfaceType,
                        types: &wasmtime::component::__internal::InstanceType<'_>,
                    ) -> wasmtime::component::__internal::anyhow::Result<()> {
                        wasmtime::component::__internal::typecheck_record(
                            ty,
                            types,
                            &[
                                (
                                    "prompt-token-count",
                                    <u32 as wasmtime::component::ComponentType>::typecheck,
                                ),
                            ],
                        )
                    }
                }
            };
            impl core::fmt::Debug for EmbeddingsUsage {
                fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
                    f.debug_struct("EmbeddingsUsage")
                        .field("prompt-token-count", &self.prompt_token_count)
                        .finish()
                }
            }
            const _: () = {
                if !(4
                    == <EmbeddingsUsage as wasmtime::component::ComponentType>::SIZE32)
                {
                    ::core::panicking::panic(
                        "assertion failed: 4 == <EmbeddingsUsage as wasmtime::component::ComponentType>::SIZE32",
                    )
                }
                if !(4
                    == <EmbeddingsUsage as wasmtime::component::ComponentType>::ALIGN32)
                {
                    ::core::panicking::panic(
                        "assertion failed: 4 == <EmbeddingsUsage as wasmtime::component::ComponentType>::ALIGN32",
                    )
                }
            };
            /// Result of generating embeddings
            #[component(record)]
            pub struct EmbeddingsResult {
                /// The embeddings generated by the request
                #[component(name = "embeddings")]
                pub embeddings: Vec<Vec<f32>>,
                /// Usage related to the embeddings generation request
                #[component(name = "usage")]
                pub usage: EmbeddingsUsage,
            }
            #[automatically_derived]
            impl ::core::clone::Clone for EmbeddingsResult {
                #[inline]
                fn clone(&self) -> EmbeddingsResult {
                    EmbeddingsResult {
                        embeddings: ::core::clone::Clone::clone(&self.embeddings),
                        usage: ::core::clone::Clone::clone(&self.usage),
                    }
                }
            }
            unsafe impl wasmtime::component::Lower for EmbeddingsResult {
                #[inline]
                fn lower<T>(
                    &self,
                    cx: &mut wasmtime::component::__internal::LowerContext<'_, T>,
                    ty: wasmtime::component::__internal::InterfaceType,
                    dst: &mut std::mem::MaybeUninit<Self::Lower>,
                ) -> wasmtime::component::__internal::anyhow::Result<()> {
                    let ty = match ty {
                        wasmtime::component::__internal::InterfaceType::Record(i) => {
                            &cx.types[i]
                        }
                        _ => wasmtime::component::__internal::bad_type_info(),
                    };
                    wasmtime::component::Lower::lower(
                        &self.embeddings,
                        cx,
                        ty.fields[0usize].ty,
                        {
                            #[allow(unused_unsafe)]
                            {
                                unsafe {
                                    use ::wasmtime::component::__internal::MaybeUninitExt;
                                    let m: &mut std::mem::MaybeUninit<_> = dst;
                                    m.map(|p| &raw mut (*p).embeddings)
                                }
                            }
                        },
                    )?;
                    wasmtime::component::Lower::lower(
                        &self.usage,
                        cx,
                        ty.fields[1usize].ty,
                        {
                            #[allow(unused_unsafe)]
                            {
                                unsafe {
                                    use ::wasmtime::component::__internal::MaybeUninitExt;
                                    let m: &mut std::mem::MaybeUninit<_> = dst;
                                    m.map(|p| &raw mut (*p).usage)
                                }
                            }
                        },
                    )?;
                    Ok(())
                }
                #[inline]
                fn store<T>(
                    &self,
                    cx: &mut wasmtime::component::__internal::LowerContext<'_, T>,
                    ty: wasmtime::component::__internal::InterfaceType,
                    mut offset: usize,
                ) -> wasmtime::component::__internal::anyhow::Result<()> {
                    if true {
                        if !(offset
                            % (<Self as wasmtime::component::ComponentType>::ALIGN32
                                as usize) == 0)
                        {
                            ::core::panicking::panic(
                                "assertion failed: offset % (<Self as wasmtime::component::ComponentType>::ALIGN32 as usize) == 0",
                            )
                        }
                    }
                    let ty = match ty {
                        wasmtime::component::__internal::InterfaceType::Record(i) => {
                            &cx.types[i]
                        }
                        _ => wasmtime::component::__internal::bad_type_info(),
                    };
                    wasmtime::component::Lower::store(
                        &self.embeddings,
                        cx,
                        ty.fields[0usize].ty,
                        <Vec<Vec<f32>> as wasmtime::component::ComponentType>::ABI
                            .next_field32_size(&mut offset),
                    )?;
                    wasmtime::component::Lower::store(
                        &self.usage,
                        cx,
                        ty.fields[1usize].ty,
                        <EmbeddingsUsage as wasmtime::component::ComponentType>::ABI
                            .next_field32_size(&mut offset),
                    )?;
                    Ok(())
                }
            }
            unsafe impl wasmtime::component::Lift for EmbeddingsResult {
                #[inline]
                fn lift(
                    cx: &mut wasmtime::component::__internal::LiftContext<'_>,
                    ty: wasmtime::component::__internal::InterfaceType,
                    src: &Self::Lower,
                ) -> wasmtime::component::__internal::anyhow::Result<Self> {
                    let ty = match ty {
                        wasmtime::component::__internal::InterfaceType::Record(i) => {
                            &cx.types[i]
                        }
                        _ => wasmtime::component::__internal::bad_type_info(),
                    };
                    Ok(Self {
                        embeddings: <Vec<
                            Vec<f32>,
                        > as wasmtime::component::Lift>::lift(
                            cx,
                            ty.fields[0usize].ty,
                            &src.embeddings,
                        )?,
                        usage: <EmbeddingsUsage as wasmtime::component::Lift>::lift(
                            cx,
                            ty.fields[1usize].ty,
                            &src.usage,
                        )?,
                    })
                }
                #[inline]
                fn load(
                    cx: &mut wasmtime::component::__internal::LiftContext<'_>,
                    ty: wasmtime::component::__internal::InterfaceType,
                    bytes: &[u8],
                ) -> wasmtime::component::__internal::anyhow::Result<Self> {
                    let ty = match ty {
                        wasmtime::component::__internal::InterfaceType::Record(i) => {
                            &cx.types[i]
                        }
                        _ => wasmtime::component::__internal::bad_type_info(),
                    };
                    if true {
                        if !((bytes.as_ptr() as usize)
                            % (<Self as wasmtime::component::ComponentType>::ALIGN32
                                as usize) == 0)
                        {
                            ::core::panicking::panic(
                                "assertion failed: (bytes.as_ptr() as usize) %\\n        (<Self as wasmtime::component::ComponentType>::ALIGN32 as usize) == 0",
                            )
                        }
                    }
                    let mut offset = 0;
                    Ok(Self {
                        embeddings: <Vec<
                            Vec<f32>,
                        > as wasmtime::component::Lift>::load(
                            cx,
                            ty.fields[0usize].ty,
                            &bytes[<Vec<
                                Vec<f32>,
                            > as wasmtime::component::ComponentType>::ABI
                                .next_field32_size(
                                    &mut offset,
                                )..][..<Vec<
                                Vec<f32>,
                            > as wasmtime::component::ComponentType>::SIZE32],
                        )?,
                        usage: <EmbeddingsUsage as wasmtime::component::Lift>::load(
                            cx,
                            ty.fields[1usize].ty,
                            &bytes[<EmbeddingsUsage as wasmtime::component::ComponentType>::ABI
                                .next_field32_size(
                                    &mut offset,
                                )..][..<EmbeddingsUsage as wasmtime::component::ComponentType>::SIZE32],
                        )?,
                    })
                }
            }
            const _: () = {
                #[doc(hidden)]
                #[repr(C)]
                pub struct LowerEmbeddingsResult<T0: Copy, T1: Copy> {
                    embeddings: T0,
                    usage: T1,
                    _align: [wasmtime::ValRaw; 0],
                }
                #[automatically_derived]
                impl<
                    T0: ::core::clone::Clone + Copy,
                    T1: ::core::clone::Clone + Copy,
                > ::core::clone::Clone for LowerEmbeddingsResult<T0, T1> {
                    #[inline]
                    fn clone(&self) -> LowerEmbeddingsResult<T0, T1> {
                        LowerEmbeddingsResult {
                            embeddings: ::core::clone::Clone::clone(&self.embeddings),
                            usage: ::core::clone::Clone::clone(&self.usage),
                            _align: ::core::clone::Clone::clone(&self._align),
                        }
                    }
                }
                #[automatically_derived]
                impl<
                    T0: ::core::marker::Copy + Copy,
                    T1: ::core::marker::Copy + Copy,
                > ::core::marker::Copy for LowerEmbeddingsResult<T0, T1> {}
                unsafe impl wasmtime::component::ComponentType for EmbeddingsResult {
                    type Lower = LowerEmbeddingsResult<
                        <Vec<Vec<f32>> as wasmtime::component::ComponentType>::Lower,
                        <EmbeddingsUsage as wasmtime::component::ComponentType>::Lower,
                    >;
                    const ABI: wasmtime::component::__internal::CanonicalAbiInfo = wasmtime::component::__internal::CanonicalAbiInfo::record_static(
                        &[
                            <Vec<Vec<f32>> as wasmtime::component::ComponentType>::ABI,
                            <EmbeddingsUsage as wasmtime::component::ComponentType>::ABI,
                        ],
                    );
                    #[inline]
                    fn typecheck(
                        ty: &wasmtime::component::__internal::InterfaceType,
                        types: &wasmtime::component::__internal::InstanceType<'_>,
                    ) -> wasmtime::component::__internal::anyhow::Result<()> {
                        wasmtime::component::__internal::typecheck_record(
                            ty,
                            types,
                            &[
                                (
                                    "embeddings",
                                    <Vec<
                                        Vec<f32>,
                                    > as wasmtime::component::ComponentType>::typecheck,
                                ),
                                (
                                    "usage",
                                    <EmbeddingsUsage as wasmtime::component::ComponentType>::typecheck,
                                ),
                            ],
                        )
                    }
                }
            };
            impl core::fmt::Debug for EmbeddingsResult {
                fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
                    f.debug_struct("EmbeddingsResult")
                        .field("embeddings", &self.embeddings)
                        .field("usage", &self.usage)
                        .finish()
                }
            }
            const _: () = {
                if !(12
                    == <EmbeddingsResult as wasmtime::component::ComponentType>::SIZE32)
                {
                    ::core::panicking::panic(
                        "assertion failed: 12 == <EmbeddingsResult as wasmtime::component::ComponentType>::SIZE32",
                    )
                }
                if !(4
                    == <EmbeddingsResult as wasmtime::component::ComponentType>::ALIGN32)
                {
                    ::core::panicking::panic(
                        "assertion failed: 4 == <EmbeddingsResult as wasmtime::component::ComponentType>::ALIGN32",
                    )
                }
            };
            pub trait Host {
                /// Perform inferencing using the provided model and prompt with the given optional params
                #[must_use]
                #[allow(clippy::type_complexity, clippy::type_repetition_in_bounds)]
                fn infer<'life0, 'async_trait>(
                    &'life0 mut self,
                    model: InferencingModel,
                    prompt: String,
                    params: Option<InferencingParams>,
                ) -> ::core::pin::Pin<
                    Box<
                        dyn ::core::future::Future<
                            Output = wasmtime::Result<Result<InferencingResult, Error>>,
                        > + ::core::marker::Send + 'async_trait,
                    >,
                >
                where
                    'life0: 'async_trait,
                    Self: 'async_trait;
                /// Generate embeddings for the supplied list of text
                #[must_use]
                #[allow(clippy::type_complexity, clippy::type_repetition_in_bounds)]
                fn generate_embeddings<'life0, 'async_trait>(
                    &'life0 mut self,
                    model: EmbeddingModel,
                    text: Vec<String>,
                ) -> ::core::pin::Pin<
                    Box<
                        dyn ::core::future::Future<
                            Output = wasmtime::Result<Result<EmbeddingsResult, Error>>,
                        > + ::core::marker::Send + 'async_trait,
                    >,
                >
                where
                    'life0: 'async_trait,
                    Self: 'async_trait;
            }
            pub fn add_to_linker<T, U>(
                linker: &mut wasmtime::component::Linker<T>,
                get: impl Fn(&mut T) -> &mut U + Send + Sync + Copy + 'static,
            ) -> wasmtime::Result<()>
            where
                T: Send,
                U: Host + Send,
            {
                let mut inst = linker.instance("fermyon:spin/llm")?;
                inst.func_wrap_async(
                    "infer",
                    move |
                        mut caller: wasmtime::StoreContextMut<'_, T>,
                        (
                            arg0,
                            arg1,
                            arg2,
                        ): (InferencingModel, String, Option<InferencingParams>)|
                    Box::new(async move {
                        let host = get(caller.data_mut());
                        let r = Host::infer(host, arg0, arg1, arg2).await;
                        Ok((r?,))
                    }),
                )?;
                inst.func_wrap_async(
                    "generate-embeddings",
                    move |
                        mut caller: wasmtime::StoreContextMut<'_, T>,
                        (arg0, arg1): (EmbeddingModel, Vec<String>)|
                    Box::new(async move {
                        let host = get(caller.data_mut());
                        let r = Host::generate_embeddings(host, arg0, arg1).await;
                        Ok((r?,))
                    }),
                )?;
                Ok(())
            }
        }
    }
    pub mod spin2_0_0 {
        #[allow(clippy::all)]
        pub mod sqlite {
            #[allow(unused_imports)]
            use wasmtime::component::__internal::anyhow;
            /// A handle to an open sqlite instance
            pub enum Connection {}
            pub trait HostConnection {
                /// Open a connection to a named database instance.
                ///
                /// If `database` is "default", the default instance is opened.
                ///
                /// `error::no-such-database` will be raised if the `name` is not recognized.
                #[must_use]
                #[allow(clippy::type_complexity, clippy::type_repetition_in_bounds)]
                fn open<'life0, 'async_trait>(
                    &'life0 mut self,
                    database: String,
                ) -> ::core::pin::Pin<
                    Box<
                        dyn ::core::future::Future<
                            Output = wasmtime::Result<
                                Result<wasmtime::component::Resource<Connection>, Error>,
                            >,
                        > + ::core::marker::Send + 'async_trait,
                    >,
                >
                where
                    'life0: 'async_trait,
                    Self: 'async_trait;
                /// Execute a statement returning back data if there is any
                #[must_use]
                #[allow(clippy::type_complexity, clippy::type_repetition_in_bounds)]
                fn execute<'life0, 'async_trait>(
                    &'life0 mut self,
                    self_: wasmtime::component::Resource<Connection>,
                    statement: String,
                    parameters: Vec<Value>,
                ) -> ::core::pin::Pin<
                    Box<
                        dyn ::core::future::Future<
                            Output = wasmtime::Result<Result<QueryResult, Error>>,
                        > + ::core::marker::Send + 'async_trait,
                    >,
                >
                where
                    'life0: 'async_trait,
                    Self: 'async_trait;
                fn drop(
                    &mut self,
                    rep: wasmtime::component::Resource<Connection>,
                ) -> wasmtime::Result<()>;
            }
            /// The set of errors which may be raised by functions in this interface
            #[component(variant)]
            pub enum Error {
                /// The host does not recognize the database name requested.
                #[component(name = "no-such-database")]
                NoSuchDatabase,
                /// The requesting component does not have access to the specified database (which may or may not exist).
                #[component(name = "access-denied")]
                AccessDenied,
                /// The provided connection is not valid
                #[component(name = "invalid-connection")]
                InvalidConnection,
                /// The database has reached its capacity
                #[component(name = "database-full")]
                DatabaseFull,
                /// Some implementation-specific error has occurred (e.g. I/O)
                #[component(name = "io")]
                Io(String),
            }
            #[automatically_derived]
            impl ::core::clone::Clone for Error {
                #[inline]
                fn clone(&self) -> Error {
                    match self {
                        Error::NoSuchDatabase => Error::NoSuchDatabase,
                        Error::AccessDenied => Error::AccessDenied,
                        Error::InvalidConnection => Error::InvalidConnection,
                        Error::DatabaseFull => Error::DatabaseFull,
                        Error::Io(__self_0) => {
                            Error::Io(::core::clone::Clone::clone(__self_0))
                        }
                    }
                }
            }
            unsafe impl wasmtime::component::Lower for Error {
                #[inline]
                fn lower<T>(
                    &self,
                    cx: &mut wasmtime::component::__internal::LowerContext<'_, T>,
                    ty: wasmtime::component::__internal::InterfaceType,
                    dst: &mut std::mem::MaybeUninit<Self::Lower>,
                ) -> wasmtime::component::__internal::anyhow::Result<()> {
                    let ty = match ty {
                        wasmtime::component::__internal::InterfaceType::Variant(i) => {
                            &cx.types[i]
                        }
                        _ => wasmtime::component::__internal::bad_type_info(),
                    };
                    match self {
                        Self::NoSuchDatabase => {
                            {
                                #[allow(unused_unsafe)]
                                {
                                    unsafe {
                                        use ::wasmtime::component::__internal::MaybeUninitExt;
                                        let m: &mut std::mem::MaybeUninit<_> = dst;
                                        m.map(|p| &raw mut (*p).tag)
                                    }
                                }
                            }
                                .write(wasmtime::ValRaw::u32(0u32));
                            unsafe {
                                wasmtime::component::__internal::lower_payload(
                                    {
                                        #[allow(unused_unsafe)]
                                        {
                                            unsafe {
                                                use ::wasmtime::component::__internal::MaybeUninitExt;
                                                let m: &mut std::mem::MaybeUninit<_> = dst;
                                                m.map(|p| &raw mut (*p).payload)
                                            }
                                        }
                                    },
                                    |payload| {
                                        #[allow(unused_unsafe)]
                                        {
                                            unsafe {
                                                use ::wasmtime::component::__internal::MaybeUninitExt;
                                                let m: &mut std::mem::MaybeUninit<_> = payload;
                                                m.map(|p| &raw mut (*p).NoSuchDatabase)
                                            }
                                        }
                                    },
                                    |dst| Ok(()),
                                )
                            }
                        }
                        Self::AccessDenied => {
                            {
                                #[allow(unused_unsafe)]
                                {
                                    unsafe {
                                        use ::wasmtime::component::__internal::MaybeUninitExt;
                                        let m: &mut std::mem::MaybeUninit<_> = dst;
                                        m.map(|p| &raw mut (*p).tag)
                                    }
                                }
                            }
                                .write(wasmtime::ValRaw::u32(1u32));
                            unsafe {
                                wasmtime::component::__internal::lower_payload(
                                    {
                                        #[allow(unused_unsafe)]
                                        {
                                            unsafe {
                                                use ::wasmtime::component::__internal::MaybeUninitExt;
                                                let m: &mut std::mem::MaybeUninit<_> = dst;
                                                m.map(|p| &raw mut (*p).payload)
                                            }
                                        }
                                    },
                                    |payload| {
                                        #[allow(unused_unsafe)]
                                        {
                                            unsafe {
                                                use ::wasmtime::component::__internal::MaybeUninitExt;
                                                let m: &mut std::mem::MaybeUninit<_> = payload;
                                                m.map(|p| &raw mut (*p).AccessDenied)
                                            }
                                        }
                                    },
                                    |dst| Ok(()),
                                )
                            }
                        }
                        Self::InvalidConnection => {
                            {
                                #[allow(unused_unsafe)]
                                {
                                    unsafe {
                                        use ::wasmtime::component::__internal::MaybeUninitExt;
                                        let m: &mut std::mem::MaybeUninit<_> = dst;
                                        m.map(|p| &raw mut (*p).tag)
                                    }
                                }
                            }
                                .write(wasmtime::ValRaw::u32(2u32));
                            unsafe {
                                wasmtime::component::__internal::lower_payload(
                                    {
                                        #[allow(unused_unsafe)]
                                        {
                                            unsafe {
                                                use ::wasmtime::component::__internal::MaybeUninitExt;
                                                let m: &mut std::mem::MaybeUninit<_> = dst;
                                                m.map(|p| &raw mut (*p).payload)
                                            }
                                        }
                                    },
                                    |payload| {
                                        #[allow(unused_unsafe)]
                                        {
                                            unsafe {
                                                use ::wasmtime::component::__internal::MaybeUninitExt;
                                                let m: &mut std::mem::MaybeUninit<_> = payload;
                                                m.map(|p| &raw mut (*p).InvalidConnection)
                                            }
                                        }
                                    },
                                    |dst| Ok(()),
                                )
                            }
                        }
                        Self::DatabaseFull => {
                            {
                                #[allow(unused_unsafe)]
                                {
                                    unsafe {
                                        use ::wasmtime::component::__internal::MaybeUninitExt;
                                        let m: &mut std::mem::MaybeUninit<_> = dst;
                                        m.map(|p| &raw mut (*p).tag)
                                    }
                                }
                            }
                                .write(wasmtime::ValRaw::u32(3u32));
                            unsafe {
                                wasmtime::component::__internal::lower_payload(
                                    {
                                        #[allow(unused_unsafe)]
                                        {
                                            unsafe {
                                                use ::wasmtime::component::__internal::MaybeUninitExt;
                                                let m: &mut std::mem::MaybeUninit<_> = dst;
                                                m.map(|p| &raw mut (*p).payload)
                                            }
                                        }
                                    },
                                    |payload| {
                                        #[allow(unused_unsafe)]
                                        {
                                            unsafe {
                                                use ::wasmtime::component::__internal::MaybeUninitExt;
                                                let m: &mut std::mem::MaybeUninit<_> = payload;
                                                m.map(|p| &raw mut (*p).DatabaseFull)
                                            }
                                        }
                                    },
                                    |dst| Ok(()),
                                )
                            }
                        }
                        Self::Io(value) => {
                            {
                                #[allow(unused_unsafe)]
                                {
                                    unsafe {
                                        use ::wasmtime::component::__internal::MaybeUninitExt;
                                        let m: &mut std::mem::MaybeUninit<_> = dst;
                                        m.map(|p| &raw mut (*p).tag)
                                    }
                                }
                            }
                                .write(wasmtime::ValRaw::u32(4u32));
                            unsafe {
                                wasmtime::component::__internal::lower_payload(
                                    {
                                        #[allow(unused_unsafe)]
                                        {
                                            unsafe {
                                                use ::wasmtime::component::__internal::MaybeUninitExt;
                                                let m: &mut std::mem::MaybeUninit<_> = dst;
                                                m.map(|p| &raw mut (*p).payload)
                                            }
                                        }
                                    },
                                    |payload| {
                                        #[allow(unused_unsafe)]
                                        {
                                            unsafe {
                                                use ::wasmtime::component::__internal::MaybeUninitExt;
                                                let m: &mut std::mem::MaybeUninit<_> = payload;
                                                m.map(|p| &raw mut (*p).Io)
                                            }
                                        }
                                    },
                                    |dst| {
                                        value
                                            .lower(
                                                cx,
                                                ty
                                                    .cases[4usize]
                                                    .ty
                                                    .unwrap_or_else(
                                                        wasmtime::component::__internal::bad_type_info,
                                                    ),
                                                dst,
                                            )
                                    },
                                )
                            }
                        }
                    }
                }
                #[inline]
                fn store<T>(
                    &self,
                    cx: &mut wasmtime::component::__internal::LowerContext<'_, T>,
                    ty: wasmtime::component::__internal::InterfaceType,
                    mut offset: usize,
                ) -> wasmtime::component::__internal::anyhow::Result<()> {
                    let ty = match ty {
                        wasmtime::component::__internal::InterfaceType::Variant(i) => {
                            &cx.types[i]
                        }
                        _ => wasmtime::component::__internal::bad_type_info(),
                    };
                    if true {
                        if !(offset
                            % (<Self as wasmtime::component::ComponentType>::ALIGN32
                                as usize) == 0)
                        {
                            ::core::panicking::panic(
                                "assertion failed: offset % (<Self as wasmtime::component::ComponentType>::ALIGN32 as usize) == 0",
                            )
                        }
                    }
                    match self {
                        Self::NoSuchDatabase => {
                            *cx.get::<1usize>(offset) = 0u8.to_le_bytes();
                            Ok(())
                        }
                        Self::AccessDenied => {
                            *cx.get::<1usize>(offset) = 1u8.to_le_bytes();
                            Ok(())
                        }
                        Self::InvalidConnection => {
                            *cx.get::<1usize>(offset) = 2u8.to_le_bytes();
                            Ok(())
                        }
                        Self::DatabaseFull => {
                            *cx.get::<1usize>(offset) = 3u8.to_le_bytes();
                            Ok(())
                        }
                        Self::Io(value) => {
                            *cx.get::<1usize>(offset) = 4u8.to_le_bytes();
                            value
                                .store(
                                    cx,
                                    ty
                                        .cases[4usize]
                                        .ty
                                        .unwrap_or_else(
                                            wasmtime::component::__internal::bad_type_info,
                                        ),
                                    offset
                                        + <Self as wasmtime::component::__internal::ComponentVariant>::PAYLOAD_OFFSET32,
                                )
                        }
                    }
                }
            }
            unsafe impl wasmtime::component::Lift for Error {
                #[inline]
                fn lift(
                    cx: &mut wasmtime::component::__internal::LiftContext<'_>,
                    ty: wasmtime::component::__internal::InterfaceType,
                    src: &Self::Lower,
                ) -> wasmtime::component::__internal::anyhow::Result<Self> {
                    let ty = match ty {
                        wasmtime::component::__internal::InterfaceType::Variant(i) => {
                            &cx.types[i]
                        }
                        _ => wasmtime::component::__internal::bad_type_info(),
                    };
                    Ok(
                        match src.tag.get_u32() {
                            0u32 => Self::NoSuchDatabase,
                            1u32 => Self::AccessDenied,
                            2u32 => Self::InvalidConnection,
                            3u32 => Self::DatabaseFull,
                            4u32 => {
                                Self::Io(
                                    <String as wasmtime::component::Lift>::lift(
                                        cx,
                                        ty
                                            .cases[4usize]
                                            .ty
                                            .unwrap_or_else(
                                                wasmtime::component::__internal::bad_type_info,
                                            ),
                                        unsafe { &src.payload.Io },
                                    )?,
                                )
                            }
                            discrim => {
                                return ::anyhow::__private::Err(
                                    ::anyhow::Error::msg({
                                        let res = ::alloc::fmt::format(
                                            format_args!("unexpected discriminant: {0}", discrim),
                                        );
                                        res
                                    }),
                                );
                            }
                        },
                    )
                }
                #[inline]
                fn load(
                    cx: &mut wasmtime::component::__internal::LiftContext<'_>,
                    ty: wasmtime::component::__internal::InterfaceType,
                    bytes: &[u8],
                ) -> wasmtime::component::__internal::anyhow::Result<Self> {
                    let align = <Self as wasmtime::component::ComponentType>::ALIGN32;
                    if true {
                        if !((bytes.as_ptr() as usize) % (align as usize) == 0) {
                            ::core::panicking::panic(
                                "assertion failed: (bytes.as_ptr() as usize) % (align as usize) == 0",
                            )
                        }
                    }
                    let discrim = bytes[0];
                    let payload_offset = <Self as wasmtime::component::__internal::ComponentVariant>::PAYLOAD_OFFSET32;
                    let payload = &bytes[payload_offset..];
                    let ty = match ty {
                        wasmtime::component::__internal::InterfaceType::Variant(i) => {
                            &cx.types[i]
                        }
                        _ => wasmtime::component::__internal::bad_type_info(),
                    };
                    Ok(
                        match discrim {
                            0u8 => Self::NoSuchDatabase,
                            1u8 => Self::AccessDenied,
                            2u8 => Self::InvalidConnection,
                            3u8 => Self::DatabaseFull,
                            4u8 => {
                                Self::Io(
                                    <String as wasmtime::component::Lift>::load(
                                        cx,
                                        ty
                                            .cases[4usize]
                                            .ty
                                            .unwrap_or_else(
                                                wasmtime::component::__internal::bad_type_info,
                                            ),
                                        &payload[..<String as wasmtime::component::ComponentType>::SIZE32],
                                    )?,
                                )
                            }
                            discrim => {
                                return ::anyhow::__private::Err(
                                    ::anyhow::Error::msg({
                                        let res = ::alloc::fmt::format(
                                            format_args!("unexpected discriminant: {0}", discrim),
                                        );
                                        res
                                    }),
                                );
                            }
                        },
                    )
                }
            }
            const _: () = {
                #[doc(hidden)]
                #[repr(C)]
                pub struct LowerError<T4: Copy> {
                    tag: wasmtime::ValRaw,
                    payload: LowerPayloadError<T4>,
                }
                #[automatically_derived]
                impl<T4: ::core::clone::Clone + Copy> ::core::clone::Clone
                for LowerError<T4> {
                    #[inline]
                    fn clone(&self) -> LowerError<T4> {
                        LowerError {
                            tag: ::core::clone::Clone::clone(&self.tag),
                            payload: ::core::clone::Clone::clone(&self.payload),
                        }
                    }
                }
                #[automatically_derived]
                impl<T4: ::core::marker::Copy + Copy> ::core::marker::Copy
                for LowerError<T4> {}
                #[doc(hidden)]
                #[allow(non_snake_case)]
                #[repr(C)]
                union LowerPayloadError<T4: Copy> {
                    NoSuchDatabase: [wasmtime::ValRaw; 0],
                    AccessDenied: [wasmtime::ValRaw; 0],
                    InvalidConnection: [wasmtime::ValRaw; 0],
                    DatabaseFull: [wasmtime::ValRaw; 0],
                    Io: T4,
                }
                #[automatically_derived]
                #[allow(non_snake_case)]
                impl<
                    T4: ::core::marker::Copy + ::core::clone::Clone + Copy,
                > ::core::clone::Clone for LowerPayloadError<T4> {
                    #[inline]
                    fn clone(&self) -> LowerPayloadError<T4> {
                        let _: ::core::clone::AssertParamIsCopy<Self>;
                        *self
                    }
                }
                #[automatically_derived]
                #[allow(non_snake_case)]
                impl<T4: ::core::marker::Copy + Copy> ::core::marker::Copy
                for LowerPayloadError<T4> {}
                unsafe impl wasmtime::component::ComponentType for Error {
                    type Lower = LowerError<
                        <String as wasmtime::component::ComponentType>::Lower,
                    >;
                    #[inline]
                    fn typecheck(
                        ty: &wasmtime::component::__internal::InterfaceType,
                        types: &wasmtime::component::__internal::InstanceType<'_>,
                    ) -> wasmtime::component::__internal::anyhow::Result<()> {
                        wasmtime::component::__internal::typecheck_variant(
                            ty,
                            types,
                            &[
                                ("no-such-database", None),
                                ("access-denied", None),
                                ("invalid-connection", None),
                                ("database-full", None),
                                (
                                    "io",
                                    Some(
                                        <String as wasmtime::component::ComponentType>::typecheck,
                                    ),
                                ),
                            ],
                        )
                    }
                    const ABI: wasmtime::component::__internal::CanonicalAbiInfo = wasmtime::component::__internal::CanonicalAbiInfo::variant_static(
                        &[
                            None,
                            None,
                            None,
                            None,
                            Some(<String as wasmtime::component::ComponentType>::ABI),
                        ],
                    );
                }
                unsafe impl wasmtime::component::__internal::ComponentVariant for Error {
                    const CASES: &'static [Option<
                        wasmtime::component::__internal::CanonicalAbiInfo,
                    >] = &[
                        None,
                        None,
                        None,
                        None,
                        Some(<String as wasmtime::component::ComponentType>::ABI),
                    ];
                }
            };
            impl core::fmt::Debug for Error {
                fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
                    match self {
                        Error::NoSuchDatabase => {
                            f.debug_tuple("Error::NoSuchDatabase").finish()
                        }
                        Error::AccessDenied => {
                            f.debug_tuple("Error::AccessDenied").finish()
                        }
                        Error::InvalidConnection => {
                            f.debug_tuple("Error::InvalidConnection").finish()
                        }
                        Error::DatabaseFull => {
                            f.debug_tuple("Error::DatabaseFull").finish()
                        }
                        Error::Io(e) => f.debug_tuple("Error::Io").field(e).finish(),
                    }
                }
            }
            impl core::fmt::Display for Error {
                fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
                    f.write_fmt(format_args!("{0:?}", self))
                }
            }
            impl std::error::Error for Error {}
            const _: () = {
                if !(12 == <Error as wasmtime::component::ComponentType>::SIZE32) {
                    ::core::panicking::panic(
                        "assertion failed: 12 == <Error as wasmtime::component::ComponentType>::SIZE32",
                    )
                }
                if !(4 == <Error as wasmtime::component::ComponentType>::ALIGN32) {
                    ::core::panicking::panic(
                        "assertion failed: 4 == <Error as wasmtime::component::ComponentType>::ALIGN32",
                    )
                }
            };
            /// A single column's result from a database query
            #[component(variant)]
            pub enum Value {
                #[component(name = "integer")]
                Integer(i64),
                #[component(name = "real")]
                Real(f64),
                #[component(name = "text")]
                Text(String),
                #[component(name = "blob")]
                Blob(Vec<u8>),
                #[component(name = "null")]
                Null,
            }
            #[automatically_derived]
            impl ::core::clone::Clone for Value {
                #[inline]
                fn clone(&self) -> Value {
                    match self {
                        Value::Integer(__self_0) => {
                            Value::Integer(::core::clone::Clone::clone(__self_0))
                        }
                        Value::Real(__self_0) => {
                            Value::Real(::core::clone::Clone::clone(__self_0))
                        }
                        Value::Text(__self_0) => {
                            Value::Text(::core::clone::Clone::clone(__self_0))
                        }
                        Value::Blob(__self_0) => {
                            Value::Blob(::core::clone::Clone::clone(__self_0))
                        }
                        Value::Null => Value::Null,
                    }
                }
            }
            unsafe impl wasmtime::component::Lower for Value {
                #[inline]
                fn lower<T>(
                    &self,
                    cx: &mut wasmtime::component::__internal::LowerContext<'_, T>,
                    ty: wasmtime::component::__internal::InterfaceType,
                    dst: &mut std::mem::MaybeUninit<Self::Lower>,
                ) -> wasmtime::component::__internal::anyhow::Result<()> {
                    let ty = match ty {
                        wasmtime::component::__internal::InterfaceType::Variant(i) => {
                            &cx.types[i]
                        }
                        _ => wasmtime::component::__internal::bad_type_info(),
                    };
                    match self {
                        Self::Integer(value) => {
                            {
                                #[allow(unused_unsafe)]
                                {
                                    unsafe {
                                        use ::wasmtime::component::__internal::MaybeUninitExt;
                                        let m: &mut std::mem::MaybeUninit<_> = dst;
                                        m.map(|p| &raw mut (*p).tag)
                                    }
                                }
                            }
                                .write(wasmtime::ValRaw::u32(0u32));
                            unsafe {
                                wasmtime::component::__internal::lower_payload(
                                    {
                                        #[allow(unused_unsafe)]
                                        {
                                            unsafe {
                                                use ::wasmtime::component::__internal::MaybeUninitExt;
                                                let m: &mut std::mem::MaybeUninit<_> = dst;
                                                m.map(|p| &raw mut (*p).payload)
                                            }
                                        }
                                    },
                                    |payload| {
                                        #[allow(unused_unsafe)]
                                        {
                                            unsafe {
                                                use ::wasmtime::component::__internal::MaybeUninitExt;
                                                let m: &mut std::mem::MaybeUninit<_> = payload;
                                                m.map(|p| &raw mut (*p).Integer)
                                            }
                                        }
                                    },
                                    |dst| {
                                        value
                                            .lower(
                                                cx,
                                                ty
                                                    .cases[0usize]
                                                    .ty
                                                    .unwrap_or_else(
                                                        wasmtime::component::__internal::bad_type_info,
                                                    ),
                                                dst,
                                            )
                                    },
                                )
                            }
                        }
                        Self::Real(value) => {
                            {
                                #[allow(unused_unsafe)]
                                {
                                    unsafe {
                                        use ::wasmtime::component::__internal::MaybeUninitExt;
                                        let m: &mut std::mem::MaybeUninit<_> = dst;
                                        m.map(|p| &raw mut (*p).tag)
                                    }
                                }
                            }
                                .write(wasmtime::ValRaw::u32(1u32));
                            unsafe {
                                wasmtime::component::__internal::lower_payload(
                                    {
                                        #[allow(unused_unsafe)]
                                        {
                                            unsafe {
                                                use ::wasmtime::component::__internal::MaybeUninitExt;
                                                let m: &mut std::mem::MaybeUninit<_> = dst;
                                                m.map(|p| &raw mut (*p).payload)
                                            }
                                        }
                                    },
                                    |payload| {
                                        #[allow(unused_unsafe)]
                                        {
                                            unsafe {
                                                use ::wasmtime::component::__internal::MaybeUninitExt;
                                                let m: &mut std::mem::MaybeUninit<_> = payload;
                                                m.map(|p| &raw mut (*p).Real)
                                            }
                                        }
                                    },
                                    |dst| {
                                        value
                                            .lower(
                                                cx,
                                                ty
                                                    .cases[1usize]
                                                    .ty
                                                    .unwrap_or_else(
                                                        wasmtime::component::__internal::bad_type_info,
                                                    ),
                                                dst,
                                            )
                                    },
                                )
                            }
                        }
                        Self::Text(value) => {
                            {
                                #[allow(unused_unsafe)]
                                {
                                    unsafe {
                                        use ::wasmtime::component::__internal::MaybeUninitExt;
                                        let m: &mut std::mem::MaybeUninit<_> = dst;
                                        m.map(|p| &raw mut (*p).tag)
                                    }
                                }
                            }
                                .write(wasmtime::ValRaw::u32(2u32));
                            unsafe {
                                wasmtime::component::__internal::lower_payload(
                                    {
                                        #[allow(unused_unsafe)]
                                        {
                                            unsafe {
                                                use ::wasmtime::component::__internal::MaybeUninitExt;
                                                let m: &mut std::mem::MaybeUninit<_> = dst;
                                                m.map(|p| &raw mut (*p).payload)
                                            }
                                        }
                                    },
                                    |payload| {
                                        #[allow(unused_unsafe)]
                                        {
                                            unsafe {
                                                use ::wasmtime::component::__internal::MaybeUninitExt;
                                                let m: &mut std::mem::MaybeUninit<_> = payload;
                                                m.map(|p| &raw mut (*p).Text)
                                            }
                                        }
                                    },
                                    |dst| {
                                        value
                                            .lower(
                                                cx,
                                                ty
                                                    .cases[2usize]
                                                    .ty
                                                    .unwrap_or_else(
                                                        wasmtime::component::__internal::bad_type_info,
                                                    ),
                                                dst,
                                            )
                                    },
                                )
                            }
                        }
                        Self::Blob(value) => {
                            {
                                #[allow(unused_unsafe)]
                                {
                                    unsafe {
                                        use ::wasmtime::component::__internal::MaybeUninitExt;
                                        let m: &mut std::mem::MaybeUninit<_> = dst;
                                        m.map(|p| &raw mut (*p).tag)
                                    }
                                }
                            }
                                .write(wasmtime::ValRaw::u32(3u32));
                            unsafe {
                                wasmtime::component::__internal::lower_payload(
                                    {
                                        #[allow(unused_unsafe)]
                                        {
                                            unsafe {
                                                use ::wasmtime::component::__internal::MaybeUninitExt;
                                                let m: &mut std::mem::MaybeUninit<_> = dst;
                                                m.map(|p| &raw mut (*p).payload)
                                            }
                                        }
                                    },
                                    |payload| {
                                        #[allow(unused_unsafe)]
                                        {
                                            unsafe {
                                                use ::wasmtime::component::__internal::MaybeUninitExt;
                                                let m: &mut std::mem::MaybeUninit<_> = payload;
                                                m.map(|p| &raw mut (*p).Blob)
                                            }
                                        }
                                    },
                                    |dst| {
                                        value
                                            .lower(
                                                cx,
                                                ty
                                                    .cases[3usize]
                                                    .ty
                                                    .unwrap_or_else(
                                                        wasmtime::component::__internal::bad_type_info,
                                                    ),
                                                dst,
                                            )
                                    },
                                )
                            }
                        }
                        Self::Null => {
                            {
                                #[allow(unused_unsafe)]
                                {
                                    unsafe {
                                        use ::wasmtime::component::__internal::MaybeUninitExt;
                                        let m: &mut std::mem::MaybeUninit<_> = dst;
                                        m.map(|p| &raw mut (*p).tag)
                                    }
                                }
                            }
                                .write(wasmtime::ValRaw::u32(4u32));
                            unsafe {
                                wasmtime::component::__internal::lower_payload(
                                    {
                                        #[allow(unused_unsafe)]
                                        {
                                            unsafe {
                                                use ::wasmtime::component::__internal::MaybeUninitExt;
                                                let m: &mut std::mem::MaybeUninit<_> = dst;
                                                m.map(|p| &raw mut (*p).payload)
                                            }
                                        }
                                    },
                                    |payload| {
                                        #[allow(unused_unsafe)]
                                        {
                                            unsafe {
                                                use ::wasmtime::component::__internal::MaybeUninitExt;
                                                let m: &mut std::mem::MaybeUninit<_> = payload;
                                                m.map(|p| &raw mut (*p).Null)
                                            }
                                        }
                                    },
                                    |dst| Ok(()),
                                )
                            }
                        }
                    }
                }
                #[inline]
                fn store<T>(
                    &self,
                    cx: &mut wasmtime::component::__internal::LowerContext<'_, T>,
                    ty: wasmtime::component::__internal::InterfaceType,
                    mut offset: usize,
                ) -> wasmtime::component::__internal::anyhow::Result<()> {
                    let ty = match ty {
                        wasmtime::component::__internal::InterfaceType::Variant(i) => {
                            &cx.types[i]
                        }
                        _ => wasmtime::component::__internal::bad_type_info(),
                    };
                    if true {
                        if !(offset
                            % (<Self as wasmtime::component::ComponentType>::ALIGN32
                                as usize) == 0)
                        {
                            ::core::panicking::panic(
                                "assertion failed: offset % (<Self as wasmtime::component::ComponentType>::ALIGN32 as usize) == 0",
                            )
                        }
                    }
                    match self {
                        Self::Integer(value) => {
                            *cx.get::<1usize>(offset) = 0u8.to_le_bytes();
                            value
                                .store(
                                    cx,
                                    ty
                                        .cases[0usize]
                                        .ty
                                        .unwrap_or_else(
                                            wasmtime::component::__internal::bad_type_info,
                                        ),
                                    offset
                                        + <Self as wasmtime::component::__internal::ComponentVariant>::PAYLOAD_OFFSET32,
                                )
                        }
                        Self::Real(value) => {
                            *cx.get::<1usize>(offset) = 1u8.to_le_bytes();
                            value
                                .store(
                                    cx,
                                    ty
                                        .cases[1usize]
                                        .ty
                                        .unwrap_or_else(
                                            wasmtime::component::__internal::bad_type_info,
                                        ),
                                    offset
                                        + <Self as wasmtime::component::__internal::ComponentVariant>::PAYLOAD_OFFSET32,
                                )
                        }
                        Self::Text(value) => {
                            *cx.get::<1usize>(offset) = 2u8.to_le_bytes();
                            value
                                .store(
                                    cx,
                                    ty
                                        .cases[2usize]
                                        .ty
                                        .unwrap_or_else(
                                            wasmtime::component::__internal::bad_type_info,
                                        ),
                                    offset
                                        + <Self as wasmtime::component::__internal::ComponentVariant>::PAYLOAD_OFFSET32,
                                )
                        }
                        Self::Blob(value) => {
                            *cx.get::<1usize>(offset) = 3u8.to_le_bytes();
                            value
                                .store(
                                    cx,
                                    ty
                                        .cases[3usize]
                                        .ty
                                        .unwrap_or_else(
                                            wasmtime::component::__internal::bad_type_info,
                                        ),
                                    offset
                                        + <Self as wasmtime::component::__internal::ComponentVariant>::PAYLOAD_OFFSET32,
                                )
                        }
                        Self::Null => {
                            *cx.get::<1usize>(offset) = 4u8.to_le_bytes();
                            Ok(())
                        }
                    }
                }
            }
            unsafe impl wasmtime::component::Lift for Value {
                #[inline]
                fn lift(
                    cx: &mut wasmtime::component::__internal::LiftContext<'_>,
                    ty: wasmtime::component::__internal::InterfaceType,
                    src: &Self::Lower,
                ) -> wasmtime::component::__internal::anyhow::Result<Self> {
                    let ty = match ty {
                        wasmtime::component::__internal::InterfaceType::Variant(i) => {
                            &cx.types[i]
                        }
                        _ => wasmtime::component::__internal::bad_type_info(),
                    };
                    Ok(
                        match src.tag.get_u32() {
                            0u32 => {
                                Self::Integer(
                                    <i64 as wasmtime::component::Lift>::lift(
                                        cx,
                                        ty
                                            .cases[0usize]
                                            .ty
                                            .unwrap_or_else(
                                                wasmtime::component::__internal::bad_type_info,
                                            ),
                                        unsafe { &src.payload.Integer },
                                    )?,
                                )
                            }
                            1u32 => {
                                Self::Real(
                                    <f64 as wasmtime::component::Lift>::lift(
                                        cx,
                                        ty
                                            .cases[1usize]
                                            .ty
                                            .unwrap_or_else(
                                                wasmtime::component::__internal::bad_type_info,
                                            ),
                                        unsafe { &src.payload.Real },
                                    )?,
                                )
                            }
                            2u32 => {
                                Self::Text(
                                    <String as wasmtime::component::Lift>::lift(
                                        cx,
                                        ty
                                            .cases[2usize]
                                            .ty
                                            .unwrap_or_else(
                                                wasmtime::component::__internal::bad_type_info,
                                            ),
                                        unsafe { &src.payload.Text },
                                    )?,
                                )
                            }
                            3u32 => {
                                Self::Blob(
                                    <Vec<
                                        u8,
                                    > as wasmtime::component::Lift>::lift(
                                        cx,
                                        ty
                                            .cases[3usize]
                                            .ty
                                            .unwrap_or_else(
                                                wasmtime::component::__internal::bad_type_info,
                                            ),
                                        unsafe { &src.payload.Blob },
                                    )?,
                                )
                            }
                            4u32 => Self::Null,
                            discrim => {
                                return ::anyhow::__private::Err(
                                    ::anyhow::Error::msg({
                                        let res = ::alloc::fmt::format(
                                            format_args!("unexpected discriminant: {0}", discrim),
                                        );
                                        res
                                    }),
                                );
                            }
                        },
                    )
                }
                #[inline]
                fn load(
                    cx: &mut wasmtime::component::__internal::LiftContext<'_>,
                    ty: wasmtime::component::__internal::InterfaceType,
                    bytes: &[u8],
                ) -> wasmtime::component::__internal::anyhow::Result<Self> {
                    let align = <Self as wasmtime::component::ComponentType>::ALIGN32;
                    if true {
                        if !((bytes.as_ptr() as usize) % (align as usize) == 0) {
                            ::core::panicking::panic(
                                "assertion failed: (bytes.as_ptr() as usize) % (align as usize) == 0",
                            )
                        }
                    }
                    let discrim = bytes[0];
                    let payload_offset = <Self as wasmtime::component::__internal::ComponentVariant>::PAYLOAD_OFFSET32;
                    let payload = &bytes[payload_offset..];
                    let ty = match ty {
                        wasmtime::component::__internal::InterfaceType::Variant(i) => {
                            &cx.types[i]
                        }
                        _ => wasmtime::component::__internal::bad_type_info(),
                    };
                    Ok(
                        match discrim {
                            0u8 => {
                                Self::Integer(
                                    <i64 as wasmtime::component::Lift>::load(
                                        cx,
                                        ty
                                            .cases[0usize]
                                            .ty
                                            .unwrap_or_else(
                                                wasmtime::component::__internal::bad_type_info,
                                            ),
                                        &payload[..<i64 as wasmtime::component::ComponentType>::SIZE32],
                                    )?,
                                )
                            }
                            1u8 => {
                                Self::Real(
                                    <f64 as wasmtime::component::Lift>::load(
                                        cx,
                                        ty
                                            .cases[1usize]
                                            .ty
                                            .unwrap_or_else(
                                                wasmtime::component::__internal::bad_type_info,
                                            ),
                                        &payload[..<f64 as wasmtime::component::ComponentType>::SIZE32],
                                    )?,
                                )
                            }
                            2u8 => {
                                Self::Text(
                                    <String as wasmtime::component::Lift>::load(
                                        cx,
                                        ty
                                            .cases[2usize]
                                            .ty
                                            .unwrap_or_else(
                                                wasmtime::component::__internal::bad_type_info,
                                            ),
                                        &payload[..<String as wasmtime::component::ComponentType>::SIZE32],
                                    )?,
                                )
                            }
                            3u8 => {
                                Self::Blob(
                                    <Vec<
                                        u8,
                                    > as wasmtime::component::Lift>::load(
                                        cx,
                                        ty
                                            .cases[3usize]
                                            .ty
                                            .unwrap_or_else(
                                                wasmtime::component::__internal::bad_type_info,
                                            ),
                                        &payload[..<Vec<
                                            u8,
                                        > as wasmtime::component::ComponentType>::SIZE32],
                                    )?,
                                )
                            }
                            4u8 => Self::Null,
                            discrim => {
                                return ::anyhow::__private::Err(
                                    ::anyhow::Error::msg({
                                        let res = ::alloc::fmt::format(
                                            format_args!("unexpected discriminant: {0}", discrim),
                                        );
                                        res
                                    }),
                                );
                            }
                        },
                    )
                }
            }
            const _: () = {
                #[doc(hidden)]
                #[repr(C)]
                pub struct LowerValue<T0: Copy, T1: Copy, T2: Copy, T3: Copy> {
                    tag: wasmtime::ValRaw,
                    payload: LowerPayloadValue<T0, T1, T2, T3>,
                }
                #[automatically_derived]
                impl<
                    T0: ::core::clone::Clone + Copy,
                    T1: ::core::clone::Clone + Copy,
                    T2: ::core::clone::Clone + Copy,
                    T3: ::core::clone::Clone + Copy,
                > ::core::clone::Clone for LowerValue<T0, T1, T2, T3> {
                    #[inline]
                    fn clone(&self) -> LowerValue<T0, T1, T2, T3> {
                        LowerValue {
                            tag: ::core::clone::Clone::clone(&self.tag),
                            payload: ::core::clone::Clone::clone(&self.payload),
                        }
                    }
                }
                #[automatically_derived]
                impl<
                    T0: ::core::marker::Copy + Copy,
                    T1: ::core::marker::Copy + Copy,
                    T2: ::core::marker::Copy + Copy,
                    T3: ::core::marker::Copy + Copy,
                > ::core::marker::Copy for LowerValue<T0, T1, T2, T3> {}
                #[doc(hidden)]
                #[allow(non_snake_case)]
                #[repr(C)]
                union LowerPayloadValue<T0: Copy, T1: Copy, T2: Copy, T3: Copy> {
                    Integer: T0,
                    Real: T1,
                    Text: T2,
                    Blob: T3,
                    Null: [wasmtime::ValRaw; 0],
                }
                #[automatically_derived]
                #[allow(non_snake_case)]
                impl<
                    T0: ::core::marker::Copy + ::core::clone::Clone + Copy,
                    T1: ::core::marker::Copy + ::core::clone::Clone + Copy,
                    T2: ::core::marker::Copy + ::core::clone::Clone + Copy,
                    T3: ::core::marker::Copy + ::core::clone::Clone + Copy,
                > ::core::clone::Clone for LowerPayloadValue<T0, T1, T2, T3> {
                    #[inline]
                    fn clone(&self) -> LowerPayloadValue<T0, T1, T2, T3> {
                        let _: ::core::clone::AssertParamIsCopy<Self>;
                        *self
                    }
                }
                #[automatically_derived]
                #[allow(non_snake_case)]
                impl<
                    T0: ::core::marker::Copy + Copy,
                    T1: ::core::marker::Copy + Copy,
                    T2: ::core::marker::Copy + Copy,
                    T3: ::core::marker::Copy + Copy,
                > ::core::marker::Copy for LowerPayloadValue<T0, T1, T2, T3> {}
                unsafe impl wasmtime::component::ComponentType for Value {
                    type Lower = LowerValue<
                        <i64 as wasmtime::component::ComponentType>::Lower,
                        <f64 as wasmtime::component::ComponentType>::Lower,
                        <String as wasmtime::component::ComponentType>::Lower,
                        <Vec<u8> as wasmtime::component::ComponentType>::Lower,
                    >;
                    #[inline]
                    fn typecheck(
                        ty: &wasmtime::component::__internal::InterfaceType,
                        types: &wasmtime::component::__internal::InstanceType<'_>,
                    ) -> wasmtime::component::__internal::anyhow::Result<()> {
                        wasmtime::component::__internal::typecheck_variant(
                            ty,
                            types,
                            &[
                                (
                                    "integer",
                                    Some(<i64 as wasmtime::component::ComponentType>::typecheck),
                                ),
                                (
                                    "real",
                                    Some(<f64 as wasmtime::component::ComponentType>::typecheck),
                                ),
                                (
                                    "text",
                                    Some(
                                        <String as wasmtime::component::ComponentType>::typecheck,
                                    ),
                                ),
                                (
                                    "blob",
                                    Some(
                                        <Vec<u8> as wasmtime::component::ComponentType>::typecheck,
                                    ),
                                ),
                                ("null", None),
                            ],
                        )
                    }
                    const ABI: wasmtime::component::__internal::CanonicalAbiInfo = wasmtime::component::__internal::CanonicalAbiInfo::variant_static(
                        &[
                            Some(<i64 as wasmtime::component::ComponentType>::ABI),
                            Some(<f64 as wasmtime::component::ComponentType>::ABI),
                            Some(<String as wasmtime::component::ComponentType>::ABI),
                            Some(<Vec<u8> as wasmtime::component::ComponentType>::ABI),
                            None,
                        ],
                    );
                }
                unsafe impl wasmtime::component::__internal::ComponentVariant for Value {
                    const CASES: &'static [Option<
                        wasmtime::component::__internal::CanonicalAbiInfo,
                    >] = &[
                        Some(<i64 as wasmtime::component::ComponentType>::ABI),
                        Some(<f64 as wasmtime::component::ComponentType>::ABI),
                        Some(<String as wasmtime::component::ComponentType>::ABI),
                        Some(<Vec<u8> as wasmtime::component::ComponentType>::ABI),
                        None,
                    ];
                }
            };
            impl core::fmt::Debug for Value {
                fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
                    match self {
                        Value::Integer(e) => {
                            f.debug_tuple("Value::Integer").field(e).finish()
                        }
                        Value::Real(e) => f.debug_tuple("Value::Real").field(e).finish(),
                        Value::Text(e) => f.debug_tuple("Value::Text").field(e).finish(),
                        Value::Blob(e) => f.debug_tuple("Value::Blob").field(e).finish(),
                        Value::Null => f.debug_tuple("Value::Null").finish(),
                    }
                }
            }
            const _: () = {
                if !(16 == <Value as wasmtime::component::ComponentType>::SIZE32) {
                    ::core::panicking::panic(
                        "assertion failed: 16 == <Value as wasmtime::component::ComponentType>::SIZE32",
                    )
                }
                if !(8 == <Value as wasmtime::component::ComponentType>::ALIGN32) {
                    ::core::panicking::panic(
                        "assertion failed: 8 == <Value as wasmtime::component::ComponentType>::ALIGN32",
                    )
                }
            };
            /// A set of values for each of the columns in a query-result
            #[component(record)]
            pub struct RowResult {
                #[component(name = "values")]
                pub values: Vec<Value>,
            }
            #[automatically_derived]
            impl ::core::clone::Clone for RowResult {
                #[inline]
                fn clone(&self) -> RowResult {
                    RowResult {
                        values: ::core::clone::Clone::clone(&self.values),
                    }
                }
            }
            unsafe impl wasmtime::component::Lower for RowResult {
                #[inline]
                fn lower<T>(
                    &self,
                    cx: &mut wasmtime::component::__internal::LowerContext<'_, T>,
                    ty: wasmtime::component::__internal::InterfaceType,
                    dst: &mut std::mem::MaybeUninit<Self::Lower>,
                ) -> wasmtime::component::__internal::anyhow::Result<()> {
                    let ty = match ty {
                        wasmtime::component::__internal::InterfaceType::Record(i) => {
                            &cx.types[i]
                        }
                        _ => wasmtime::component::__internal::bad_type_info(),
                    };
                    wasmtime::component::Lower::lower(
                        &self.values,
                        cx,
                        ty.fields[0usize].ty,
                        {
                            #[allow(unused_unsafe)]
                            {
                                unsafe {
                                    use ::wasmtime::component::__internal::MaybeUninitExt;
                                    let m: &mut std::mem::MaybeUninit<_> = dst;
                                    m.map(|p| &raw mut (*p).values)
                                }
                            }
                        },
                    )?;
                    Ok(())
                }
                #[inline]
                fn store<T>(
                    &self,
                    cx: &mut wasmtime::component::__internal::LowerContext<'_, T>,
                    ty: wasmtime::component::__internal::InterfaceType,
                    mut offset: usize,
                ) -> wasmtime::component::__internal::anyhow::Result<()> {
                    if true {
                        if !(offset
                            % (<Self as wasmtime::component::ComponentType>::ALIGN32
                                as usize) == 0)
                        {
                            ::core::panicking::panic(
                                "assertion failed: offset % (<Self as wasmtime::component::ComponentType>::ALIGN32 as usize) == 0",
                            )
                        }
                    }
                    let ty = match ty {
                        wasmtime::component::__internal::InterfaceType::Record(i) => {
                            &cx.types[i]
                        }
                        _ => wasmtime::component::__internal::bad_type_info(),
                    };
                    wasmtime::component::Lower::store(
                        &self.values,
                        cx,
                        ty.fields[0usize].ty,
                        <Vec<Value> as wasmtime::component::ComponentType>::ABI
                            .next_field32_size(&mut offset),
                    )?;
                    Ok(())
                }
            }
            unsafe impl wasmtime::component::Lift for RowResult {
                #[inline]
                fn lift(
                    cx: &mut wasmtime::component::__internal::LiftContext<'_>,
                    ty: wasmtime::component::__internal::InterfaceType,
                    src: &Self::Lower,
                ) -> wasmtime::component::__internal::anyhow::Result<Self> {
                    let ty = match ty {
                        wasmtime::component::__internal::InterfaceType::Record(i) => {
                            &cx.types[i]
                        }
                        _ => wasmtime::component::__internal::bad_type_info(),
                    };
                    Ok(Self {
                        values: <Vec<
                            Value,
                        > as wasmtime::component::Lift>::lift(
                            cx,
                            ty.fields[0usize].ty,
                            &src.values,
                        )?,
                    })
                }
                #[inline]
                fn load(
                    cx: &mut wasmtime::component::__internal::LiftContext<'_>,
                    ty: wasmtime::component::__internal::InterfaceType,
                    bytes: &[u8],
                ) -> wasmtime::component::__internal::anyhow::Result<Self> {
                    let ty = match ty {
                        wasmtime::component::__internal::InterfaceType::Record(i) => {
                            &cx.types[i]
                        }
                        _ => wasmtime::component::__internal::bad_type_info(),
                    };
                    if true {
                        if !((bytes.as_ptr() as usize)
                            % (<Self as wasmtime::component::ComponentType>::ALIGN32
                                as usize) == 0)
                        {
                            ::core::panicking::panic(
                                "assertion failed: (bytes.as_ptr() as usize) %\\n        (<Self as wasmtime::component::ComponentType>::ALIGN32 as usize) == 0",
                            )
                        }
                    }
                    let mut offset = 0;
                    Ok(Self {
                        values: <Vec<
                            Value,
                        > as wasmtime::component::Lift>::load(
                            cx,
                            ty.fields[0usize].ty,
                            &bytes[<Vec<
                                Value,
                            > as wasmtime::component::ComponentType>::ABI
                                .next_field32_size(
                                    &mut offset,
                                )..][..<Vec<
                                Value,
                            > as wasmtime::component::ComponentType>::SIZE32],
                        )?,
                    })
                }
            }
            const _: () = {
                #[doc(hidden)]
                #[repr(C)]
                pub struct LowerRowResult<T0: Copy> {
                    values: T0,
                    _align: [wasmtime::ValRaw; 0],
                }
                #[automatically_derived]
                impl<T0: ::core::clone::Clone + Copy> ::core::clone::Clone
                for LowerRowResult<T0> {
                    #[inline]
                    fn clone(&self) -> LowerRowResult<T0> {
                        LowerRowResult {
                            values: ::core::clone::Clone::clone(&self.values),
                            _align: ::core::clone::Clone::clone(&self._align),
                        }
                    }
                }
                #[automatically_derived]
                impl<T0: ::core::marker::Copy + Copy> ::core::marker::Copy
                for LowerRowResult<T0> {}
                unsafe impl wasmtime::component::ComponentType for RowResult {
                    type Lower = LowerRowResult<
                        <Vec<Value> as wasmtime::component::ComponentType>::Lower,
                    >;
                    const ABI: wasmtime::component::__internal::CanonicalAbiInfo = wasmtime::component::__internal::CanonicalAbiInfo::record_static(
                        &[<Vec<Value> as wasmtime::component::ComponentType>::ABI],
                    );
                    #[inline]
                    fn typecheck(
                        ty: &wasmtime::component::__internal::InterfaceType,
                        types: &wasmtime::component::__internal::InstanceType<'_>,
                    ) -> wasmtime::component::__internal::anyhow::Result<()> {
                        wasmtime::component::__internal::typecheck_record(
                            ty,
                            types,
                            &[
                                (
                                    "values",
                                    <Vec<
                                        Value,
                                    > as wasmtime::component::ComponentType>::typecheck,
                                ),
                            ],
                        )
                    }
                }
            };
            impl core::fmt::Debug for RowResult {
                fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
                    f.debug_struct("RowResult").field("values", &self.values).finish()
                }
            }
            const _: () = {
                if !(8 == <RowResult as wasmtime::component::ComponentType>::SIZE32) {
                    ::core::panicking::panic(
                        "assertion failed: 8 == <RowResult as wasmtime::component::ComponentType>::SIZE32",
                    )
                }
                if !(4 == <RowResult as wasmtime::component::ComponentType>::ALIGN32) {
                    ::core::panicking::panic(
                        "assertion failed: 4 == <RowResult as wasmtime::component::ComponentType>::ALIGN32",
                    )
                }
            };
            /// A result of a query
            #[component(record)]
            pub struct QueryResult {
                /// The names of the columns retrieved in the query
                #[component(name = "columns")]
                pub columns: Vec<String>,
                /// the row results each containing the values for all the columns for a given row
                #[component(name = "rows")]
                pub rows: Vec<RowResult>,
            }
            #[automatically_derived]
            impl ::core::clone::Clone for QueryResult {
                #[inline]
                fn clone(&self) -> QueryResult {
                    QueryResult {
                        columns: ::core::clone::Clone::clone(&self.columns),
                        rows: ::core::clone::Clone::clone(&self.rows),
                    }
                }
            }
            unsafe impl wasmtime::component::Lower for QueryResult {
                #[inline]
                fn lower<T>(
                    &self,
                    cx: &mut wasmtime::component::__internal::LowerContext<'_, T>,
                    ty: wasmtime::component::__internal::InterfaceType,
                    dst: &mut std::mem::MaybeUninit<Self::Lower>,
                ) -> wasmtime::component::__internal::anyhow::Result<()> {
                    let ty = match ty {
                        wasmtime::component::__internal::InterfaceType::Record(i) => {
                            &cx.types[i]
                        }
                        _ => wasmtime::component::__internal::bad_type_info(),
                    };
                    wasmtime::component::Lower::lower(
                        &self.columns,
                        cx,
                        ty.fields[0usize].ty,
                        {
                            #[allow(unused_unsafe)]
                            {
                                unsafe {
                                    use ::wasmtime::component::__internal::MaybeUninitExt;
                                    let m: &mut std::mem::MaybeUninit<_> = dst;
                                    m.map(|p| &raw mut (*p).columns)
                                }
                            }
                        },
                    )?;
                    wasmtime::component::Lower::lower(
                        &self.rows,
                        cx,
                        ty.fields[1usize].ty,
                        {
                            #[allow(unused_unsafe)]
                            {
                                unsafe {
                                    use ::wasmtime::component::__internal::MaybeUninitExt;
                                    let m: &mut std::mem::MaybeUninit<_> = dst;
                                    m.map(|p| &raw mut (*p).rows)
                                }
                            }
                        },
                    )?;
                    Ok(())
                }
                #[inline]
                fn store<T>(
                    &self,
                    cx: &mut wasmtime::component::__internal::LowerContext<'_, T>,
                    ty: wasmtime::component::__internal::InterfaceType,
                    mut offset: usize,
                ) -> wasmtime::component::__internal::anyhow::Result<()> {
                    if true {
                        if !(offset
                            % (<Self as wasmtime::component::ComponentType>::ALIGN32
                                as usize) == 0)
                        {
                            ::core::panicking::panic(
                                "assertion failed: offset % (<Self as wasmtime::component::ComponentType>::ALIGN32 as usize) == 0",
                            )
                        }
                    }
                    let ty = match ty {
                        wasmtime::component::__internal::InterfaceType::Record(i) => {
                            &cx.types[i]
                        }
                        _ => wasmtime::component::__internal::bad_type_info(),
                    };
                    wasmtime::component::Lower::store(
                        &self.columns,
                        cx,
                        ty.fields[0usize].ty,
                        <Vec<String> as wasmtime::component::ComponentType>::ABI
                            .next_field32_size(&mut offset),
                    )?;
                    wasmtime::component::Lower::store(
                        &self.rows,
                        cx,
                        ty.fields[1usize].ty,
                        <Vec<RowResult> as wasmtime::component::ComponentType>::ABI
                            .next_field32_size(&mut offset),
                    )?;
                    Ok(())
                }
            }
            unsafe impl wasmtime::component::Lift for QueryResult {
                #[inline]
                fn lift(
                    cx: &mut wasmtime::component::__internal::LiftContext<'_>,
                    ty: wasmtime::component::__internal::InterfaceType,
                    src: &Self::Lower,
                ) -> wasmtime::component::__internal::anyhow::Result<Self> {
                    let ty = match ty {
                        wasmtime::component::__internal::InterfaceType::Record(i) => {
                            &cx.types[i]
                        }
                        _ => wasmtime::component::__internal::bad_type_info(),
                    };
                    Ok(Self {
                        columns: <Vec<
                            String,
                        > as wasmtime::component::Lift>::lift(
                            cx,
                            ty.fields[0usize].ty,
                            &src.columns,
                        )?,
                        rows: <Vec<
                            RowResult,
                        > as wasmtime::component::Lift>::lift(
                            cx,
                            ty.fields[1usize].ty,
                            &src.rows,
                        )?,
                    })
                }
                #[inline]
                fn load(
                    cx: &mut wasmtime::component::__internal::LiftContext<'_>,
                    ty: wasmtime::component::__internal::InterfaceType,
                    bytes: &[u8],
                ) -> wasmtime::component::__internal::anyhow::Result<Self> {
                    let ty = match ty {
                        wasmtime::component::__internal::InterfaceType::Record(i) => {
                            &cx.types[i]
                        }
                        _ => wasmtime::component::__internal::bad_type_info(),
                    };
                    if true {
                        if !((bytes.as_ptr() as usize)
                            % (<Self as wasmtime::component::ComponentType>::ALIGN32
                                as usize) == 0)
                        {
                            ::core::panicking::panic(
                                "assertion failed: (bytes.as_ptr() as usize) %\\n        (<Self as wasmtime::component::ComponentType>::ALIGN32 as usize) == 0",
                            )
                        }
                    }
                    let mut offset = 0;
                    Ok(Self {
                        columns: <Vec<
                            String,
                        > as wasmtime::component::Lift>::load(
                            cx,
                            ty.fields[0usize].ty,
                            &bytes[<Vec<
                                String,
                            > as wasmtime::component::ComponentType>::ABI
                                .next_field32_size(
                                    &mut offset,
                                )..][..<Vec<
                                String,
                            > as wasmtime::component::ComponentType>::SIZE32],
                        )?,
                        rows: <Vec<
                            RowResult,
                        > as wasmtime::component::Lift>::load(
                            cx,
                            ty.fields[1usize].ty,
                            &bytes[<Vec<
                                RowResult,
                            > as wasmtime::component::ComponentType>::ABI
                                .next_field32_size(
                                    &mut offset,
                                )..][..<Vec<
                                RowResult,
                            > as wasmtime::component::ComponentType>::SIZE32],
                        )?,
                    })
                }
            }
            const _: () = {
                #[doc(hidden)]
                #[repr(C)]
                pub struct LowerQueryResult<T0: Copy, T1: Copy> {
                    columns: T0,
                    rows: T1,
                    _align: [wasmtime::ValRaw; 0],
                }
                #[automatically_derived]
                impl<
                    T0: ::core::clone::Clone + Copy,
                    T1: ::core::clone::Clone + Copy,
                > ::core::clone::Clone for LowerQueryResult<T0, T1> {
                    #[inline]
                    fn clone(&self) -> LowerQueryResult<T0, T1> {
                        LowerQueryResult {
                            columns: ::core::clone::Clone::clone(&self.columns),
                            rows: ::core::clone::Clone::clone(&self.rows),
                            _align: ::core::clone::Clone::clone(&self._align),
                        }
                    }
                }
                #[automatically_derived]
                impl<
                    T0: ::core::marker::Copy + Copy,
                    T1: ::core::marker::Copy + Copy,
                > ::core::marker::Copy for LowerQueryResult<T0, T1> {}
                unsafe impl wasmtime::component::ComponentType for QueryResult {
                    type Lower = LowerQueryResult<
                        <Vec<String> as wasmtime::component::ComponentType>::Lower,
                        <Vec<RowResult> as wasmtime::component::ComponentType>::Lower,
                    >;
                    const ABI: wasmtime::component::__internal::CanonicalAbiInfo = wasmtime::component::__internal::CanonicalAbiInfo::record_static(
                        &[
                            <Vec<String> as wasmtime::component::ComponentType>::ABI,
                            <Vec<RowResult> as wasmtime::component::ComponentType>::ABI,
                        ],
                    );
                    #[inline]
                    fn typecheck(
                        ty: &wasmtime::component::__internal::InterfaceType,
                        types: &wasmtime::component::__internal::InstanceType<'_>,
                    ) -> wasmtime::component::__internal::anyhow::Result<()> {
                        wasmtime::component::__internal::typecheck_record(
                            ty,
                            types,
                            &[
                                (
                                    "columns",
                                    <Vec<
                                        String,
                                    > as wasmtime::component::ComponentType>::typecheck,
                                ),
                                (
                                    "rows",
                                    <Vec<
                                        RowResult,
                                    > as wasmtime::component::ComponentType>::typecheck,
                                ),
                            ],
                        )
                    }
                }
            };
            impl core::fmt::Debug for QueryResult {
                fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
                    f.debug_struct("QueryResult")
                        .field("columns", &self.columns)
                        .field("rows", &self.rows)
                        .finish()
                }
            }
            const _: () = {
                if !(16 == <QueryResult as wasmtime::component::ComponentType>::SIZE32) {
                    ::core::panicking::panic(
                        "assertion failed: 16 == <QueryResult as wasmtime::component::ComponentType>::SIZE32",
                    )
                }
                if !(4 == <QueryResult as wasmtime::component::ComponentType>::ALIGN32) {
                    ::core::panicking::panic(
                        "assertion failed: 4 == <QueryResult as wasmtime::component::ComponentType>::ALIGN32",
                    )
                }
            };
            pub trait Host: HostConnection {}
            pub fn add_to_linker<T, U>(
                linker: &mut wasmtime::component::Linker<T>,
                get: impl Fn(&mut T) -> &mut U + Send + Sync + Copy + 'static,
            ) -> wasmtime::Result<()>
            where
                T: Send,
                U: Host + Send,
            {
                let mut inst = linker.instance("fermyon:spin/sqlite@2.0.0")?;
                inst.resource::<
                        Connection,
                    >(
                    "connection",
                    move |mut store, rep| -> wasmtime::Result<()> {
                        HostConnection::drop(
                            get(store.data_mut()),
                            wasmtime::component::Resource::new_own(rep),
                        )
                    },
                )?;
                inst.func_wrap_async(
                    "[static]connection.open",
                    move |
                        mut caller: wasmtime::StoreContextMut<'_, T>,
                        (arg0,): (String,)|
                    Box::new(async move {
                        let host = get(caller.data_mut());
                        let r = HostConnection::open(host, arg0).await;
                        Ok((r?,))
                    }),
                )?;
                inst.func_wrap_async(
                    "[method]connection.execute",
                    move |
                        mut caller: wasmtime::StoreContextMut<'_, T>,
                        (
                            arg0,
                            arg1,
                            arg2,
                        ): (
                            wasmtime::component::Resource<Connection>,
                            String,
                            Vec<Value>,
                        )|
                    Box::new(async move {
                        let host = get(caller.data_mut());
                        let r = HostConnection::execute(host, arg0, arg1, arg2).await;
                        Ok((r?,))
                    }),
                )?;
                Ok(())
            }
        }
        #[allow(clippy::all)]
        pub mod key_value {
            #[allow(unused_imports)]
            use wasmtime::component::__internal::anyhow;
            /// An open key-value store
            pub enum Store {}
            pub trait HostStore {
                /// Open the store with the specified name.
                ///
                /// If `name` is "default", the default store is opened.  Otherwise,
                /// `name` must refer to a store defined and configured in a runtime
                /// configuration file supplied with the application.
                ///
                /// `error::no-such-store` will be raised if the `name` is not recognized.
                #[must_use]
                #[allow(clippy::type_complexity, clippy::type_repetition_in_bounds)]
                fn open<'life0, 'async_trait>(
                    &'life0 mut self,
                    name: String,
                ) -> ::core::pin::Pin<
                    Box<
                        dyn ::core::future::Future<
                            Output = wasmtime::Result<
                                Result<wasmtime::component::Resource<Store>, Error>,
                            >,
                        > + ::core::marker::Send + 'async_trait,
                    >,
                >
                where
                    'life0: 'async_trait,
                    Self: 'async_trait;
                /// Get the value associated with the specified `key` from the specified
                /// `store`.
                ///
                /// `error::invalid-store` will be raised if `store` is not a valid handle
                /// to an open store, and `error::no-such-key` will be raised if there is no
                /// tuple for `key` in `store`.
                #[must_use]
                #[allow(clippy::type_complexity, clippy::type_repetition_in_bounds)]
                fn get<'life0, 'async_trait>(
                    &'life0 mut self,
                    self_: wasmtime::component::Resource<Store>,
                    key: String,
                ) -> ::core::pin::Pin<
                    Box<
                        dyn ::core::future::Future<
                            Output = wasmtime::Result<Result<Vec<u8>, Error>>,
                        > + ::core::marker::Send + 'async_trait,
                    >,
                >
                where
                    'life0: 'async_trait,
                    Self: 'async_trait;
                /// Set the `value` associated with the specified `key` in the specified
                /// `store`, overwriting any existing value.
                ///
                /// `error::invalid-store` will be raised if `store` is not a valid handle
                /// to an open store.
                #[must_use]
                #[allow(clippy::type_complexity, clippy::type_repetition_in_bounds)]
                fn set<'life0, 'async_trait>(
                    &'life0 mut self,
                    self_: wasmtime::component::Resource<Store>,
                    key: String,
                    value: Vec<u8>,
                ) -> ::core::pin::Pin<
                    Box<
                        dyn ::core::future::Future<
                            Output = wasmtime::Result<Result<(), Error>>,
                        > + ::core::marker::Send + 'async_trait,
                    >,
                >
                where
                    'life0: 'async_trait,
                    Self: 'async_trait;
                /// Delete the tuple with the specified `key` from the specified `store`.
                ///
                /// `error::invalid-store` will be raised if `store` is not a valid handle
                /// to an open store.  No error is raised if a tuple did not previously
                /// exist for `key`.
                #[must_use]
                #[allow(clippy::type_complexity, clippy::type_repetition_in_bounds)]
                fn delete<'life0, 'async_trait>(
                    &'life0 mut self,
                    self_: wasmtime::component::Resource<Store>,
                    key: String,
                ) -> ::core::pin::Pin<
                    Box<
                        dyn ::core::future::Future<
                            Output = wasmtime::Result<Result<(), Error>>,
                        > + ::core::marker::Send + 'async_trait,
                    >,
                >
                where
                    'life0: 'async_trait,
                    Self: 'async_trait;
                /// Return whether a tuple exists for the specified `key` in the specified
                /// `store`.
                ///
                /// `error::invalid-store` will be raised if `store` is not a valid handle
                /// to an open store.
                #[must_use]
                #[allow(clippy::type_complexity, clippy::type_repetition_in_bounds)]
                fn exists<'life0, 'async_trait>(
                    &'life0 mut self,
                    self_: wasmtime::component::Resource<Store>,
                    key: String,
                ) -> ::core::pin::Pin<
                    Box<
                        dyn ::core::future::Future<
                            Output = wasmtime::Result<Result<bool, Error>>,
                        > + ::core::marker::Send + 'async_trait,
                    >,
                >
                where
                    'life0: 'async_trait,
                    Self: 'async_trait;
                /// Return a list of all the keys in the specified `store`.
                ///
                /// `error::invalid-store` will be raised if `store` is not a valid handle
                /// to an open store.
                #[must_use]
                #[allow(clippy::type_complexity, clippy::type_repetition_in_bounds)]
                fn get_keys<'life0, 'async_trait>(
                    &'life0 mut self,
                    self_: wasmtime::component::Resource<Store>,
                ) -> ::core::pin::Pin<
                    Box<
                        dyn ::core::future::Future<
                            Output = wasmtime::Result<Result<Vec<String>, Error>>,
                        > + ::core::marker::Send + 'async_trait,
                    >,
                >
                where
                    'life0: 'async_trait,
                    Self: 'async_trait;
                fn drop(
                    &mut self,
                    rep: wasmtime::component::Resource<Store>,
                ) -> wasmtime::Result<()>;
            }
            /// The set of errors which may be raised by functions in this interface
            #[component(variant)]
            pub enum Error {
                /// Too many stores have been opened simultaneously. Closing one or more
                /// stores prior to retrying may address this.
                #[component(name = "store-table-full")]
                StoreTableFull,
                /// The host does not recognize the store name requested.  Defining and
                /// configuring a store with that name in a runtime configuration file
                /// may address this.
                #[component(name = "no-such-store")]
                NoSuchStore,
                /// The requesting component does not have access to the specified store
                /// (which may or may not exist).
                #[component(name = "access-denied")]
                AccessDenied,
                /// The store handle provided is not recognized, i.e. it was either never
                /// opened or has been closed.
                #[component(name = "invalid-store")]
                InvalidStore,
                /// No key-value tuple exists for the specified key in the specified
                /// store.
                #[component(name = "no-such-key")]
                NoSuchKey,
                /// Some implementation-specific error has occurred (e.g. I/O)
                #[component(name = "io")]
                Io(String),
            }
            #[automatically_derived]
            impl ::core::clone::Clone for Error {
                #[inline]
                fn clone(&self) -> Error {
                    match self {
                        Error::StoreTableFull => Error::StoreTableFull,
                        Error::NoSuchStore => Error::NoSuchStore,
                        Error::AccessDenied => Error::AccessDenied,
                        Error::InvalidStore => Error::InvalidStore,
                        Error::NoSuchKey => Error::NoSuchKey,
                        Error::Io(__self_0) => {
                            Error::Io(::core::clone::Clone::clone(__self_0))
                        }
                    }
                }
            }
            unsafe impl wasmtime::component::Lower for Error {
                #[inline]
                fn lower<T>(
                    &self,
                    cx: &mut wasmtime::component::__internal::LowerContext<'_, T>,
                    ty: wasmtime::component::__internal::InterfaceType,
                    dst: &mut std::mem::MaybeUninit<Self::Lower>,
                ) -> wasmtime::component::__internal::anyhow::Result<()> {
                    let ty = match ty {
                        wasmtime::component::__internal::InterfaceType::Variant(i) => {
                            &cx.types[i]
                        }
                        _ => wasmtime::component::__internal::bad_type_info(),
                    };
                    match self {
                        Self::StoreTableFull => {
                            {
                                #[allow(unused_unsafe)]
                                {
                                    unsafe {
                                        use ::wasmtime::component::__internal::MaybeUninitExt;
                                        let m: &mut std::mem::MaybeUninit<_> = dst;
                                        m.map(|p| &raw mut (*p).tag)
                                    }
                                }
                            }
                                .write(wasmtime::ValRaw::u32(0u32));
                            unsafe {
                                wasmtime::component::__internal::lower_payload(
                                    {
                                        #[allow(unused_unsafe)]
                                        {
                                            unsafe {
                                                use ::wasmtime::component::__internal::MaybeUninitExt;
                                                let m: &mut std::mem::MaybeUninit<_> = dst;
                                                m.map(|p| &raw mut (*p).payload)
                                            }
                                        }
                                    },
                                    |payload| {
                                        #[allow(unused_unsafe)]
                                        {
                                            unsafe {
                                                use ::wasmtime::component::__internal::MaybeUninitExt;
                                                let m: &mut std::mem::MaybeUninit<_> = payload;
                                                m.map(|p| &raw mut (*p).StoreTableFull)
                                            }
                                        }
                                    },
                                    |dst| Ok(()),
                                )
                            }
                        }
                        Self::NoSuchStore => {
                            {
                                #[allow(unused_unsafe)]
                                {
                                    unsafe {
                                        use ::wasmtime::component::__internal::MaybeUninitExt;
                                        let m: &mut std::mem::MaybeUninit<_> = dst;
                                        m.map(|p| &raw mut (*p).tag)
                                    }
                                }
                            }
                                .write(wasmtime::ValRaw::u32(1u32));
                            unsafe {
                                wasmtime::component::__internal::lower_payload(
                                    {
                                        #[allow(unused_unsafe)]
                                        {
                                            unsafe {
                                                use ::wasmtime::component::__internal::MaybeUninitExt;
                                                let m: &mut std::mem::MaybeUninit<_> = dst;
                                                m.map(|p| &raw mut (*p).payload)
                                            }
                                        }
                                    },
                                    |payload| {
                                        #[allow(unused_unsafe)]
                                        {
                                            unsafe {
                                                use ::wasmtime::component::__internal::MaybeUninitExt;
                                                let m: &mut std::mem::MaybeUninit<_> = payload;
                                                m.map(|p| &raw mut (*p).NoSuchStore)
                                            }
                                        }
                                    },
                                    |dst| Ok(()),
                                )
                            }
                        }
                        Self::AccessDenied => {
                            {
                                #[allow(unused_unsafe)]
                                {
                                    unsafe {
                                        use ::wasmtime::component::__internal::MaybeUninitExt;
                                        let m: &mut std::mem::MaybeUninit<_> = dst;
                                        m.map(|p| &raw mut (*p).tag)
                                    }
                                }
                            }
                                .write(wasmtime::ValRaw::u32(2u32));
                            unsafe {
                                wasmtime::component::__internal::lower_payload(
                                    {
                                        #[allow(unused_unsafe)]
                                        {
                                            unsafe {
                                                use ::wasmtime::component::__internal::MaybeUninitExt;
                                                let m: &mut std::mem::MaybeUninit<_> = dst;
                                                m.map(|p| &raw mut (*p).payload)
                                            }
                                        }
                                    },
                                    |payload| {
                                        #[allow(unused_unsafe)]
                                        {
                                            unsafe {
                                                use ::wasmtime::component::__internal::MaybeUninitExt;
                                                let m: &mut std::mem::MaybeUninit<_> = payload;
                                                m.map(|p| &raw mut (*p).AccessDenied)
                                            }
                                        }
                                    },
                                    |dst| Ok(()),
                                )
                            }
                        }
                        Self::InvalidStore => {
                            {
                                #[allow(unused_unsafe)]
                                {
                                    unsafe {
                                        use ::wasmtime::component::__internal::MaybeUninitExt;
                                        let m: &mut std::mem::MaybeUninit<_> = dst;
                                        m.map(|p| &raw mut (*p).tag)
                                    }
                                }
                            }
                                .write(wasmtime::ValRaw::u32(3u32));
                            unsafe {
                                wasmtime::component::__internal::lower_payload(
                                    {
                                        #[allow(unused_unsafe)]
                                        {
                                            unsafe {
                                                use ::wasmtime::component::__internal::MaybeUninitExt;
                                                let m: &mut std::mem::MaybeUninit<_> = dst;
                                                m.map(|p| &raw mut (*p).payload)
                                            }
                                        }
                                    },
                                    |payload| {
                                        #[allow(unused_unsafe)]
                                        {
                                            unsafe {
                                                use ::wasmtime::component::__internal::MaybeUninitExt;
                                                let m: &mut std::mem::MaybeUninit<_> = payload;
                                                m.map(|p| &raw mut (*p).InvalidStore)
                                            }
                                        }
                                    },
                                    |dst| Ok(()),
                                )
                            }
                        }
                        Self::NoSuchKey => {
                            {
                                #[allow(unused_unsafe)]
                                {
                                    unsafe {
                                        use ::wasmtime::component::__internal::MaybeUninitExt;
                                        let m: &mut std::mem::MaybeUninit<_> = dst;
                                        m.map(|p| &raw mut (*p).tag)
                                    }
                                }
                            }
                                .write(wasmtime::ValRaw::u32(4u32));
                            unsafe {
                                wasmtime::component::__internal::lower_payload(
                                    {
                                        #[allow(unused_unsafe)]
                                        {
                                            unsafe {
                                                use ::wasmtime::component::__internal::MaybeUninitExt;
                                                let m: &mut std::mem::MaybeUninit<_> = dst;
                                                m.map(|p| &raw mut (*p).payload)
                                            }
                                        }
                                    },
                                    |payload| {
                                        #[allow(unused_unsafe)]
                                        {
                                            unsafe {
                                                use ::wasmtime::component::__internal::MaybeUninitExt;
                                                let m: &mut std::mem::MaybeUninit<_> = payload;
                                                m.map(|p| &raw mut (*p).NoSuchKey)
                                            }
                                        }
                                    },
                                    |dst| Ok(()),
                                )
                            }
                        }
                        Self::Io(value) => {
                            {
                                #[allow(unused_unsafe)]
                                {
                                    unsafe {
                                        use ::wasmtime::component::__internal::MaybeUninitExt;
                                        let m: &mut std::mem::MaybeUninit<_> = dst;
                                        m.map(|p| &raw mut (*p).tag)
                                    }
                                }
                            }
                                .write(wasmtime::ValRaw::u32(5u32));
                            unsafe {
                                wasmtime::component::__internal::lower_payload(
                                    {
                                        #[allow(unused_unsafe)]
                                        {
                                            unsafe {
                                                use ::wasmtime::component::__internal::MaybeUninitExt;
                                                let m: &mut std::mem::MaybeUninit<_> = dst;
                                                m.map(|p| &raw mut (*p).payload)
                                            }
                                        }
                                    },
                                    |payload| {
                                        #[allow(unused_unsafe)]
                                        {
                                            unsafe {
                                                use ::wasmtime::component::__internal::MaybeUninitExt;
                                                let m: &mut std::mem::MaybeUninit<_> = payload;
                                                m.map(|p| &raw mut (*p).Io)
                                            }
                                        }
                                    },
                                    |dst| {
                                        value
                                            .lower(
                                                cx,
                                                ty
                                                    .cases[5usize]
                                                    .ty
                                                    .unwrap_or_else(
                                                        wasmtime::component::__internal::bad_type_info,
                                                    ),
                                                dst,
                                            )
                                    },
                                )
                            }
                        }
                    }
                }
                #[inline]
                fn store<T>(
                    &self,
                    cx: &mut wasmtime::component::__internal::LowerContext<'_, T>,
                    ty: wasmtime::component::__internal::InterfaceType,
                    mut offset: usize,
                ) -> wasmtime::component::__internal::anyhow::Result<()> {
                    let ty = match ty {
                        wasmtime::component::__internal::InterfaceType::Variant(i) => {
                            &cx.types[i]
                        }
                        _ => wasmtime::component::__internal::bad_type_info(),
                    };
                    if true {
                        if !(offset
                            % (<Self as wasmtime::component::ComponentType>::ALIGN32
                                as usize) == 0)
                        {
                            ::core::panicking::panic(
                                "assertion failed: offset % (<Self as wasmtime::component::ComponentType>::ALIGN32 as usize) == 0",
                            )
                        }
                    }
                    match self {
                        Self::StoreTableFull => {
                            *cx.get::<1usize>(offset) = 0u8.to_le_bytes();
                            Ok(())
                        }
                        Self::NoSuchStore => {
                            *cx.get::<1usize>(offset) = 1u8.to_le_bytes();
                            Ok(())
                        }
                        Self::AccessDenied => {
                            *cx.get::<1usize>(offset) = 2u8.to_le_bytes();
                            Ok(())
                        }
                        Self::InvalidStore => {
                            *cx.get::<1usize>(offset) = 3u8.to_le_bytes();
                            Ok(())
                        }
                        Self::NoSuchKey => {
                            *cx.get::<1usize>(offset) = 4u8.to_le_bytes();
                            Ok(())
                        }
                        Self::Io(value) => {
                            *cx.get::<1usize>(offset) = 5u8.to_le_bytes();
                            value
                                .store(
                                    cx,
                                    ty
                                        .cases[5usize]
                                        .ty
                                        .unwrap_or_else(
                                            wasmtime::component::__internal::bad_type_info,
                                        ),
                                    offset
                                        + <Self as wasmtime::component::__internal::ComponentVariant>::PAYLOAD_OFFSET32,
                                )
                        }
                    }
                }
            }
            unsafe impl wasmtime::component::Lift for Error {
                #[inline]
                fn lift(
                    cx: &mut wasmtime::component::__internal::LiftContext<'_>,
                    ty: wasmtime::component::__internal::InterfaceType,
                    src: &Self::Lower,
                ) -> wasmtime::component::__internal::anyhow::Result<Self> {
                    let ty = match ty {
                        wasmtime::component::__internal::InterfaceType::Variant(i) => {
                            &cx.types[i]
                        }
                        _ => wasmtime::component::__internal::bad_type_info(),
                    };
                    Ok(
                        match src.tag.get_u32() {
                            0u32 => Self::StoreTableFull,
                            1u32 => Self::NoSuchStore,
                            2u32 => Self::AccessDenied,
                            3u32 => Self::InvalidStore,
                            4u32 => Self::NoSuchKey,
                            5u32 => {
                                Self::Io(
                                    <String as wasmtime::component::Lift>::lift(
                                        cx,
                                        ty
                                            .cases[5usize]
                                            .ty
                                            .unwrap_or_else(
                                                wasmtime::component::__internal::bad_type_info,
                                            ),
                                        unsafe { &src.payload.Io },
                                    )?,
                                )
                            }
                            discrim => {
                                return ::anyhow::__private::Err(
                                    ::anyhow::Error::msg({
                                        let res = ::alloc::fmt::format(
                                            format_args!("unexpected discriminant: {0}", discrim),
                                        );
                                        res
                                    }),
                                );
                            }
                        },
                    )
                }
                #[inline]
                fn load(
                    cx: &mut wasmtime::component::__internal::LiftContext<'_>,
                    ty: wasmtime::component::__internal::InterfaceType,
                    bytes: &[u8],
                ) -> wasmtime::component::__internal::anyhow::Result<Self> {
                    let align = <Self as wasmtime::component::ComponentType>::ALIGN32;
                    if true {
                        if !((bytes.as_ptr() as usize) % (align as usize) == 0) {
                            ::core::panicking::panic(
                                "assertion failed: (bytes.as_ptr() as usize) % (align as usize) == 0",
                            )
                        }
                    }
                    let discrim = bytes[0];
                    let payload_offset = <Self as wasmtime::component::__internal::ComponentVariant>::PAYLOAD_OFFSET32;
                    let payload = &bytes[payload_offset..];
                    let ty = match ty {
                        wasmtime::component::__internal::InterfaceType::Variant(i) => {
                            &cx.types[i]
                        }
                        _ => wasmtime::component::__internal::bad_type_info(),
                    };
                    Ok(
                        match discrim {
                            0u8 => Self::StoreTableFull,
                            1u8 => Self::NoSuchStore,
                            2u8 => Self::AccessDenied,
                            3u8 => Self::InvalidStore,
                            4u8 => Self::NoSuchKey,
                            5u8 => {
                                Self::Io(
                                    <String as wasmtime::component::Lift>::load(
                                        cx,
                                        ty
                                            .cases[5usize]
                                            .ty
                                            .unwrap_or_else(
                                                wasmtime::component::__internal::bad_type_info,
                                            ),
                                        &payload[..<String as wasmtime::component::ComponentType>::SIZE32],
                                    )?,
                                )
                            }
                            discrim => {
                                return ::anyhow::__private::Err(
                                    ::anyhow::Error::msg({
                                        let res = ::alloc::fmt::format(
                                            format_args!("unexpected discriminant: {0}", discrim),
                                        );
                                        res
                                    }),
                                );
                            }
                        },
                    )
                }
            }
            const _: () = {
                #[doc(hidden)]
                #[repr(C)]
                pub struct LowerError<T5: Copy> {
                    tag: wasmtime::ValRaw,
                    payload: LowerPayloadError<T5>,
                }
                #[automatically_derived]
                impl<T5: ::core::clone::Clone + Copy> ::core::clone::Clone
                for LowerError<T5> {
                    #[inline]
                    fn clone(&self) -> LowerError<T5> {
                        LowerError {
                            tag: ::core::clone::Clone::clone(&self.tag),
                            payload: ::core::clone::Clone::clone(&self.payload),
                        }
                    }
                }
                #[automatically_derived]
                impl<T5: ::core::marker::Copy + Copy> ::core::marker::Copy
                for LowerError<T5> {}
                #[doc(hidden)]
                #[allow(non_snake_case)]
                #[repr(C)]
                union LowerPayloadError<T5: Copy> {
                    StoreTableFull: [wasmtime::ValRaw; 0],
                    NoSuchStore: [wasmtime::ValRaw; 0],
                    AccessDenied: [wasmtime::ValRaw; 0],
                    InvalidStore: [wasmtime::ValRaw; 0],
                    NoSuchKey: [wasmtime::ValRaw; 0],
                    Io: T5,
                }
                #[automatically_derived]
                #[allow(non_snake_case)]
                impl<
                    T5: ::core::marker::Copy + ::core::clone::Clone + Copy,
                > ::core::clone::Clone for LowerPayloadError<T5> {
                    #[inline]
                    fn clone(&self) -> LowerPayloadError<T5> {
                        let _: ::core::clone::AssertParamIsCopy<Self>;
                        *self
                    }
                }
                #[automatically_derived]
                #[allow(non_snake_case)]
                impl<T5: ::core::marker::Copy + Copy> ::core::marker::Copy
                for LowerPayloadError<T5> {}
                unsafe impl wasmtime::component::ComponentType for Error {
                    type Lower = LowerError<
                        <String as wasmtime::component::ComponentType>::Lower,
                    >;
                    #[inline]
                    fn typecheck(
                        ty: &wasmtime::component::__internal::InterfaceType,
                        types: &wasmtime::component::__internal::InstanceType<'_>,
                    ) -> wasmtime::component::__internal::anyhow::Result<()> {
                        wasmtime::component::__internal::typecheck_variant(
                            ty,
                            types,
                            &[
                                ("store-table-full", None),
                                ("no-such-store", None),
                                ("access-denied", None),
                                ("invalid-store", None),
                                ("no-such-key", None),
                                (
                                    "io",
                                    Some(
                                        <String as wasmtime::component::ComponentType>::typecheck,
                                    ),
                                ),
                            ],
                        )
                    }
                    const ABI: wasmtime::component::__internal::CanonicalAbiInfo = wasmtime::component::__internal::CanonicalAbiInfo::variant_static(
                        &[
                            None,
                            None,
                            None,
                            None,
                            None,
                            Some(<String as wasmtime::component::ComponentType>::ABI),
                        ],
                    );
                }
                unsafe impl wasmtime::component::__internal::ComponentVariant for Error {
                    const CASES: &'static [Option<
                        wasmtime::component::__internal::CanonicalAbiInfo,
                    >] = &[
                        None,
                        None,
                        None,
                        None,
                        None,
                        Some(<String as wasmtime::component::ComponentType>::ABI),
                    ];
                }
            };
            impl core::fmt::Debug for Error {
                fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
                    match self {
                        Error::StoreTableFull => {
                            f.debug_tuple("Error::StoreTableFull").finish()
                        }
                        Error::NoSuchStore => {
                            f.debug_tuple("Error::NoSuchStore").finish()
                        }
                        Error::AccessDenied => {
                            f.debug_tuple("Error::AccessDenied").finish()
                        }
                        Error::InvalidStore => {
                            f.debug_tuple("Error::InvalidStore").finish()
                        }
                        Error::NoSuchKey => f.debug_tuple("Error::NoSuchKey").finish(),
                        Error::Io(e) => f.debug_tuple("Error::Io").field(e).finish(),
                    }
                }
            }
            impl core::fmt::Display for Error {
                fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
                    f.write_fmt(format_args!("{0:?}", self))
                }
            }
            impl std::error::Error for Error {}
            const _: () = {
                if !(12 == <Error as wasmtime::component::ComponentType>::SIZE32) {
                    ::core::panicking::panic(
                        "assertion failed: 12 == <Error as wasmtime::component::ComponentType>::SIZE32",
                    )
                }
                if !(4 == <Error as wasmtime::component::ComponentType>::ALIGN32) {
                    ::core::panicking::panic(
                        "assertion failed: 4 == <Error as wasmtime::component::ComponentType>::ALIGN32",
                    )
                }
            };
            pub trait Host: HostStore {}
            pub fn add_to_linker<T, U>(
                linker: &mut wasmtime::component::Linker<T>,
                get: impl Fn(&mut T) -> &mut U + Send + Sync + Copy + 'static,
            ) -> wasmtime::Result<()>
            where
                T: Send,
                U: Host + Send,
            {
                let mut inst = linker.instance("fermyon:spin/key-value@2.0.0")?;
                inst.resource::<
                        Store,
                    >(
                    "store",
                    move |mut store, rep| -> wasmtime::Result<()> {
                        HostStore::drop(
                            get(store.data_mut()),
                            wasmtime::component::Resource::new_own(rep),
                        )
                    },
                )?;
                inst.func_wrap_async(
                    "[static]store.open",
                    move |
                        mut caller: wasmtime::StoreContextMut<'_, T>,
                        (arg0,): (String,)|
                    Box::new(async move {
                        let host = get(caller.data_mut());
                        let r = HostStore::open(host, arg0).await;
                        Ok((r?,))
                    }),
                )?;
                inst.func_wrap_async(
                    "[method]store.get",
                    move |
                        mut caller: wasmtime::StoreContextMut<'_, T>,
                        (arg0, arg1): (wasmtime::component::Resource<Store>, String)|
                    Box::new(async move {
                        let host = get(caller.data_mut());
                        let r = HostStore::get(host, arg0, arg1).await;
                        Ok((r?,))
                    }),
                )?;
                inst.func_wrap_async(
                    "[method]store.set",
                    move |
                        mut caller: wasmtime::StoreContextMut<'_, T>,
                        (
                            arg0,
                            arg1,
                            arg2,
                        ): (wasmtime::component::Resource<Store>, String, Vec<u8>)|
                    Box::new(async move {
                        let host = get(caller.data_mut());
                        let r = HostStore::set(host, arg0, arg1, arg2).await;
                        Ok((r?,))
                    }),
                )?;
                inst.func_wrap_async(
                    "[method]store.delete",
                    move |
                        mut caller: wasmtime::StoreContextMut<'_, T>,
                        (arg0, arg1): (wasmtime::component::Resource<Store>, String)|
                    Box::new(async move {
                        let host = get(caller.data_mut());
                        let r = HostStore::delete(host, arg0, arg1).await;
                        Ok((r?,))
                    }),
                )?;
                inst.func_wrap_async(
                    "[method]store.exists",
                    move |
                        mut caller: wasmtime::StoreContextMut<'_, T>,
                        (arg0, arg1): (wasmtime::component::Resource<Store>, String)|
                    Box::new(async move {
                        let host = get(caller.data_mut());
                        let r = HostStore::exists(host, arg0, arg1).await;
                        Ok((r?,))
                    }),
                )?;
                inst.func_wrap_async(
                    "[method]store.get-keys",
                    move |
                        mut caller: wasmtime::StoreContextMut<'_, T>,
                        (arg0,): (wasmtime::component::Resource<Store>,)|
                    Box::new(async move {
                        let host = get(caller.data_mut());
                        let r = HostStore::get_keys(host, arg0).await;
                        Ok((r?,))
                    }),
                )?;
                Ok(())
            }
        }
    }
}
pub mod wasi {
    pub mod logging {
        #[allow(clippy::all)]
        pub mod logging {
            #[allow(unused_imports)]
            use wasmtime::component::__internal::anyhow;
            /// A log level, describing a kind of message.
            #[component(enum)]
            pub enum Level {
                /// Describes messages about the values of variables and the flow of
                /// control within a program.
                #[component(name = "trace")]
                Trace,
                /// Describes messages likely to be of interest to someone debugging a
                /// program.
                #[component(name = "debug")]
                Debug,
                /// Describes messages likely to be of interest to someone monitoring a
                /// program.
                #[component(name = "info")]
                Info,
                /// Describes messages indicating hazardous situations.
                #[component(name = "warn")]
                Warn,
                /// Describes messages indicating serious errors.
                #[component(name = "error")]
                Error,
                /// Describes messages indicating fatal errors.
                #[component(name = "critical")]
                Critical,
            }
            #[automatically_derived]
            impl ::core::clone::Clone for Level {
                #[inline]
                fn clone(&self) -> Level {
                    *self
                }
            }
            #[automatically_derived]
            impl ::core::marker::Copy for Level {}
            #[automatically_derived]
            impl ::core::marker::StructuralPartialEq for Level {}
            #[automatically_derived]
            impl ::core::cmp::PartialEq for Level {
                #[inline]
                fn eq(&self, other: &Level) -> bool {
                    let __self_tag = ::core::intrinsics::discriminant_value(self);
                    let __arg1_tag = ::core::intrinsics::discriminant_value(other);
                    __self_tag == __arg1_tag
                }
            }
            #[automatically_derived]
            impl ::core::marker::StructuralEq for Level {}
            #[automatically_derived]
            impl ::core::cmp::Eq for Level {
                #[inline]
                #[doc(hidden)]
                #[no_coverage]
                fn assert_receiver_is_total_eq(&self) -> () {}
            }
            unsafe impl wasmtime::component::Lower for Level {
                #[inline]
                fn lower<T>(
                    &self,
                    cx: &mut wasmtime::component::__internal::LowerContext<'_, T>,
                    ty: wasmtime::component::__internal::InterfaceType,
                    dst: &mut std::mem::MaybeUninit<Self::Lower>,
                ) -> wasmtime::component::__internal::anyhow::Result<()> {
                    let ty = match ty {
                        wasmtime::component::__internal::InterfaceType::Enum(i) => {
                            &cx.types[i]
                        }
                        _ => wasmtime::component::__internal::bad_type_info(),
                    };
                    match self {
                        Self::Trace => {
                            {
                                #[allow(unused_unsafe)]
                                {
                                    unsafe {
                                        use ::wasmtime::component::__internal::MaybeUninitExt;
                                        let m: &mut std::mem::MaybeUninit<_> = dst;
                                        m.map(|p| &raw mut (*p).tag)
                                    }
                                }
                            }
                                .write(wasmtime::ValRaw::u32(0u32));
                            unsafe {
                                wasmtime::component::__internal::lower_payload(
                                    {
                                        #[allow(unused_unsafe)]
                                        {
                                            unsafe {
                                                use ::wasmtime::component::__internal::MaybeUninitExt;
                                                let m: &mut std::mem::MaybeUninit<_> = dst;
                                                m.map(|p| &raw mut (*p).payload)
                                            }
                                        }
                                    },
                                    |payload| {
                                        #[allow(unused_unsafe)]
                                        {
                                            unsafe {
                                                use ::wasmtime::component::__internal::MaybeUninitExt;
                                                let m: &mut std::mem::MaybeUninit<_> = payload;
                                                m.map(|p| &raw mut (*p).Trace)
                                            }
                                        }
                                    },
                                    |dst| Ok(()),
                                )
                            }
                        }
                        Self::Debug => {
                            {
                                #[allow(unused_unsafe)]
                                {
                                    unsafe {
                                        use ::wasmtime::component::__internal::MaybeUninitExt;
                                        let m: &mut std::mem::MaybeUninit<_> = dst;
                                        m.map(|p| &raw mut (*p).tag)
                                    }
                                }
                            }
                                .write(wasmtime::ValRaw::u32(1u32));
                            unsafe {
                                wasmtime::component::__internal::lower_payload(
                                    {
                                        #[allow(unused_unsafe)]
                                        {
                                            unsafe {
                                                use ::wasmtime::component::__internal::MaybeUninitExt;
                                                let m: &mut std::mem::MaybeUninit<_> = dst;
                                                m.map(|p| &raw mut (*p).payload)
                                            }
                                        }
                                    },
                                    |payload| {
                                        #[allow(unused_unsafe)]
                                        {
                                            unsafe {
                                                use ::wasmtime::component::__internal::MaybeUninitExt;
                                                let m: &mut std::mem::MaybeUninit<_> = payload;
                                                m.map(|p| &raw mut (*p).Debug)
                                            }
                                        }
                                    },
                                    |dst| Ok(()),
                                )
                            }
                        }
                        Self::Info => {
                            {
                                #[allow(unused_unsafe)]
                                {
                                    unsafe {
                                        use ::wasmtime::component::__internal::MaybeUninitExt;
                                        let m: &mut std::mem::MaybeUninit<_> = dst;
                                        m.map(|p| &raw mut (*p).tag)
                                    }
                                }
                            }
                                .write(wasmtime::ValRaw::u32(2u32));
                            unsafe {
                                wasmtime::component::__internal::lower_payload(
                                    {
                                        #[allow(unused_unsafe)]
                                        {
                                            unsafe {
                                                use ::wasmtime::component::__internal::MaybeUninitExt;
                                                let m: &mut std::mem::MaybeUninit<_> = dst;
                                                m.map(|p| &raw mut (*p).payload)
                                            }
                                        }
                                    },
                                    |payload| {
                                        #[allow(unused_unsafe)]
                                        {
                                            unsafe {
                                                use ::wasmtime::component::__internal::MaybeUninitExt;
                                                let m: &mut std::mem::MaybeUninit<_> = payload;
                                                m.map(|p| &raw mut (*p).Info)
                                            }
                                        }
                                    },
                                    |dst| Ok(()),
                                )
                            }
                        }
                        Self::Warn => {
                            {
                                #[allow(unused_unsafe)]
                                {
                                    unsafe {
                                        use ::wasmtime::component::__internal::MaybeUninitExt;
                                        let m: &mut std::mem::MaybeUninit<_> = dst;
                                        m.map(|p| &raw mut (*p).tag)
                                    }
                                }
                            }
                                .write(wasmtime::ValRaw::u32(3u32));
                            unsafe {
                                wasmtime::component::__internal::lower_payload(
                                    {
                                        #[allow(unused_unsafe)]
                                        {
                                            unsafe {
                                                use ::wasmtime::component::__internal::MaybeUninitExt;
                                                let m: &mut std::mem::MaybeUninit<_> = dst;
                                                m.map(|p| &raw mut (*p).payload)
                                            }
                                        }
                                    },
                                    |payload| {
                                        #[allow(unused_unsafe)]
                                        {
                                            unsafe {
                                                use ::wasmtime::component::__internal::MaybeUninitExt;
                                                let m: &mut std::mem::MaybeUninit<_> = payload;
                                                m.map(|p| &raw mut (*p).Warn)
                                            }
                                        }
                                    },
                                    |dst| Ok(()),
                                )
                            }
                        }
                        Self::Error => {
                            {
                                #[allow(unused_unsafe)]
                                {
                                    unsafe {
                                        use ::wasmtime::component::__internal::MaybeUninitExt;
                                        let m: &mut std::mem::MaybeUninit<_> = dst;
                                        m.map(|p| &raw mut (*p).tag)
                                    }
                                }
                            }
                                .write(wasmtime::ValRaw::u32(4u32));
                            unsafe {
                                wasmtime::component::__internal::lower_payload(
                                    {
                                        #[allow(unused_unsafe)]
                                        {
                                            unsafe {
                                                use ::wasmtime::component::__internal::MaybeUninitExt;
                                                let m: &mut std::mem::MaybeUninit<_> = dst;
                                                m.map(|p| &raw mut (*p).payload)
                                            }
                                        }
                                    },
                                    |payload| {
                                        #[allow(unused_unsafe)]
                                        {
                                            unsafe {
                                                use ::wasmtime::component::__internal::MaybeUninitExt;
                                                let m: &mut std::mem::MaybeUninit<_> = payload;
                                                m.map(|p| &raw mut (*p).Error)
                                            }
                                        }
                                    },
                                    |dst| Ok(()),
                                )
                            }
                        }
                        Self::Critical => {
                            {
                                #[allow(unused_unsafe)]
                                {
                                    unsafe {
                                        use ::wasmtime::component::__internal::MaybeUninitExt;
                                        let m: &mut std::mem::MaybeUninit<_> = dst;
                                        m.map(|p| &raw mut (*p).tag)
                                    }
                                }
                            }
                                .write(wasmtime::ValRaw::u32(5u32));
                            unsafe {
                                wasmtime::component::__internal::lower_payload(
                                    {
                                        #[allow(unused_unsafe)]
                                        {
                                            unsafe {
                                                use ::wasmtime::component::__internal::MaybeUninitExt;
                                                let m: &mut std::mem::MaybeUninit<_> = dst;
                                                m.map(|p| &raw mut (*p).payload)
                                            }
                                        }
                                    },
                                    |payload| {
                                        #[allow(unused_unsafe)]
                                        {
                                            unsafe {
                                                use ::wasmtime::component::__internal::MaybeUninitExt;
                                                let m: &mut std::mem::MaybeUninit<_> = payload;
                                                m.map(|p| &raw mut (*p).Critical)
                                            }
                                        }
                                    },
                                    |dst| Ok(()),
                                )
                            }
                        }
                    }
                }
                #[inline]
                fn store<T>(
                    &self,
                    cx: &mut wasmtime::component::__internal::LowerContext<'_, T>,
                    ty: wasmtime::component::__internal::InterfaceType,
                    mut offset: usize,
                ) -> wasmtime::component::__internal::anyhow::Result<()> {
                    let ty = match ty {
                        wasmtime::component::__internal::InterfaceType::Enum(i) => {
                            &cx.types[i]
                        }
                        _ => wasmtime::component::__internal::bad_type_info(),
                    };
                    if true {
                        if !(offset
                            % (<Self as wasmtime::component::ComponentType>::ALIGN32
                                as usize) == 0)
                        {
                            ::core::panicking::panic(
                                "assertion failed: offset % (<Self as wasmtime::component::ComponentType>::ALIGN32 as usize) == 0",
                            )
                        }
                    }
                    match self {
                        Self::Trace => {
                            *cx.get::<1usize>(offset) = 0u8.to_le_bytes();
                            Ok(())
                        }
                        Self::Debug => {
                            *cx.get::<1usize>(offset) = 1u8.to_le_bytes();
                            Ok(())
                        }
                        Self::Info => {
                            *cx.get::<1usize>(offset) = 2u8.to_le_bytes();
                            Ok(())
                        }
                        Self::Warn => {
                            *cx.get::<1usize>(offset) = 3u8.to_le_bytes();
                            Ok(())
                        }
                        Self::Error => {
                            *cx.get::<1usize>(offset) = 4u8.to_le_bytes();
                            Ok(())
                        }
                        Self::Critical => {
                            *cx.get::<1usize>(offset) = 5u8.to_le_bytes();
                            Ok(())
                        }
                    }
                }
            }
            unsafe impl wasmtime::component::Lift for Level {
                #[inline]
                fn lift(
                    cx: &mut wasmtime::component::__internal::LiftContext<'_>,
                    ty: wasmtime::component::__internal::InterfaceType,
                    src: &Self::Lower,
                ) -> wasmtime::component::__internal::anyhow::Result<Self> {
                    let ty = match ty {
                        wasmtime::component::__internal::InterfaceType::Enum(i) => {
                            &cx.types[i]
                        }
                        _ => wasmtime::component::__internal::bad_type_info(),
                    };
                    Ok(
                        match src.tag.get_u32() {
                            0u32 => Self::Trace,
                            1u32 => Self::Debug,
                            2u32 => Self::Info,
                            3u32 => Self::Warn,
                            4u32 => Self::Error,
                            5u32 => Self::Critical,
                            discrim => {
                                return ::anyhow::__private::Err(
                                    ::anyhow::Error::msg({
                                        let res = ::alloc::fmt::format(
                                            format_args!("unexpected discriminant: {0}", discrim),
                                        );
                                        res
                                    }),
                                );
                            }
                        },
                    )
                }
                #[inline]
                fn load(
                    cx: &mut wasmtime::component::__internal::LiftContext<'_>,
                    ty: wasmtime::component::__internal::InterfaceType,
                    bytes: &[u8],
                ) -> wasmtime::component::__internal::anyhow::Result<Self> {
                    let align = <Self as wasmtime::component::ComponentType>::ALIGN32;
                    if true {
                        if !((bytes.as_ptr() as usize) % (align as usize) == 0) {
                            ::core::panicking::panic(
                                "assertion failed: (bytes.as_ptr() as usize) % (align as usize) == 0",
                            )
                        }
                    }
                    let discrim = bytes[0];
                    let payload_offset = <Self as wasmtime::component::__internal::ComponentVariant>::PAYLOAD_OFFSET32;
                    let payload = &bytes[payload_offset..];
                    let ty = match ty {
                        wasmtime::component::__internal::InterfaceType::Enum(i) => {
                            &cx.types[i]
                        }
                        _ => wasmtime::component::__internal::bad_type_info(),
                    };
                    Ok(
                        match discrim {
                            0u8 => Self::Trace,
                            1u8 => Self::Debug,
                            2u8 => Self::Info,
                            3u8 => Self::Warn,
                            4u8 => Self::Error,
                            5u8 => Self::Critical,
                            discrim => {
                                return ::anyhow::__private::Err(
                                    ::anyhow::Error::msg({
                                        let res = ::alloc::fmt::format(
                                            format_args!("unexpected discriminant: {0}", discrim),
                                        );
                                        res
                                    }),
                                );
                            }
                        },
                    )
                }
            }
            const _: () = {
                #[doc(hidden)]
                #[repr(C)]
                pub struct LowerLevel {
                    tag: wasmtime::ValRaw,
                    payload: LowerPayloadLevel,
                }
                #[automatically_derived]
                impl ::core::clone::Clone for LowerLevel {
                    #[inline]
                    fn clone(&self) -> LowerLevel {
                        let _: ::core::clone::AssertParamIsClone<wasmtime::ValRaw>;
                        let _: ::core::clone::AssertParamIsClone<LowerPayloadLevel>;
                        *self
                    }
                }
                #[automatically_derived]
                impl ::core::marker::Copy for LowerLevel {}
                #[doc(hidden)]
                #[allow(non_snake_case)]
                #[repr(C)]
                union LowerPayloadLevel {
                    Trace: [wasmtime::ValRaw; 0],
                    Debug: [wasmtime::ValRaw; 0],
                    Info: [wasmtime::ValRaw; 0],
                    Warn: [wasmtime::ValRaw; 0],
                    Error: [wasmtime::ValRaw; 0],
                    Critical: [wasmtime::ValRaw; 0],
                }
                #[automatically_derived]
                #[allow(non_snake_case)]
                impl ::core::clone::Clone for LowerPayloadLevel {
                    #[inline]
                    fn clone(&self) -> LowerPayloadLevel {
                        let _: ::core::clone::AssertParamIsCopy<Self>;
                        *self
                    }
                }
                #[automatically_derived]
                #[allow(non_snake_case)]
                impl ::core::marker::Copy for LowerPayloadLevel {}
                unsafe impl wasmtime::component::ComponentType for Level {
                    type Lower = LowerLevel;
                    #[inline]
                    fn typecheck(
                        ty: &wasmtime::component::__internal::InterfaceType,
                        types: &wasmtime::component::__internal::InstanceType<'_>,
                    ) -> wasmtime::component::__internal::anyhow::Result<()> {
                        wasmtime::component::__internal::typecheck_enum(
                            ty,
                            types,
                            &["trace", "debug", "info", "warn", "error", "critical"],
                        )
                    }
                    const ABI: wasmtime::component::__internal::CanonicalAbiInfo = wasmtime::component::__internal::CanonicalAbiInfo::variant_static(
                        &[None, None, None, None, None, None],
                    );
                }
                unsafe impl wasmtime::component::__internal::ComponentVariant for Level {
                    const CASES: &'static [Option<
                        wasmtime::component::__internal::CanonicalAbiInfo,
                    >] = &[None, None, None, None, None, None];
                }
            };
            impl core::fmt::Debug for Level {
                fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
                    match self {
                        Level::Trace => f.debug_tuple("Level::Trace").finish(),
                        Level::Debug => f.debug_tuple("Level::Debug").finish(),
                        Level::Info => f.debug_tuple("Level::Info").finish(),
                        Level::Warn => f.debug_tuple("Level::Warn").finish(),
                        Level::Error => f.debug_tuple("Level::Error").finish(),
                        Level::Critical => f.debug_tuple("Level::Critical").finish(),
                    }
                }
            }
            const _: () = {
                if !(1 == <Level as wasmtime::component::ComponentType>::SIZE32) {
                    ::core::panicking::panic(
                        "assertion failed: 1 == <Level as wasmtime::component::ComponentType>::SIZE32",
                    )
                }
                if !(1 == <Level as wasmtime::component::ComponentType>::ALIGN32) {
                    ::core::panicking::panic(
                        "assertion failed: 1 == <Level as wasmtime::component::ComponentType>::ALIGN32",
                    )
                }
            };
            pub trait Host {
                /// Emit a log message.
                ///
                /// A log message has a `level` describing what kind of message is being
                /// sent, a context, which is an uninterpreted string meant to help
                /// consumers group similar messages, and a string containing the message
                /// text.
                #[must_use]
                #[allow(clippy::type_complexity, clippy::type_repetition_in_bounds)]
                fn log<'life0, 'async_trait>(
                    &'life0 mut self,
                    level: Level,
                    context: String,
                    message: String,
                ) -> ::core::pin::Pin<
                    Box<
                        dyn ::core::future::Future<
                            Output = wasmtime::Result<()>,
                        > + ::core::marker::Send + 'async_trait,
                    >,
                >
                where
                    'life0: 'async_trait,
                    Self: 'async_trait;
            }
            pub fn add_to_linker<T, U>(
                linker: &mut wasmtime::component::Linker<T>,
                get: impl Fn(&mut T) -> &mut U + Send + Sync + Copy + 'static,
            ) -> wasmtime::Result<()>
            where
                T: Send,
                U: Host + Send,
            {
                let mut inst = linker.instance("wasi:logging/logging")?;
                inst.func_wrap_async(
                    "log",
                    move |
                        mut caller: wasmtime::StoreContextMut<'_, T>,
                        (arg0, arg1, arg2): (Level, String, String)|
                    Box::new(async move {
                        let host = get(caller.data_mut());
                        let r = Host::log(host, arg0, arg1, arg2).await;
                        r
                    }),
                )?;
                Ok(())
            }
        }
    }
}
pub mod exports {
    pub mod fermyon {
        pub mod spin {
            #[allow(clippy::all)]
            pub mod inbound_http {
                #[allow(unused_imports)]
                use wasmtime::component::__internal::anyhow;
                pub type Request = super::super::super::super::fermyon::spin::http_types::Request;
                const _: () = {
                    if !(40 == <Request as wasmtime::component::ComponentType>::SIZE32) {
                        ::core::panicking::panic(
                            "assertion failed: 40 == <Request as wasmtime::component::ComponentType>::SIZE32",
                        )
                    }
                    if !(4 == <Request as wasmtime::component::ComponentType>::ALIGN32) {
                        ::core::panicking::panic(
                            "assertion failed: 4 == <Request as wasmtime::component::ComponentType>::ALIGN32",
                        )
                    }
                };
                pub type Response = super::super::super::super::fermyon::spin::http_types::Response;
                const _: () = {
                    if !(28 == <Response as wasmtime::component::ComponentType>::SIZE32)
                    {
                        ::core::panicking::panic(
                            "assertion failed: 28 == <Response as wasmtime::component::ComponentType>::SIZE32",
                        )
                    }
                    if !(4 == <Response as wasmtime::component::ComponentType>::ALIGN32)
                    {
                        ::core::panicking::panic(
                            "assertion failed: 4 == <Response as wasmtime::component::ComponentType>::ALIGN32",
                        )
                    }
                };
                pub struct InboundHttp {
                    handle_request: wasmtime::component::Func,
                }
                impl InboundHttp {
                    pub fn new(
                        __exports: &mut wasmtime::component::ExportInstance<'_, '_>,
                    ) -> wasmtime::Result<InboundHttp> {
                        let handle_request = *__exports
                            .typed_func::<(&Request,), (Response,)>("handle-request")?
                            .func();
                        Ok(InboundHttp { handle_request })
                    }
                    pub async fn call_handle_request<S: wasmtime::AsContextMut>(
                        &self,
                        mut store: S,
                        arg0: &Request,
                    ) -> wasmtime::Result<Response>
                    where
                        <S as wasmtime::AsContext>::Data: Send,
                    {
                        let callee = unsafe {
                            wasmtime::component::TypedFunc::<
                                (&Request,),
                                (Response,),
                            >::new_unchecked(self.handle_request)
                        };
                        let (ret0,) = callee
                            .call_async(store.as_context_mut(), (arg0,))
                            .await?;
                        callee.post_return_async(store.as_context_mut()).await?;
                        Ok(ret0)
                    }
                }
            }
            #[allow(clippy::all)]
            pub mod inbound_redis {
                #[allow(unused_imports)]
                use wasmtime::component::__internal::anyhow;
                pub type Payload = super::super::super::super::fermyon::spin::redis_types::Payload;
                const _: () = {
                    if !(8 == <Payload as wasmtime::component::ComponentType>::SIZE32) {
                        ::core::panicking::panic(
                            "assertion failed: 8 == <Payload as wasmtime::component::ComponentType>::SIZE32",
                        )
                    }
                    if !(4 == <Payload as wasmtime::component::ComponentType>::ALIGN32) {
                        ::core::panicking::panic(
                            "assertion failed: 4 == <Payload as wasmtime::component::ComponentType>::ALIGN32",
                        )
                    }
                };
                pub type Error = super::super::super::super::fermyon::spin::redis_types::Error;
                const _: () = {
                    if !(1 == <Error as wasmtime::component::ComponentType>::SIZE32) {
                        ::core::panicking::panic(
                            "assertion failed: 1 == <Error as wasmtime::component::ComponentType>::SIZE32",
                        )
                    }
                    if !(1 == <Error as wasmtime::component::ComponentType>::ALIGN32) {
                        ::core::panicking::panic(
                            "assertion failed: 1 == <Error as wasmtime::component::ComponentType>::ALIGN32",
                        )
                    }
                };
                pub struct InboundRedis {
                    handle_message: wasmtime::component::Func,
                }
                impl InboundRedis {
                    pub fn new(
                        __exports: &mut wasmtime::component::ExportInstance<'_, '_>,
                    ) -> wasmtime::Result<InboundRedis> {
                        let handle_message = *__exports
                            .typed_func::<
                                (&Payload,),
                                (Result<(), Error>,),
                            >("handle-message")?
                            .func();
                        Ok(InboundRedis { handle_message })
                    }
                    pub async fn call_handle_message<S: wasmtime::AsContextMut>(
                        &self,
                        mut store: S,
                        arg0: &Payload,
                    ) -> wasmtime::Result<Result<(), Error>>
                    where
                        <S as wasmtime::AsContext>::Data: Send,
                    {
                        let callee = unsafe {
                            wasmtime::component::TypedFunc::<
                                (&Payload,),
                                (Result<(), Error>,),
                            >::new_unchecked(self.handle_message)
                        };
                        let (ret0,) = callee
                            .call_async(store.as_context_mut(), (arg0,))
                            .await?;
                        callee.post_return_async(store.as_context_mut()).await?;
                        Ok(ret0)
                    }
                }
            }
        }
    }
}
const _: &str = "package wasi:io\n\nworld imports {\n    import streams\n    import poll\n}\n";
const _: &str = "package wasi:io\n\n/// WASI I/O is an I/O abstraction API which is currently focused on providing\n/// stream types.\n///\n/// In the future, the component model is expected to add built-in stream types;\n/// when it does, they are expected to subsume this API.\ninterface streams {\n    use poll.{pollable}\n\n    /// An error for input-stream and output-stream operations.\n    variant stream-error {\n        /// The last operation (a write or flush) failed before completion.\n        ///\n        /// More information is available in the `error` payload.\n        last-operation-failed(error),\n        /// The stream is closed: no more input will be accepted by the\n        /// stream. A closed output-stream will return this error on all\n        /// future operations.\n        closed\n    }\n\n    /// Contextual error information about the last failure that happened on\n    /// a read, write, or flush from an `input-stream` or `output-stream`.\n    ///\n    /// This type is returned through the `stream-error` type whenever an\n    /// operation on a stream directly fails or an error is discovered\n    /// after-the-fact, for example when a write\'s failure shows up through a\n    /// later `flush` or `check-write`.\n    ///\n    /// Interfaces such as `wasi:filesystem/types` provide functionality to\n    /// further \"downcast\" this error into interface-specific error information.\n    resource error {\n        /// Returns a string that\'s suitable to assist humans in debugging this\n        /// error.\n        ///\n        /// The returned string will change across platforms and hosts which\n        /// means that parsing it, for example, would be a\n        /// platform-compatibility hazard.\n        to-debug-string: func() -> string\n    }\n\n    /// An input bytestream.\n    ///\n    /// `input-stream`s are *non-blocking* to the extent practical on underlying\n    /// platforms. I/O operations always return promptly; if fewer bytes are\n    /// promptly available than requested, they return the number of bytes promptly\n    /// available, which could even be zero. To wait for data to be available,\n    /// use the `subscribe` function to obtain a `pollable` which can be polled\n    /// for using `wasi:io/poll`.\n    resource input-stream {\n        /// Perform a non-blocking read from the stream.\n        ///\n        /// This function returns a list of bytes containing the data that was\n        /// read, along with a `stream-status` which, indicates whether further\n        /// reads are expected to produce data. The returned list will contain up to\n        /// `len` bytes; it may return fewer than requested, but not more. An\n        /// empty list and `stream-status:open` indicates no more data is\n        /// available at this time, and that the pollable given by `subscribe`\n        /// will be ready when more data is available.\n        ///\n        /// Once a stream has reached the end, subsequent calls to `read` or\n        /// `skip` will always report `stream-status:ended` rather than producing more\n        /// data.\n        ///\n        /// When the caller gives a `len` of 0, it represents a request to read 0\n        /// bytes. This read should  always succeed and return an empty list and\n        /// the current `stream-status`.\n        ///\n        /// The `len` parameter is a `u64`, which could represent a list of u8 which\n        /// is not possible to allocate in wasm32, or not desirable to allocate as\n        /// as a return value by the callee. The callee may return a list of bytes\n        /// less than `len` in size while more bytes are available for reading.\n        read: func(\n            /// The maximum number of bytes to read\n            len: u64\n        ) -> result<list<u8>, stream-error>\n\n        /// Read bytes from a stream, after blocking until at least one byte can\n        /// be read. Except for blocking, identical to `read`.\n        blocking-read: func(\n            /// The maximum number of bytes to read\n            len: u64\n        ) -> result<list<u8>, stream-error>\n\n        /// Skip bytes from a stream.\n        ///\n        /// This is similar to the `read` function, but avoids copying the\n        /// bytes into the instance.\n        ///\n        /// Once a stream has reached the end, subsequent calls to read or\n        /// `skip` will always report end-of-stream rather than producing more\n        /// data.\n        ///\n        /// This function returns the number of bytes skipped, along with a\n        /// `stream-status` indicating whether the end of the stream was\n        /// reached. The returned value will be at most `len`; it may be less.\n        skip: func(\n            /// The maximum number of bytes to skip.\n            len: u64,\n        ) -> result<u64, stream-error>\n\n        /// Skip bytes from a stream, after blocking until at least one byte\n        /// can be skipped. Except for blocking behavior, identical to `skip`.\n        blocking-skip: func(\n            /// The maximum number of bytes to skip.\n            len: u64,\n        ) -> result<u64, stream-error>\n\n        /// Create a `pollable` which will resolve once either the specified stream\n        /// has bytes available to read or the other end of the stream has been\n        /// closed.\n        /// The created `pollable` is a child resource of the `input-stream`.\n        /// Implementations may trap if the `input-stream` is dropped before\n        /// all derived `pollable`s created with this function are dropped.\n        subscribe: func() -> pollable\n    }\n\n\n    /// An output bytestream.\n    ///\n    /// `output-stream`s are *non-blocking* to the extent practical on\n    /// underlying platforms. Except where specified otherwise, I/O operations also\n    /// always return promptly, after the number of bytes that can be written\n    /// promptly, which could even be zero. To wait for the stream to be ready to\n    /// accept data, the `subscribe` function to obtain a `pollable` which can be\n    /// polled for using `wasi:io/poll`.\n    resource output-stream {\n        /// Check readiness for writing. This function never blocks.\n        ///\n        /// Returns the number of bytes permitted for the next call to `write`,\n        /// or an error. Calling `write` with more bytes than this function has\n        /// permitted will trap.\n        ///\n        /// When this function returns 0 bytes, the `subscribe` pollable will\n        /// become ready when this function will report at least 1 byte, or an\n        /// error.\n        check-write: func() -> result<u64, stream-error>\n\n        /// Perform a write. This function never blocks.\n        ///\n        /// Precondition: check-write gave permit of Ok(n) and contents has a\n        /// length of less than or equal to n. Otherwise, this function will trap.\n        ///\n        /// returns Err(closed) without writing if the stream has closed since\n        /// the last call to check-write provided a permit.\n        write: func(\n            contents: list<u8>\n        ) -> result<_, stream-error>\n\n        /// Perform a write of up to 4096 bytes, and then flush the stream. Block\n        /// until all of these operations are complete, or an error occurs.\n        ///\n        /// This is a convenience wrapper around the use of `check-write`,\n        /// `subscribe`, `write`, and `flush`, and is implemented with the\n        /// following pseudo-code:\n        ///\n        /// ```text\n        /// let pollable = this.subscribe();\n        /// while !contents.is_empty() {\n        ///     // Wait for the stream to become writable\n        ///     poll-one(pollable);\n        ///     let Ok(n) = this.check-write(); // eliding error handling\n        ///     let len = min(n, contents.len());\n        ///     let (chunk, rest) = contents.split_at(len);\n        ///     this.write(chunk  );            // eliding error handling\n        ///     contents = rest;\n        /// }\n        /// this.flush();\n        /// // Wait for completion of `flush`\n        /// poll-one(pollable);\n        /// // Check for any errors that arose during `flush`\n        /// let _ = this.check-write();         // eliding error handling\n        /// ```\n        blocking-write-and-flush: func(\n            contents: list<u8>\n        ) -> result<_, stream-error>\n\n        /// Request to flush buffered output. This function never blocks.\n        ///\n        /// This tells the output-stream that the caller intends any buffered\n        /// output to be flushed. the output which is expected to be flushed\n        /// is all that has been passed to `write` prior to this call.\n        ///\n        /// Upon calling this function, the `output-stream` will not accept any\n        /// writes (`check-write` will return `ok(0)`) until the flush has\n        /// completed. The `subscribe` pollable will become ready when the\n        /// flush has completed and the stream can accept more writes.\n        flush: func() -> result<_, stream-error>\n\n        /// Request to flush buffered output, and block until flush completes\n        /// and stream is ready for writing again.\n        blocking-flush: func() -> result<_, stream-error>\n\n        /// Create a `pollable` which will resolve once the output-stream\n        /// is ready for more writing, or an error has occured. When this\n        /// pollable is ready, `check-write` will return `ok(n)` with n>0, or an\n        /// error.\n        ///\n        /// If the stream is closed, this pollable is always ready immediately.\n        ///\n        /// The created `pollable` is a child resource of the `output-stream`.\n        /// Implementations may trap if the `output-stream` is dropped before\n        /// all derived `pollable`s created with this function are dropped.\n        subscribe: func() -> pollable\n\n        /// Write zeroes to a stream.\n        ///\n        /// this should be used precisely like `write` with the exact same\n        /// preconditions (must use check-write first), but instead of\n        /// passing a list of bytes, you simply pass the number of zero-bytes\n        /// that should be written.\n        write-zeroes: func(\n            /// The number of zero-bytes to write\n            len: u64\n        ) -> result<_, stream-error>\n\n        /// Perform a write of up to 4096 zeroes, and then flush the stream.\n        /// Block until all of these operations are complete, or an error\n        /// occurs.\n        ///\n        /// This is a convenience wrapper around the use of `check-write`,\n        /// `subscribe`, `write-zeroes`, and `flush`, and is implemented with\n        /// the following pseudo-code:\n        ///\n        /// ```text\n        /// let pollable = this.subscribe();\n        /// while num_zeroes != 0 {\n        ///     // Wait for the stream to become writable\n        ///     poll-one(pollable);\n        ///     let Ok(n) = this.check-write(); // eliding error handling\n        ///     let len = min(n, num_zeroes);\n        ///     this.write-zeroes(len);         // eliding error handling\n        ///     num_zeroes -= len;\n        /// }\n        /// this.flush();\n        /// // Wait for completion of `flush`\n        /// poll-one(pollable);\n        /// // Check for any errors that arose during `flush`\n        /// let _ = this.check-write();         // eliding error handling\n        /// ```\n        blocking-write-zeroes-and-flush: func(\n            /// The number of zero-bytes to write\n            len: u64\n        ) -> result<_, stream-error>\n\n        /// Read from one stream and write to another.\n        ///\n        /// This function returns the number of bytes transferred; it may be less\n        /// than `len`.\n        ///\n        /// Unlike other I/O functions, this function blocks until all the data\n        /// read from the input stream has been written to the output stream.\n        splice: func(\n            /// The stream to read from\n            src: input-stream,\n            /// The number of bytes to splice\n            len: u64,\n        ) -> result<u64, stream-error>\n\n        /// Read from one stream and write to another, with blocking.\n        ///\n        /// This is similar to `splice`, except that it blocks until at least\n        /// one byte can be read.\n        blocking-splice: func(\n            /// The stream to read from\n            src: input-stream,\n            /// The number of bytes to splice\n            len: u64,\n        ) -> result<u64, stream-error>\n\n        /// Forward the entire contents of an input stream to an output stream.\n        ///\n        /// This function repeatedly reads from the input stream and writes\n        /// the data to the output stream, until the end of the input stream\n        /// is reached, or an error is encountered.\n        ///\n        /// Unlike other I/O functions, this function blocks until the end\n        /// of the input stream is seen and all the data has been written to\n        /// the output stream.\n        ///\n        /// This function returns the number of bytes transferred, and the status of\n        /// the output stream.\n        forward: func(\n            /// The stream to read from\n            src: input-stream\n        ) -> result<u64, stream-error>\n    }\n}\n";
const _: &str = "package wasi:io\n\n/// A poll API intended to let users wait for I/O events on multiple handles\n/// at once.\ninterface poll {\n    /// A \"pollable\" handle.\n    resource pollable\n\n    /// Poll for completion on a set of pollables.\n    ///\n    /// This function takes a list of pollables, which identify I/O sources of\n    /// interest, and waits until one or more of the events is ready for I/O.\n    ///\n    /// The result `list<u32>` contains one or more indices of handles in the\n    /// argument list that is ready for I/O.\n    ///\n    /// If the list contains more elements than can be indexed with a `u32`\n    /// value, this function traps.\n    ///\n    /// A timeout can be implemented by adding a pollable from the\n    /// wasi-clocks API to the list.\n    ///\n    /// This function does not return a `result`; polling in itself does not\n    /// do any I/O so it doesn\'t fail. If any of the I/O sources identified by\n    /// the pollables has an error, it is indicated by marking the source as\n    /// being reaedy for I/O.\n    poll-list: func(in: list<borrow<pollable>>) -> list<u32>\n\n    /// Poll for completion on a single pollable.\n    ///\n    /// This function is similar to `poll-list`, but operates on only a single\n    /// pollable. When it returns, the handle is ready for I/O.\n    poll-one: func(in: borrow<pollable>)\n}\n";
const _: &str = "// The `wasi:http/incoming-handler` interface is meant to be exported by\n// components and called by the host in response to a new incoming HTTP\n// response.\n//\n//   NOTE: in Preview3, this interface will be merged with\n//   `wasi:http/outgoing-handler` into a single `wasi:http/handler` interface\n//   that takes a `request` parameter and returns a `response` result.\n//\ninterface incoming-handler {\n  use types.{incoming-request, response-outparam}\n\n  // The `handle` function takes an outparam instead of returning its response\n  // so that the component may stream its response while streaming any other\n  // request or response bodies. The callee MUST write a response to the\n  // `response-outparam` and then finish the response before returning. The `handle`\n  // function is allowed to continue execution after finishing the response\'s\n  // output stream. While this post-response execution is taken off the\n  // critical path, since there is no return value, there is no way to report\n  // its success or failure.\n  handle: func(\n    request: incoming-request,\n    response-out: response-outparam\n  )\n}\n";
const _: &str = "// The `wasi:http/outgoing-handler` interface is meant to be imported by\n// components and implemented by the host.\n//\n//   NOTE: in Preview3, this interface will be merged with\n//   `wasi:http/outgoing-handler` into a single `wasi:http/handler` interface\n//   that takes a `request` parameter and returns a `response` result.\n//\ninterface outgoing-handler {\n  use types.{outgoing-request, request-options, future-incoming-response, error}\n\n  // The parameter and result types of the `handle` function allow the caller\n  // to concurrently stream the bodies of the outgoing request and the incoming\n  // response.\n  // Consumes the outgoing-request. Gives an error if the outgoing-request\n  // is invalid or cannot be satisfied by this handler.\n  handle: func(\n    request: outgoing-request,\n    options: option<request-options>\n  ) -> result<future-incoming-response, error>\n}\n";
const _: &str = "package wasi:http\n\n// The `wasi:http/types` interface is meant to be imported by components to\n// define the HTTP resource types and operations used by the component\'s\n// imported and exported interfaces.\ninterface types {\n  use wasi:io/streams.{input-stream, output-stream}\n  use wasi:io/poll.{pollable}\n\n  // This type corresponds to HTTP standard Methods.\n  variant method {\n    get,\n    head,\n    post,\n    put,\n    delete,\n    connect,\n    options,\n    trace,\n    patch,\n    other(string)\n  }\n\n  // This type corresponds to HTTP standard Related Schemes.\n  variant scheme {\n    HTTP,\n    HTTPS,\n    other(string)\n  }\n\n  // TODO: perhaps better align with HTTP semantics?\n  // This type enumerates the different kinds of errors that may occur when\n  // initially returning a response.\n  variant error {\n    invalid-url(string),\n    timeout-error(string),\n    protocol-error(string),\n    unexpected-error(string)\n  }\n\n  // This following block defines the `fields` resource which corresponds to\n  // HTTP standard Fields. Soon, when resource types are added, the `type\n  // fields = u32` type alias can be replaced by a proper `resource fields`\n  // definition containing all the functions using the method syntactic sugar.\n  resource fields {\n    // Multiple values for a header are multiple entries in the list with the\n    // same key.\n    constructor(entries: list<tuple<string,list<u8>>>)\n\n    // Values off wire are not necessarily well formed, so they are given by\n    // list<u8> instead of string.\n    get: func(name: string) -> list<list<u8>>\n\n    // Values off wire are not necessarily well formed, so they are given by\n    // list<u8> instead of string.\n    set: func(name: string, value: list<list<u8>>)\n    delete: func(name: string)\n    append: func(name: string, value: list<u8>)\n\n    // Values off wire are not necessarily well formed, so they are given by\n    // list<u8> instead of string.\n    entries: func() -> list<tuple<string,list<u8>>>\n\n    // Deep copy of all contents in a fields.\n    clone: func() -> fields\n  }\n\n  type headers = fields\n  type trailers = fields\n\n  // The following block defines the `incoming-request` and `outgoing-request`\n  // resource types that correspond to HTTP standard Requests. Soon, when\n  // resource types are added, the `u32` type aliases can be replaced by\n  // proper `resource` type definitions containing all the functions as\n  // methods. Later, Preview2 will allow both types to be merged together into\n  // a single `request` type (that uses the single `stream` type mentioned\n  // above). The `consume` and `write` methods may only be called once (and\n  // return failure thereafter).\n  resource incoming-request {\n    method: func() -> method\n\n    path-with-query: func() -> option<string>\n\n    scheme: func() -> option<scheme>\n\n    authority: func() -> option<string>\n\n    headers: func() -> /* child */ headers\n    // Will return the input-stream child at most once. If called more than\n    // once, subsequent calls will return error.\n\n    consume: func() -> result<incoming-body>\n  }\n\n  resource outgoing-request {\n    constructor(\n      method: method,\n      path-with-query: option<string>,\n      scheme: option<scheme>,\n      authority: option<string>,\n      headers: borrow<headers>\n    )\n\n    // Will return the outgoing-body child at most once. If called more than\n    // once, subsequent calls will return error.\n    write: func() -> result< /* child */ outgoing-body>\n  }\n\n  // Additional optional parameters that can be set when making a request.\n  record request-options {\n    // The following timeouts are specific to the HTTP protocol and work\n    // independently of the overall timeouts passed to `io.poll.poll-list`.\n\n    // The timeout for the initial connect.\n    connect-timeout-ms: option<u32>,\n\n    // The timeout for receiving the first byte of the response body.\n    first-byte-timeout-ms: option<u32>,\n\n    // The timeout for receiving the next chunk of bytes in the response body\n    // stream.\n    between-bytes-timeout-ms: option<u32>\n  }\n\n  // The following block defines a special resource type used by the\n  // `wasi:http/incoming-handler` interface. When resource types are added, this\n  // block can be replaced by a proper `resource response-outparam { ... }`\n  // definition. Later, with Preview3, the need for an outparam goes away entirely\n  // (the `wasi:http/handler` interface used for both incoming and outgoing can\n  // simply return a `stream`).\n  resource response-outparam {\n    set: static func(param: response-outparam, response: result<outgoing-response, error>)\n  }\n\n  // This type corresponds to the HTTP standard Status Code.\n  type status-code = u16\n\n  // The following block defines the `incoming-response` and `outgoing-response`\n  // resource types that correspond to HTTP standard Responses. Soon, when\n  // resource types are added, the `u32` type aliases can be replaced by proper\n  // `resource` type definitions containing all the functions as methods. Later,\n  // Preview2 will allow both types to be merged together into a single `response`\n  // type (that uses the single `stream` type mentioned above). The `consume` and\n  // `write` methods may only be called once (and return failure thereafter).\n  resource incoming-response {\n    status: func() -> status-code\n\n    headers: func() -> /* child */ headers\n\n    // May be called at most once. returns error if called additional times.\n    // TODO: make incoming-request-consume work the same way, giving a child\n    // incoming-body.\n    consume: func() -> result<incoming-body>\n  }\n\n  resource incoming-body {\n    // returned input-stream is a child - the implementation may trap if\n    // incoming-body is dropped (or consumed by call to\n    // incoming-body-finish) before the input-stream is dropped.\n    // May be called at most once. returns error if called additional times.\n    %stream: func() -> result</* child */ input-stream>\n\n    // takes ownership of incoming-body. this will trap if the\n    // incoming-body-stream child is still alive!\n    finish: static func(this: incoming-body) ->\n    /* transitive child of the incoming-response of incoming-body */ future-trailers\n  }\n\n  resource future-trailers {\n    /// Pollable that resolves when the body has been fully read, and the trailers\n    /// are ready to be consumed.\n    subscribe: func() -> /* child */ pollable\n\n    /// Retrieve reference to trailers, if they are ready.\n    get: func() -> option<result</* child */ trailers, error>>\n  }\n\n  resource outgoing-response {\n    constructor(status-code: status-code, headers: borrow<headers>)\n\n    /// Will give the child outgoing-response at most once. subsequent calls will\n    /// return an error.\n    write: func() -> result<outgoing-body>\n  }\n\n  resource outgoing-body {\n    /// Will give the child output-stream at most once. subsequent calls will\n    /// return an error.\n    write: func() -> result</* child */ output-stream>\n\n    /// Finalize an outgoing body, optionally providing trailers. This must be\n    /// called to signal that the response is complete. If the `outgoing-body` is\n    /// dropped without calling `outgoing-body-finalize`, the implementation\n    /// should treat the body as corrupted.\n    finish: static func(this: outgoing-body, trailers: option<trailers>)\n  }\n\n  /// The following block defines a special resource type used by the\n  /// `wasi:http/outgoing-handler` interface to emulate\n  /// `future<result<response, error>>` in advance of Preview3. Given a\n  /// `future-incoming-response`, the client can call the non-blocking `get`\n  /// method to get the result if it is available. If the result is not available,\n  /// the client can call `listen` to get a `pollable` that can be passed to\n  /// `wasi:io/poll.poll-list`.\n  resource future-incoming-response {\n    /// option indicates readiness.\n    /// outer result indicates you are allowed to get the\n    /// incoming-response-or-error at most once. subsequent calls after ready\n    /// will return an error here.\n    /// inner result indicates whether the incoming-response was available, or an\n    /// error occured.\n    get: func() -> option<result<result</* NOT a child*/ incoming-response, error>>>\n\n    subscribe: func() -> /* child */ pollable\n  }\n}\n";
const _: &str = "interface redis-types {\n  // General purpose error.\n  enum error {\n      success,\n      error,\n  }\n\n  // The message payload.\n  type payload = list<u8>\n\n  // A parameter type for the general-purpose `execute` function.\n  variant redis-parameter {\n      int64(s64),\n      binary(payload)\n  }\n\n  // A return type for the general-purpose `execute` function.\n  variant redis-result {\n      nil,\n      status(string),\n      int64(s64),\n      binary(payload)\n  }\n}\n";
const _: &str = "package fermyon:spin\n\nworld host {\n  include platform\n\n  export inbound-http\n  export inbound-redis\n}\n\nworld redis-trigger {\n  include platform\n  export inbound-redis\n}\n\nworld http-trigger {\n  include platform\n  export inbound-http\n}\n\nworld wasi-http-trigger {\n  include platform\n  import wasi:http/outgoing-handler\n  export wasi:http/incoming-handler\n}\n\nworld platform {\n  import config\n  import http\n  import postgres\n  import mysql\n  import sqlite\n  import redis\n  import key-value\n  import llm\n}\n";
const _: &str = "interface http {\n    use http-types.{request, response, http-error}\n\n    send-request: func(req: request) -> result<response, http-error>\n}\n";
const _: &str = "interface config {\n  // Get a configuration value for the current component.\n  // The config key must match one defined in in the component manifest.\n  get-config: func(key: string) -> result<string, error>\n\n  variant error {\n      provider(string),\n      invalid-key(string),\n      invalid-schema(string),\n      other(string),\n  }\n}\n";
const _: &str = "interface postgres {\n  use rdbms-types.{parameter-value, row-set}\n\n  // General purpose error.\n  variant pg-error {\n      success,\n      connection-failed(string),\n      bad-parameter(string),\n      query-failed(string),\n      value-conversion-failed(string),\n      other-error(string)\n  }\n\n  // query the database: select\n  query: func(address: string, statement: string, params: list<parameter-value>) -> result<row-set, pg-error>\n\n  // execute command to the database: insert, update, delete\n  execute: func(address: string, statement: string, params: list<parameter-value>) -> result<u64, pg-error>\n}\n";
const _: &str = "interface redis {\n  use redis-types.{payload, redis-parameter, redis-result, error}\n\n  // Publish a Redis message to the specificed channel and return an error, if any.\n  publish: func(address: string, channel: string, payload: payload) -> result<_, error>\n\n  // Get the value of a key.\n  get: func(address: string, key: string) -> result<payload, error>\n\n  // Set key to value. If key alreads holds a value, it is overwritten.\n  set: func(address: string, key: string, value: payload) -> result<_, error>\n\n  // Increments the number stored at key by one. If the key does not exist, it is set to 0 before performing the operation.\n  // An error is returned if the key contains a value of the wrong type or contains a string that can not be represented as integer.\n  incr: func(address: string, key: string) -> result<s64, error>\n\n  // Removes the specified keys. A key is ignored if it does not exist.\n  del: func(address: string, keys: list<string>) -> result<s64, error>\n\n  // Add the specified `values` to the set named `key`, returning the number of newly-added values.\n  sadd: func(address: string, key: string, values: list<string>) -> result<s64, error>\n\n  // Retrieve the contents of the set named `key`.\n  smembers: func(address: string, key: string) -> result<list<string>, error>\n\n  // Remove the specified `values` from the set named `key`, returning the number of newly-removed values.\n  srem: func(address: string, key: string, values: list<string>) -> result<s64, error>\n\n  // Execute an arbitrary Redis command and receive the result.\n  execute: func(address: string, command: string, arguments: list<redis-parameter>) -> result<list<redis-result>, error>\n}\n";
const _: &str = "interface inbound-http {\n    use http-types.{request, response}\n\n    handle-request: func(req: request) -> response\n}\n";
const _: &str = "interface http-types {\n   type http-status = u16\n\n   type body = list<u8>\n\n   type headers = list<tuple<string, string>>\n\n   type params = list<tuple<string, string>>\n\n   type uri = string\n\n    enum method {\n        get,\n        post,\n        put,\n        delete,\n        patch,\n        head,\n        options,\n    }\n\n    record request {\n        method: method,\n        uri: uri,\n        headers: headers,\n        params: params,\n        body: option<body>,\n    }\n\n    record response {\n        status: http-status,\n        headers: option<headers>,\n        body: option<body>,\n    }\n\n    enum http-error {\n        success,\n        destination-not-allowed,\n        invalid-url,\n        request-error,\n        runtime-error,\n        too-many-requests,\n    }\n}\n";
const _: &str = "interface inbound-redis {\n  use redis-types.{payload, error}\n\n  // The entrypoint for a Redis handler.\n  handle-message: func(message: payload) -> result<_, error>\n}\n";
const _: &str = "interface mysql {\n  use rdbms-types.{parameter-value, row-set}\n\n  // General purpose error.\n  variant mysql-error {\n      success,\n      connection-failed(string),\n      bad-parameter(string),\n      query-failed(string),\n      value-conversion-failed(string),\n      other-error(string)\n  }\n\n  // query the database: select\n  query: func(address: string, statement: string, params: list<parameter-value>) -> result<row-set, mysql-error>\n\n  // execute command to the database: insert, update, delete\n  execute: func(address: string, statement: string, params: list<parameter-value>) -> result<_, mysql-error>\n}\n";
const _: &str = "interface key-value {\n  // A handle to an open key-value store\n  type store = u32\n\n  // The set of errors which may be raised by functions in this interface\n  variant error {\n    // Too many stores have been opened simultaneously. Closing one or more\n    // stores prior to retrying may address this.\n    store-table-full,\n\n    // The host does not recognize the store name requested.  Defining and\n    // configuring a store with that name in a runtime configuration file\n    // may address this.\n    no-such-store,\n\n    // The requesting component does not have access to the specified store\n    // (which may or may not exist).\n    access-denied,\n\n    // The store handle provided is not recognized, i.e. it was either never\n    // opened or has been closed.\n    invalid-store,\n\n    // No key-value tuple exists for the specified key in the specified\n    // store.\n    no-such-key,\n\n    // Some implementation-specific error has occurred (e.g. I/O)\n    io(string)\n  }\n\n  // Open the store with the specified name.\n  //\n  // If `name` is \"default\", the default store is opened.  Otherwise,\n  // `name` must refer to a store defined and configured in a runtime\n  // configuration file supplied with the application.\n  //\n  // `error::no-such-store` will be raised if the `name` is not recognized.\n  open: func(name: string) -> result<store, error>\n\n  // Get the value associated with the specified `key` from the specified\n  // `store`.\n  //\n  // `error::invalid-store` will be raised if `store` is not a valid handle\n  // to an open store, and `error::no-such-key` will be raised if there is no\n  // tuple for `key` in `store`.\n  get: func(store: store, key: string) -> result<list<u8>, error>\n\n  // Set the `value` associated with the specified `key` in the specified\n  // `store`, overwriting any existing value.\n  //\n  // `error::invalid-store` will be raised if `store` is not a valid handle\n  // to an open store.\n  set: func(store: store, key: string, value: list<u8>) -> result<_, error>\n\n  // Delete the tuple with the specified `key` from the specified `store`.\n  //\n  // `error::invalid-store` will be raised if `store` is not a valid handle\n  // to an open store.  No error is raised if a tuple did not previously\n  // exist for `key`.\n  delete: func(store: store, key: string) -> result<_, error>\n\n  // Return whether a tuple exists for the specified `key` in the specified\n  // `store`.\n  //\n  // `error::invalid-store` will be raised if `store` is not a valid handle\n  // to an open store.\n  exists: func(store: store, key: string) -> result<bool, error>\n\n  // Return a list of all the keys in the specified `store`.\n  //\n  // `error::invalid-store` will be raised if `store` is not a valid handle\n  // to an open store.\n  get-keys: func(store: store) -> result<list<string>, error>\n\n  // Close the specified `store`.\n  //\n  // This has no effect if `store` is not a valid handle to an open store.\n  close: func(store: store)\n}";
const _: &str = "interface sqlite {\n  // A handle to an open sqlite instance\n  type connection = u32\n\n  // The set of errors which may be raised by functions in this interface\n  variant error {\n    // The host does not recognize the database name requested.\n    no-such-database,\n    // The requesting component does not have access to the specified database (which may or may not exist).\n    access-denied,\n    // The provided connection is not valid\n    invalid-connection,\n    // The database has reached its capacity\n    database-full,\n    // Some implementation-specific error has occurred (e.g. I/O)\n    io(string)\n  }\n\n  // Open a connection to a named database instance.\n  //\n  // If `database` is \"default\", the default instance is opened.\n  //\n  // `error::no-such-database` will be raised if the `name` is not recognized.\n  open: func(database: string) -> result<connection, error>\n\n  // Execute a statement returning back data if there is any\n  execute: func(conn: connection, statement: string, parameters: list<value>) -> result<query-result, error>\n\n  // Close the specified `connection`.\n  close: func(conn: connection)\n\n  // A result of a query\n  record query-result {\n    // The names of the columns retrieved in the query\n    columns: list<string>,\n    // the row results each containing the values for all the columns for a given row\n    rows: list<row-result>,\n  }\n\n  // A set of values for each of the columns in a query-result\n  record row-result {\n    values: list<value>\n  }\n  \n  variant value {\n    integer(s64),\n    real(float64),\n    text(string),\n    blob(list<u8>),\n    null\n  }\n}";
const _: &str = "// A WASI interface dedicated to performing inferencing for Large Language Models.\ninterface llm {\n\t/// A Large Language Model.\n\ttype inferencing-model = string\n\n\t/// Inference request parameters\n\trecord inferencing-params {\n\t\t/// The maximum tokens that should be inferred.\n\t\t///\n\t\t/// Note: the backing implementation may return less tokens.\n\t\tmax-tokens: u32,\n\t\t/// The amount the model should avoid repeating tokens.\n\t\trepeat-penalty: float32,\n\t\t/// The number of tokens the model should apply the repeat penalty to.\n\t\trepeat-penalty-last-n-token-count: u32,\n\t\t/// The randomness with which the next token is selected.\n\t\ttemperature: float32,\n\t\t/// The number of possible next tokens the model will choose from.\n\t\ttop-k: u32,\n\t\t/// The probability total of next tokens the model will choose from.\n\t\ttop-p: float32\n\t}\n\n\t/// The set of errors which may be raised by functions in this interface\n\tvariant error {\n\t\tmodel-not-supported,\n\t\truntime-error(string),\n\t\tinvalid-input(string)\n\t}\n\n\t/// An inferencing result\n\trecord inferencing-result {\n\t\t/// The text generated by the model\n\t\t// TODO: this should be a stream\n\t\ttext: string,\n\t\t/// Usage information about the inferencing request\n\t\tusage: inferencing-usage\n\t}\n\n\t/// Usage information related to the inferencing result\n\trecord inferencing-usage {\n\t\t/// Number of tokens in the prompt\n\t\tprompt-token-count: u32,\n\t\t/// Number of tokens generated by the inferencing operation\n\t\tgenerated-token-count: u32\n\t}\n\n\t/// Perform inferencing using the provided model and prompt with the given optional params\n\tinfer: func(model: inferencing-model, prompt: string, params: option<inferencing-params>) -> result<inferencing-result, error>\n\n\t/// The model used for generating embeddings\n\ttype embedding-model = string\n\n\t/// Generate embeddings for the supplied list of text\n\tgenerate-embeddings: func(model: embedding-model, text: list<string>) -> result<embeddings-result, error>\n\n\t/// Result of generating embeddings\n\trecord embeddings-result {\n\t\t/// The embeddings generated by the request\n\t\tembeddings: list<list<float32>>,\n\t\t/// Usage related to the embeddings generation request\n\t\tusage: embeddings-usage\n\t}\n\n\t/// Usage related to an embeddings generation request\n\trecord embeddings-usage {\n\t\t/// Number of tokens in the prompt\n\t\tprompt-token-count: u32,\n\t}\n}\n";
const _: &str = "interface rdbms-types {\n  enum db-data-type {\n      boolean,\n      int8,\n      int16,\n      int32,\n      int64,\n      uint8,\n      uint16,\n      uint32,\n      uint64,\n      floating32,\n      floating64,\n      str,\n      binary,\n      other,\n  }\n\n  variant db-value {\n      boolean(bool),\n      int8(s8),\n      int16(s16),\n      int32(s32),\n      int64(s64),\n      uint8(u8),\n      uint16(u16),\n      uint32(u32),\n      uint64(u64),\n      floating32(float32),\n      floating64(float64),\n      str(string),\n      binary(list<u8>),\n      db-null,\n      unsupported,\n  }\n\n  variant parameter-value {\n      boolean(bool),\n      int8(s8),\n      int16(s16),\n      int32(s32),\n      int64(s64),\n      uint8(u8),\n      uint16(u16),\n      uint32(u32),\n      uint64(u64),\n      floating32(float32),\n      floating64(float64),\n      str(string),\n      binary(list<u8>),\n      db-null,\n  }\n\n  record column {\n      name: string,\n      data-type: db-data-type,\n  }\n\n  type row = list<db-value>\n\n  record row-set {\n      columns: list<column>,\n      rows: list<row>,\n  }\n}\n";
const _: &str = "package wasi:logging\n\n/// WASI Logging is a logging API intended to let users emit log messages with\n/// simple priority levels and context values.\ninterface logging {\n    /// A log level, describing a kind of message.\n    enum level {\n       /// Describes messages about the values of variables and the flow of\n       /// control within a program.\n       trace,\n\n       /// Describes messages likely to be of interest to someone debugging a\n       /// program.\n       debug,\n\n       /// Describes messages likely to be of interest to someone monitoring a\n       /// program.\n       info,\n\n       /// Describes messages indicating hazardous situations.\n       warn,\n\n       /// Describes messages indicating serious errors.\n       error,\n\n       /// Describes messages indicating fatal errors.\n       critical,\n    }\n\n    /// Emit a log message.\n    ///\n    /// A log message has a `level` describing what kind of message is being\n    /// sent, a context, which is an uninterpreted string meant to help\n    /// consumers group similar messages, and a string containing the message\n    /// text.\n    log: func(level: level, context: string, message: string)\n}";
const _: &str = "package fermyon:spin@2.0.0\n\nworld host {\n  import wasi:logging/logging\n  include fermyon:spin/host\n  \n  import sqlite\n  import key-value\n}\n\nworld redis-trigger {\n  include platform\n  export fermyon:spin/inbound-redis\n}\n\nworld http-trigger {\n  include platform\n  export fermyon:spin/inbound-http\n}\n\nworld platform {\n  import wasi:logging/logging\n  import fermyon:spin/config\n  import fermyon:spin/http\n  import fermyon:spin/postgres\n  import fermyon:spin/mysql\n  import fermyon:spin/redis\n  import fermyon:spin/llm\n\n  import sqlite\n  import key-value\n}\n";
const _: &str = "interface key-value {\n  /// An open key-value store\n  resource store {\n    /// Open the store with the specified name.\n    ///\n    /// If `name` is \"default\", the default store is opened.  Otherwise,\n    /// `name` must refer to a store defined and configured in a runtime\n    /// configuration file supplied with the application.\n    ///\n    /// `error::no-such-store` will be raised if the `name` is not recognized.\n    open: static func(name: string) -> result<store, error>\n\n    /// Get the value associated with the specified `key` from the specified\n    /// `store`.\n    ///\n    /// `error::invalid-store` will be raised if `store` is not a valid handle\n    /// to an open store, and `error::no-such-key` will be raised if there is no\n    /// tuple for `key` in `store`.\n    get: func(key: string) -> result<list<u8>, error>\n\n    /// Set the `value` associated with the specified `key` in the specified\n    /// `store`, overwriting any existing value.\n    ///\n    /// `error::invalid-store` will be raised if `store` is not a valid handle\n    /// to an open store.\n    set: func(key: string, value: list<u8>) -> result<_, error>\n\n    /// Delete the tuple with the specified `key` from the specified `store`.\n    ///\n    /// `error::invalid-store` will be raised if `store` is not a valid handle\n    /// to an open store.  No error is raised if a tuple did not previously\n    /// exist for `key`.\n    delete: func(key: string) -> result<_, error>\n\n    /// Return whether a tuple exists for the specified `key` in the specified\n    /// `store`.\n    ///\n    /// `error::invalid-store` will be raised if `store` is not a valid handle\n    /// to an open store.\n    exists: func(key: string) -> result<bool, error>\n\n    /// Return a list of all the keys in the specified `store`.\n    ///\n    /// `error::invalid-store` will be raised if `store` is not a valid handle\n    /// to an open store.\n    get-keys: func() -> result<list<string>, error>\n  }\n\n  /// The set of errors which may be raised by functions in this interface\n  variant error {\n    /// Too many stores have been opened simultaneously. Closing one or more\n    /// stores prior to retrying may address this.\n    store-table-full,\n\n    /// The host does not recognize the store name requested.  Defining and\n    /// configuring a store with that name in a runtime configuration file\n    /// may address this.\n    no-such-store,\n\n    /// The requesting component does not have access to the specified store\n    /// (which may or may not exist).\n    access-denied,\n\n    /// The store handle provided is not recognized, i.e. it was either never\n    /// opened or has been closed.\n    invalid-store,\n\n    /// No key-value tuple exists for the specified key in the specified\n    /// store.\n    no-such-key,\n\n    /// Some implementation-specific error has occurred (e.g. I/O)\n    io(string)\n  }\n}\n";
const _: &str = "interface sqlite {\n  /// A handle to an open sqlite instance\n  resource connection {\n    /// Open a connection to a named database instance.\n    ///\n    /// If `database` is \"default\", the default instance is opened.\n    ///\n    /// `error::no-such-database` will be raised if the `name` is not recognized.\n    open: static func(database: string) -> result<connection, error>\n\n    /// Execute a statement returning back data if there is any\n    execute: func(statement: string, parameters: list<value>) -> result<query-result, error>\n  }\n\n  /// The set of errors which may be raised by functions in this interface\n  variant error {\n    /// The host does not recognize the database name requested.\n    no-such-database,\n    /// The requesting component does not have access to the specified database (which may or may not exist).\n    access-denied,\n    /// The provided connection is not valid\n    invalid-connection,\n    /// The database has reached its capacity\n    database-full,\n    /// Some implementation-specific error has occurred (e.g. I/O)\n    io(string)\n  }\n\n  /// A result of a query\n  record query-result {\n    /// The names of the columns retrieved in the query\n    columns: list<string>,\n    /// the row results each containing the values for all the columns for a given row\n    rows: list<row-result>,\n  }\n\n  /// A set of values for each of the columns in a query-result\n  record row-result {\n    values: list<value>\n  }\n  \n  /// A single column\'s result from a database query\n  variant value {\n    integer(s64),\n    real(float64),\n    text(string),\n    blob(list<u8>),\n    null\n  }\n}\n";
pub use fermyon::spin as v1;
pub use fermyon::spin2_0_0 as v2;
